* copyright ( c ) 2006 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . core exception ;
import org . eclipse . jface . text . templates . template ; dcnl import org . eclipse . jface . text . templates . persistence . template store ;
import org . eclipse . jdt . core . completion context ;
import org . eclipse . jdt . internal . corext . template . java . java context type ;
/ * * dcnl * methods that are to be considered inherited even though they are overridden somewhere in the dcnl * hierarchy - notably for bridge method generation dcnl * / dcnl hashtable of object inherited overridden methods ;
this . inherited overridden methods = null ;
method binding [ ] overridden = ( method binding [ ] ) this . inherited overridden methods . get ( current method . selector ) ; dcnl if ( overridden ! = null ) { dcnl for ( int i = overridden . length ; - - i > = 0 ; ) { dcnl method binding inherited method = overridden [ i ] ; dcnl if ( !inherited method . is static ( ) & & !inherited method . is final ( ) ) dcnl check for bridge method ( current method , inherited method , all inherited methods ) ; dcnl } dcnl } dcnl } dcnl void add bridge method candidate ( method binding overridden method ) { dcnl method binding [ ] existing = ( method binding [ ] ) this . inherited overridden methods . get ( overridden method . selector ) ; dcnl if ( existing = = null ) { dcnl existing = new method binding [ ] { overridden method } ; dcnl } else { dcnl int length = existing . length ; dcnl system . arraycopy ( existing , 0 , existing = new method binding [ length + 1 ] , 0 , length ) ; dcnl existing [ length ] = overridden method ; dcnl } dcnl this . inherited overridden methods . put ( overridden method . selector , existing ) ;
this . inherited overridden methods = new hashtable of object ( 11 ) ;
if ( type binding . not equals ( inherited method . return type , existing method . return type ) & & dcnl are return types compatible ( existing method , inherited method ) ) { dcnl add bridge method candidate ( inherited method ) ; dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ / caveat : returns false if a method is implemented , but with a return type that is incompatible with that of the interface method
if ( inherited method = = null | | !does method override ( existing method , inherited method ) )
/ * * add an annotation to a resource , with linebreak ( default ) * /
try { dcnl i package fragment pack1 = current source folder . create package fragment ( "test0017" , false , null ) ; dcnl string buffer buf = new string buffer ( ) ; dcnl buf . append ( "package test0017 ; \ n" ) ; dcnl buf . append ( " \ n" ) ; dcnl buf . append ( " @ interface non null { } \ n" ) ; dcnl buf . append ( " \ n" ) ; dcnl buf . append ( "public class x { \ n" ) ; dcnl buf . append ( " void foo ( ) { \ n" ) ; dcnl buf . append ( " try ( file reader reader1 = new file reader ( \ "file1 \ " ) ; ) { \ n" ) ; dcnl buf . append ( " int ch ; \ n" ) ; dcnl buf . append ( " while ( ( ch = reader1 . read ( ) ) ! = - 1 ) { \ n" ) ; dcnl buf . append ( " system . out . println ( ch ) ; \ n" ) ; dcnl buf . append ( " } \ n" ) ; dcnl buf . append ( " } \ n" ) ; dcnl buf . append ( " } \ n" ) ; dcnl buf . append ( " } " ) ; dcnl dcnl i compilation unit cu = pack1 . create compilation unit ( "x . java" , buf . to string ( ) , false , null ) ; dcnl compilation unit ast root = create ast ( cu , true , true ) ; dcnl ast ast = ast root . get ast ( ) ; dcnl ast rewrite rewrite = ast rewrite . create ( ast ) ; dcnl dcnl block block = ( ( method declaration ) ( ( type declaration ) ast root . types ( ) . get ( 1 ) ) . body declarations ( ) . get ( 0 ) ) . get body ( ) ; dcnl list statements = block . statements ( ) ; dcnl statement statement = ( statement ) statements . get ( 0 ) ; dcnl assert true ( statement instanceof try statement ) ; dcnl dcnl try statement try statement = ( try statement ) statement ; dcnl variable declaration expression resource = ( variable declaration expression ) try statement . resources ( ) . get ( 0 ) ; dcnl marker annotation new marker annotation = ast . new marker annotation ( ) ; dcnl new marker annotation . set type name ( ast . new name ( " non null" ) ) ; dcnl dcnl list rewrite list rewrite = rewrite . get list rewrite ( resource , variable declaration expression . modifiers2 property ) ; dcnl list rewrite . insert first ( new marker annotation , null ) ; dcnl dcnl string preview = evaluate rewrite ( cu , rewrite ) ; dcnl dcnl buf = new string buffer ( ) ; dcnl buf . append ( "package test0017 ; \ n" ) ; dcnl buf . append ( " \ n" ) ; dcnl buf . append ( " @ interface non null { } \ n" ) ; dcnl buf . append ( " \ n" ) ; dcnl buf . append ( "public class x { \ n" ) ; dcnl buf . append ( " void foo ( ) { \ n" ) ; dcnl buf . append ( " try ( @ non null \ n" ) ; dcnl buf . append ( " file reader reader1 = new file reader ( \ "file1 \ " ) ; ) { \ n" ) ; dcnl buf . append ( " int ch ; \ n" ) ; dcnl buf . append ( " while ( ( ch = reader1 . read ( ) ) ! = - 1 ) { \ n" ) ; dcnl buf . append ( " system . out . println ( ch ) ; \ n" ) ; dcnl buf . append ( " } \ n" ) ; dcnl buf . append ( " } \ n" ) ; dcnl buf . append ( " } \ n" ) ; dcnl buf . append ( " } " ) ; dcnl assert equal string ( preview , buf . to string ( ) ) ; dcnl } finally { dcnl delete project ( "p 17" ) ; dcnl } dcnl } dcnl dcnl / * * add an annotation to a resource , no linebreak * / dcnl public void test try statement with resources7 since 4 ( ) throws exception { dcnl dcnl i java project java project = create project ( "p 17" , java core . version 1 7 ) ; dcnl java project . set option ( default code formatter constants . formatter insert new line after annotation on local variable , java core . do not insert ) ; dcnl i package fragment root current source folder = get package fragment root ( "p 17" , "src" ) ; dcnl
public void test variable declaration statement1 only 2 ( ) throws exception {
property = = variable declaration expression . modifiers2 property | | dcnl property = = variable declaration statement . modifiers2 property | | dcnl property = = type parameter . modifiers property | | is annotations property ) { dcnl ast node parent = node . get parent ( ) ; dcnl if ( parent instanceof method declaration ) dcnl formatter prefix = this . formatter . param annotation separation ; dcnl else if ( parent instanceof block | | parent instanceof try statement | | parent instanceof for statement ) dcnl formatter prefix = this . formatter . local annotation separation ; dcnl else dcnl formatter prefix = this . formatter . type annotation separation ; dcnl } else {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
buf . append ( " \ n" ) ;
import org . eclipse . jdt . core . dom . creation reference ;
import org . eclipse . jdt . core . dom . expression method reference ;
import org . eclipse . jdt . core . dom . method reference ;
import org . eclipse . jdt . core . dom . type method reference ;
dcnl @ override dcnl public void end visit ( method reference node ) { dcnl i method binding method binding = node . resolve method binding ( ) ; dcnl if ( method binding ! = null ) { dcnl i type binding type binding = node . resolve type binding ( ) ; dcnl if ( type binding ! = null ) { dcnl i method binding sam binding = type binding . get functional interface method ( ) ; dcnl constraint variable2 descendant ; dcnl if ( node instanceof creation reference ) { dcnl creation reference creation reference = ( creation reference ) node ; dcnl i type binding creation type binding = creation reference . get type ( ) . resolve binding ( ) ; dcnl descendant = creation type binding = = null ? null : f model . create declaring type variable ( creation type binding ) ; dcnl } else { dcnl descendant = f model . create return type variable ( method binding ) ; dcnl } dcnl constraint variable2 ancestor = f model . create return type variable ( sam binding ) ; dcnl if ( descendant ! = null & & ancestor ! = null ) { dcnl f model . create subtype constraint ( descendant , ancestor ) ; dcnl } dcnl i type binding [ ] parameter types = method binding . get parameter types ( ) ; dcnl i type binding [ ] sam parameter types = sam binding . get parameter types ( ) ; dcnl if ( parameter types . length = = sam parameter types . length ) { dcnl / / expression : : method or type : : new or super : : method or type : : method1 for static method1 dcnl if ( node instanceof expression method reference ) { dcnl expression expression = ( ( expression method reference ) node ) . get expression ( ) ; dcnl descendant = ( constraint variable2 ) expression . get property ( property constraint variable ) ; dcnl if ( descendant ! = null ) { dcnl / / expression : : method dcnl end visit ( method binding , descendant ) ; dcnl } else { dcnl / / type : : method1 for static method1 dcnl } dcnl } dcnl for ( int i = 0 ; i < parameter types . length ; i + + ) { dcnl descendant = f model . create method parameter variable ( sam binding , i ) ; dcnl ancestor = f model . create method parameter variable ( method binding , i ) ; dcnl if ( descendant ! = null & & ancestor ! = null ) { dcnl f model . create subtype constraint ( descendant , ancestor ) ; dcnl } dcnl } dcnl } else if ( parameter types . length + 1 = = sam parameter types . length ) { dcnl / / type : : method1 for non - static method1 : first param is receiver dcnl i type binding receiver type = null ; dcnl if ( node instanceof expression method reference ) { dcnl / / always , as type method reference is currently not returned by the parser dcnl receiver type = ( ( expression method reference ) node ) . get expression ( ) . resolve type binding ( ) ; dcnl } else if ( node instanceof type method reference ) { dcnl / / untested , might be used in the future dcnl receiver type = ( ( type method reference ) node ) . get type ( ) . resolve binding ( ) ; dcnl } dcnl if ( receiver type ! = null ) { dcnl descendant = f model . create method parameter variable ( sam binding , 0 ) ; dcnl ancestor = f model . create declaring type variable ( receiver type ) ; dcnl if ( ancestor ! = null & & descendant ! = null ) { dcnl f model . create subtype constraint ( descendant , ancestor ) ; dcnl } dcnl } dcnl for ( int i = 0 ; i < parameter types . length ; i + + ) { dcnl descendant = f model . create method parameter variable ( sam binding , i + 1 ) ; dcnl ancestor = f model . create method parameter variable ( method binding , i ) ; dcnl if ( descendant ! = null & & ancestor ! = null ) { dcnl f model . create subtype constraint ( descendant , ancestor ) ; dcnl } dcnl } dcnl } dcnl } dcnl } dcnl super . end visit ( node ) ; dcnl } dcnl
import org . eclipse . jdt . core . dom . expression ;
import org . eclipse . jdt . core . dom . i type binding ;
import org . eclipse . jdt . internal . corext . dom . bindings ;
import org . eclipse . jdt . internal . ui . text . correction . proposals . make local variable non null proposal ;
public static void add return and argument type proposal ( i invocation context context , i problem location problem , change kind change kind ,
* copyright ( c ) 2000 , 2016 ibm corporation and others .
if ( ( s . index of ( ' , ' ) < 0 ) & & ( s . index of ( ' \ \ ' ) < 0 ) & & s . index of ( ' \ n' ) < 0 )
* copyright ( c ) 2006 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2004 , 2016 ibm corporation and others .
public class logical structures list viewer label provider extends label provider implements i table label provider {
f logical structures = new array list < > ( ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
if ( !use15specifics ) remove type arguments ( ) ;
public boolean is parameterized ( ) { dcnl return this . bracket = = this . end ; dcnl }
this . start = this . end + 1 ; / / skip ' ; ' or ' < '
import org . eclipse . jdt . core . i access rule ; dcnl import org . eclipse . jdt . core . i class file ; dcnl import org . eclipse . jdt . core . i classpath attribute ; dcnl import org . eclipse . jdt . core . i classpath entry ; dcnl import org . eclipse . jdt . core . i compilation unit ; dcnl import org . eclipse . jdt . core . i jar entry resource ; dcnl import org . eclipse . jdt . core . i java element ; dcnl import org . eclipse . jdt . core . i java model marker ; dcnl import org . eclipse . jdt . core . i java model status constants ; dcnl import org . eclipse . jdt . core . i java project ; dcnl import org . eclipse . jdt . core . i method ; dcnl import org . eclipse . jdt . core . i package fragment ; dcnl import org . eclipse . jdt . core . i package fragment root ; dcnl import org . eclipse . jdt . core . i type ; dcnl import org . eclipse . jdt . core . java core ; dcnl import org . eclipse . jdt . core . java model exception ; dcnl import org . eclipse . jdt . core . working copy owner ;
" void add method ( method info < string > . inner method info < string > mi ) { } " + dcnl " } "
* copyright ( c ) 2000 , 2016 ibm corporation and others .
char [ ] type name = this . compound name [ this . compound name . length - 1 ] ; dcnl target type = this . f package . get type0 ( type name ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . ui . text . java . relevance computer ;
* harry terkelsen - bug 460491 - npe in parameterized type binding . collect substitutes
"3 . info in x . java ( at line 10 ) \ n" +
"1 . info in x . java ( at line 6 ) \ n" +
"2 . info in c . java ( at line 14 ) \ n" +
"1 . info in x . java ( at line 8 ) \ n" +
"1 . info in foo . java ( at line 17 ) \ n" +
"2 . info in foo . java ( at line 20 ) \ n" +
"2 . info in proj b \ \ class that imports . java ( at line 7 ) \ n" +
"1 . info in test . java ( at line 9 ) \ n" +
problems . append ( problem count + ( problem . is error ( ) ? " . error" : problem . is warning ( ) ? " . warning" : " . info" ) ) ;
import org . eclipse . jdt . core . search . search participant ;
import org . eclipse . jdt . internal . core . search . matching . match locator ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . core . binary method ;
private type binding unit scope type binding = null ; / / cached
this . unit scope type binding = type binding ; / / cache .
this . unit scope type binding = null ;
} else if ( method pattern . focus instanceof binary method & & dcnl method pattern . declaring type instanceof binary type & & dcnl this . unit scope type binding instanceof problem reference binding ) { / / get binding from unit scope for non - visible member of binary type dcnl char [ ] type name = pattern locator . qualified pattern ( method pattern . declaring simple name , method pattern . declaring qualification ) ; dcnl if ( type name ! = null ) { dcnl i type type = method pattern . declaring type ; dcnl i type enclosing type = type . get declaring type ( ) ; dcnl while ( enclosing type ! = null ) { dcnl type = enclosing type ; dcnl enclosing type = type . get declaring type ( ) ; dcnl } dcnl type name = type . get fully qualified name ( ) . to char array ( ) ; dcnl type binding type binding = this . unit scope type binding ; dcnl if ( type binding instanceof problem reference binding ) { dcnl problem reference binding problem reference binding = ( problem reference binding ) this . unit scope type binding ; dcnl reference binding closest match = ( problem reference binding . problem id ( ) = = problem reasons . not visible ) ? dcnl problem reference binding . closest reference match ( ) : null ; dcnl return closest match ! = null ? get method binding ( method pattern , closest match ) : null ; dcnl } dcnl }
result = get method binding ( method pattern , declaring type binding ) ; dcnl } dcnl } dcnl this . bindings . put ( method pattern , result ! = null ? result : new problem method binding ( method pattern . selector , null , problem reasons . not found ) ) ; dcnl return result ; dcnl } dcnl dcnl private method binding get method binding ( method pattern method pattern , type binding declaring type binding ) { dcnl method binding result ; dcnl char [ ] [ ] parameter types = method pattern . parameter simple names ; dcnl if ( parameter types = = null ) return null ; dcnl int param typeslength = parameter types . length ; dcnl reference binding reference binding = ( reference binding ) declaring type binding ; dcnl method binding [ ] methods = reference binding . get methods ( method pattern . selector ) ; dcnl int methods length = methods . length ; dcnl type variable binding [ ] ref type variables = reference binding . type variables ( ) ; dcnl int type var length = ref type variables = = null ? 0 : ref type variables . length ; dcnl list < method binding > possible methods = new array list < method binding > ( methods length ) ; dcnl for ( int i = 0 ; i < methods length ; i + + ) { dcnl type binding [ ] method parameters = methods [ i ] . parameters ; dcnl int param length = method parameters = = null ? 0 : method parameters . length ; dcnl type variable binding [ ] method type variables = methods [ i ] . type variables ; dcnl int meth type var length = method type variables = = null ? 0 : method type variables . length ; dcnl boolean found = false ; dcnl if ( method parameters ! = null & & param length = = param typeslength ) { dcnl for ( int p = 0 ; p < param length ; p + + ) { dcnl if ( char operation . equals ( method parameters [ p ] . source name ( ) , parameter types [ p ] ) ) { dcnl / / param erasure match dcnl found = true ; dcnl } else { dcnl / / type variable dcnl found = false ; dcnl if ( ref type variables ! = null ) { dcnl for ( int v = 0 ; v < type var length ; v + + ) { dcnl if ( ! char operation . equals ( ref type variables [ v ] . source name , parameter types [ p ] ) ) { dcnl found = false ; dcnl break ;
found = true ; dcnl } dcnl } dcnl if ( !found & & method type variables ! = null ) { dcnl for ( int v = 0 ; v < meth type var length ; v + + ) { dcnl if ( ! char operation . equals ( method type variables [ v ] . source name , parameter types [ p ] ) ) { dcnl found = false ; dcnl break ;
found = true ;
if ( !found ) break ;
} dcnl if ( found ) { dcnl possible methods . add ( methods [ i ] ) ;
import org . eclipse . jdt . internal . core . binary method ;
boolean is binary = this . pattern! = null & & this . pattern . focus instanceof binary method ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* having to traverse ast . return the "ordinal" returned by the enclosing type .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
public int functional expressions count = 0 ;
* copyright ( c ) 2006 , 2016 ibm corporation and others .
notify test tree entry ( get test id ( id ) + ' , ' + escape comma ( replace line delimiters ( id . get name ( ) ) ) + ' , ' + b + ' , ' + i ) ;
if ( ( s . index of ( ' , ' ) < 0 ) & & ( s . index of ( ' \ \ ' ) < 0 ) )
* copyright ( c ) 2006 , 2016 ibm corporation and others .
" return arrays . as list ( new string [ ] [ ] { { \ "2 \ " } , { \ "4 \ \ n \ " } , { \ "6 \ \ r \ " } , { \ "8 \ \ r \ \ n \ " } } ) ; \ n" +
test run listeners . suite as string ( " [ 2 : test even ( 6 ) ] " , progress state . completed , result . ok , null , 2 ) , dcnl test run listeners . test case as string ( "test even [ 2 : test even ( 6 ) ] " , "pack . a test case" , progress state . completed , result . ok , null , 3 ) , dcnl test run listeners . suite as string ( " [ 3 : test even ( 8 ) ] " , progress state . completed , result . ok , null , 2 ) , dcnl test run listeners . test case as string ( "test even [ 3 : test even ( 8 ) ] " , "pack . a test case" , progress state . completed , result . ok , null , 3 ) ,
notify test tree entry ( get test id ( id ) + ' , ' + escape test name ( id . get name ( ) ) + ' , ' + b + ' , ' + i ) ;
public static string escape test name ( string s ) { dcnl if ( ( s . index of ( ' , ' ) < 0 ) & & ( s . index of ( ' \ \ ' ) < 0 ) & & ( s . index of ( ' \ r' ) < 0 ) & & ( s . index of ( ' \ n' ) < 0 ) )
if ( c = = ' , ' ) {
} else if ( c = = ' \ \ ' ) {
} else if ( c = = ' \ r' ) { dcnl if ( i + 1 < s . length ( ) & & s . char at ( i + 1 ) = = ' \ n' ) { dcnl i + + ; dcnl } dcnl sb . append ( ' ' ) ; dcnl } else if ( c = = ' \ n' ) { dcnl sb . append ( ' ' ) ; dcnl } else {
public void test parametrized with evil chars ( ) throws exception {
" return arrays . as list ( new string [ ] [ ] { { \ "2 \ " } , { \ "4 \ \ n \ " } , { \ "6 \ \ r \ " } , { \ "8 \ \ r \ \ n \ " } , { \ "0 \ \ \ \ , \ " } } ) ; \ n" +
test run listeners . session as string ( "a test case" , progress state . completed , result . error , 0 ) , dcnl test run listeners . suite as string ( "pack . a test case" , progress state . completed , result . error , null , 1 ) ,
test run listeners . suite as string ( " [ 4 : test even ( 0 \ \ , ) ] " , progress state . completed , result . error , null , 2 ) , dcnl test run listeners . test case as string ( "test even [ 4 : test even ( 0 \ \ , ) ] " , "pack . a test case" , progress state . completed , result . error , new failure trace ( "java . lang . number format exception" , null , null ) , 3 ) ,
* copyright ( c ) 2000 , 2015 ibm corporation and others .
/ / caveat : returns false if a method is implemented that needs a bridge method
if ( inherited method = = null dcnl | | type binding . not equals ( inherited method . return type , existing method . return type ) ) / / need to keep around to produce bridge methods ? . . .
public static string modify dialog tabpage parentheses title ;
modify dialog tabpage parentheses title = parentheses
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( progress monitor , 3 ) ;
index [ ] indexes = get indexes ( sub monitor . split ( 1 ) ) ;
sub monitor loop monitor = sub monitor . split ( 2 ) . set work remaining ( max ) ;
is complete & = search ( indexes [ i ] , loop monitor . split ( 1 ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jface . viewers . i structured selection ; dcnl
import org . eclipse . jdt . internal . compiler . batch . classpath directory ;
import org . eclipse . jdt . internal . compiler . batch . file system ;
import org . eclipse . jdt . internal . compiler . batch . file system . classpath ; dcnl import org . eclipse . jdt . internal . compiler . env . name environment answer ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type constants ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* classes put in this list will be run only if "add" vm parameter ( - dadd = true ) is added
copyright ( c ) 2012 , 2016 eclipse foundation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* find a type named < type name > in the package < package name > . dcnl * answer the binary form of the type if it is known to be consistent . dcnl * otherwise , answer the compilation unit which defines the type dcnl * or null if the type does not exist . dcnl * the default package is indicated by char [ 0 ] [ ] . dcnl * dcnl * it is known that the package containing the type exists . dcnl * dcnl * note : this method can be used to find a member type using its dcnl * internal name a$b , but the source file for a is answered if the binary dcnl * file is inconsistent . dcnl * dcnl * the flag < search with secondary types > can be used to switch on / off the search for secondary types . dcnl * this is useful because the search for secondary types may by very expensive regarding the performance dcnl * and in many cases it isn't necessary to search for secondary types . dcnl * dcnl * @ param type name type to find dcnl * @ param package name package of the searched type dcnl * @ param search with secondary types flag to switch on / off the search for secondary types dcnl * @ return { @ link name environment answer } dcnl * / dcnl name environment answer find type ( char [ ] type name , char [ ] [ ] package name , boolean search with secondary types ) ; / * *
* copyright ( c ) 2000 , 2016 ibm corporation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
# copyright ( c ) 2000 , 2016 ibm corporation and others .
if ( ! ( s . ends with ( suffix string java ) | | s . ends with ( suffix string java ) ) ) continue ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2004 , 2016 ibm corporation and others .
" the return types are incompatible for the inherited methods edit part . get viewer ( ) , abstract link view < m > . get viewer ( ) \ n" +
/ * * dcnl * methods that are to be considered inherited even though they are overridden somewhere in the dcnl * hierarchy - notably for bridge method generation dcnl * / dcnl hashtable of object inherited overridden methods ;
this . inherited overridden methods = null ;
method binding [ ] overridden = ( method binding [ ] ) this . inherited overridden methods . get ( current method . selector ) ; dcnl if ( overridden ! = null ) { dcnl for ( int i = overridden . length ; - - i > = 0 ; ) { dcnl method binding inherited method = overridden [ i ] ; dcnl if ( is parameter subsignature ( current method , inherited method ) & & dcnl !inherited method . is static ( ) & & !inherited method . is final ( ) ) dcnl check for bridge method ( current method , inherited method , all inherited methods ) ; dcnl } dcnl } dcnl } dcnl void add bridge method candidate ( method binding overridden method ) { dcnl method binding [ ] existing = ( method binding [ ] ) this . inherited overridden methods . get ( overridden method . selector ) ; dcnl if ( existing = = null ) { dcnl existing = new method binding [ ] { overridden method } ; dcnl } else { dcnl int length = existing . length ; dcnl system . arraycopy ( existing , 0 , existing = new method binding [ length + 1 ] , 0 , length ) ; dcnl existing [ length ] = overridden method ; dcnl } dcnl this . inherited overridden methods . put ( overridden method . selector , existing ) ;
this . inherited overridden methods = new hashtable of object ( 11 ) ;
if ( type binding . not equals ( inherited method . return type , existing method . return type ) & & dcnl are return types compatible ( existing method , inherited method ) ) { dcnl add bridge method candidate ( inherited method ) ; dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ / caveat : returns false if a method is implemented , but with a return type that is incompatible with that of the interface method
if ( inherited method = = null | | !does method override ( existing method , inherited method ) )
import org . eclipse . jdt . internal . compiler . env . i name environment extension ;
public interface i name environment with progress extends i name environment extension { dcnl
type binding [ ] argument types ; dcnl if ( t . is parameterized type ( ) ) { dcnl method binding captured function type = ( ( parameterized type binding ) t ) . get single abstract method ( inference context . scope , true , reference . source start , reference . source end ) ; dcnl argument types = captured function type . parameters ; dcnl } else { dcnl argument types = function type . parameters ; dcnl } dcnl suspended inference record prev invocation = inference context . enter poly invocation ( reference , reference . create pseudo expressions ( argument types ) ) ;
if ( type binding . not equals ( inherited method . return type . erasure ( ) , existing method . return type . erasure ( ) ) & &
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import java . util . hash set ;
import org . eclipse . swt . widgets . tree item ;
hash set < object > visited = new hash set < > ( ) ; dcnl tree item [ ] root nodes = get tree ( ) . get items ( ) ; dcnl for ( tree item root node : root nodes ) { dcnl expand node ( root node , visited ) ; dcnl }
} else if ( ast node instanceof completion on provides interfaces qualified type reference ) { dcnl completion on provides interfaces qualified type reference ( ast node , ast node parent , qualified binding , scope ) ; dcnl } else if ( ast node instanceof completion on provides interfaces single type reference ) { dcnl completion on provides interfaces single type reference ( ast node , ast node parent , qualified binding , scope ) ; dcnl } else if ( ast node instanceof completion on provides implementations qualified type reference ) { dcnl completion on provides implementations qualified type reference ( ast node , ast node parent , qualified binding , scope ) ; dcnl } else if ( ast node instanceof completion on provides implementations single type reference ) { dcnl completion on provides implementations single type reference ( ast node , ast node parent , qualified binding , scope ) ;
private void completion on provides interfaces qualified type reference ( ast node ast node , ast node ast node parent , binding qualified binding , scope scope ) { dcnl / / todo : filter the results wrt accessibility and add relevance to the results . dcnl completion on qualified type reference ( ast node , ast node parent , qualified binding , scope ) ; dcnl } dcnl dcnl private void completion on provides implementations qualified type reference ( ast node ast node , ast node ast node parent , binding qualified binding , scope scope ) { dcnl / / todo : filter the results wrt accessibility and add relevance to the results . dcnl completion on qualified type reference ( ast node , ast node parent , qualified binding , scope ) ; dcnl } dcnl
dcnl private type reference pending provides interface = null ;
form completion on provides interfaces type ref ( index , length , module ) ;
form completion on provides implementations type ref ( index , length , module ) ;
private void form completion on provides interfaces type ref ( int index , int length , recovered module module ) { dcnl long [ ] positions = new long [ length ] ; dcnl system . arraycopy ( dcnl this . identifier position stack , dcnl this . identifier ptr - length + 1 , dcnl positions , dcnl 0 , dcnl length ) ; dcnl type reference reference = index = = 0 ? new completion on provides interfaces single type reference ( assist identifier ( ) , positions [ 0 ] ) : dcnl new completion on provides interfaces qualified type reference ( identifier sub set ( index ) , assist identifier ( ) , positions ) ; dcnl module . add provides interfaces ( reference , 0 ) ; dcnl this . assist node parent = module . type declaration ; dcnl } dcnl private void form completion on provides implementations type ref ( int index , int length , recovered module module ) { dcnl long [ ] positions = new long [ length ] ; dcnl system . arraycopy ( dcnl this . identifier position stack , dcnl this . identifier ptr - length + 1 , dcnl positions , dcnl 0 , dcnl length ) ; dcnl type reference reference = index = = 0 ? new completion on provides implementations single type reference ( assist identifier ( ) , positions [ 0 ] ) : dcnl new completion on provides implementations qualified type reference ( identifier sub set ( index ) , assist identifier ( ) , positions ) ; dcnl module . add provides implementations ( this . pending provides interface , reference , 0 ) ; dcnl this . assist node parent = module . type declaration ; dcnl } dcnl
}
public recovered type reference [ ] uses ;
public recovered type reference [ ] interfaces ; dcnl public recovered type reference [ ] implementations ; dcnl public int services count ; dcnl private type reference pending interface ;
if ( this . uses = = null ) { dcnl this . uses = new recovered type reference [ 5 ] ;
if ( this . uses count = = this . uses . length ) {
this . uses ,
( this . uses = new recovered type reference [ 2 * this . uses count ] ) ,
this . uses [ this . uses count + + ] = element ;
public recovered element add provides interfaces ( type reference type reference , int bracket balance value ) { dcnl reset pending modifiers ( ) ; dcnl check mem services ( ) ; dcnl recovered type reference element = new recovered type reference ( type reference , this , bracket balance value ) ; dcnl this . interfaces [ this . services count + + ] = element ; dcnl return this ; dcnl } dcnl public recovered element add provides implementations ( type reference that pending interface , type reference type reference , int bracket balance value ) { dcnl reset pending modifiers ( ) ; dcnl check mem services ( ) ; dcnl recovered type reference element = new recovered type reference ( type reference , this , bracket balance value ) ; dcnl this . pending interface = that pending interface ; dcnl this . implementations [ this . services count + + ] = element ; dcnl return this ; dcnl } dcnl private void check mem services ( ) { dcnl if ( this . interfaces = = null ) { dcnl this . interfaces = new recovered type reference [ 5 ] ; dcnl this . implementations = new recovered type reference [ 5 ] ; dcnl this . services count = 0 ; dcnl } else { dcnl if ( this . services count = = this . interfaces . length ) { dcnl system . arraycopy ( dcnl this . interfaces , dcnl 0 , dcnl ( this . interfaces = new recovered type reference [ 2 * this . services count ] ) , dcnl 0 , dcnl this . services count ) ; dcnl system . arraycopy ( dcnl this . implementations , dcnl 0 , dcnl ( this . implementations = new recovered type reference [ 2 * this . services count ] ) , dcnl 0 , dcnl this . services count ) ; dcnl } dcnl } dcnl } dcnl public module declaration updated module declaration ( ) {
update uses ( module declaration ) ; dcnl update services ( module declaration ) ; dcnl return module declaration ; dcnl } dcnl private void update uses ( module declaration module declaration ) {
ref1 [ actual count + + ] = this . uses [ i ] . update type reference ( ) ;
array list tests 9 = ( array list ) test classes . clone ( ) ; dcnl tests 9 . add all ( test classes 1 5 ) ; dcnl tests 9 . add ( parser test1 7 . class ) ; dcnl tests 9 . add ( lambda expression syntax test . class ) ; dcnl tests 9 . add ( reference expression syntax test . class ) ; dcnl tests 9 . add ( type annotation syntax test . class ) ; dcnl tests 9 . add ( completion parser test18 . class ) ; dcnl tests 9 . add ( selection parser test18 . class ) ; dcnl tests 9 . add ( module declaration syntax test . class ) ;
array list since 9 = new array list ( ) ; dcnl since 9 . add ( unicode9 test . class ) ;
array list tests 9 = ( array list ) standard tests . clone ( ) ; dcnl tests 9 . add all ( since 1 4 ) ; dcnl tests 9 . add all ( since 1 5 ) ; dcnl tests 9 . add all ( since 1 6 ) ; dcnl tests 9 . add all ( since 1 7 ) ; dcnl tests 9 . add all ( since 1 8 ) ; dcnl tests 9 . add all ( since 9 ) ;
public class unicode9 test extends abstract regression test { dcnl public unicode9 test ( string name ) {
public static final int f 9 = 0x40 ;
fix java se9 compliance source target levels ( profile ) ;
static final string java se 9 = " java se - 9" ; / / $non - nls - 1$
mappings . put ( java se 9 , new string [ ] { java se 1 8 } ) ;
public static boolean is9 or higher ( string compliance ) {
* checks if the given project or workspace has source compliance 9 or greater .
* @ return < code > true < / code > if the given project or workspace has source compliance 9 or
preferences messages . compliance configuration block version9 ,
version 1 5 , version 1 6 , version 1 7 , version 1 8 , version 9 } ;
preferences messages . compliance configuration block version9 ,
preferences messages . compliance configuration block version9 ,
private static string [ ] fg java9 module info keywords = { "module" , "requires" , "exports" , "public" , "to" , "provides" , "with" , "uses" } ; / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ / / $non - nls - 4$ / / $non - nls - 5$ / / $non - nls - 6$ / / $non - nls - 7$ / / $non - nls - 8$
return create9 module info rules ( default token , version ) ;
private list < i rule > create9 module info rules ( token default token , string version ) {
versioned word matcher j9 module info matcher = new versioned word matcher ( default token , java core . version 9 , version ) ;
for ( int i = 0 ; i < fg java9 module info keywords . length ; i + + ) dcnl j9 module info matcher . add word ( fg java9 module info keywords [ i ] , token ) ;
combined word rule . add word matcher ( j9 module info matcher ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
} else if ( java version . starts with ( java core . version 9 ) dcnl & & ( java version . length ( ) = = java core . version 9 . length ( ) | | java version . char at ( java core . version 9 . length ( ) ) = = ' . ' ) ) { dcnl compliance = java core . version 9 ;
public void test package ( ) {
evaluate with expected type ( "return boolean . value of ( true ) ; " . to char array ( ) , "java . lang . boolean" . to char array ( ) ) ;
evaluate with expected type ( "return character . value of ( 'c' ) ; " . to char array ( ) , "java . lang . character" . to char array ( ) ) ;
evaluate with expected type ( "return double . value of ( 1 . 0 ) ; " . to char array ( ) , "java . lang . double" . to char array ( ) ) ;
evaluate with expected type ( "return float . value of ( 1 . 0f ) ; " . to char array ( ) , "java . lang . float" . to char array ( ) ) ;
evaluate with expected type ( "return integer . value of ( 1 ) ; " . to char array ( ) , "java . lang . integer" . to char array ( ) ) ;
evaluate with expected type ( "return long . value of ( 1 ) ; " . to char array ( ) , "java . lang . long" . to char array ( ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
definition id = "org . eclipse . jdt . ui . edit . text . java . generate . tostring" dcnl label = " % generate to string action . label"
id = "org . eclipse . jdt . ui . actions . generate to string" >
definition id = "org . eclipse . jdt . ui . edit . text . java . generate . hashcode . equals" dcnl label = " % generate hash code equals action . label"
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import junit . framework . test ; dcnl import junit . framework . test suite ; dcnl
* copyright ( c ) 2000 , 2016 ibm corporation and others .
definition id = "org . eclipse . jdt . ui . edit . text . java . push . down" dcnl label = " % refactoring . push down action . label"
id = "org . eclipse . jdt . ui . actions . push down" >
definition id = "org . eclipse . jdt . ui . edit . text . java . pull . up" dcnl label = " % refactoring . pull up action . label"
id = "org . eclipse . jdt . ui . actions . pull up" >
definition id = "org . eclipse . jdt . ui . edit . text . java . extract . superclass" dcnl label = " % refactoring . extract supertype action . label"
id = "org . eclipse . jdt . ui . actions . extract superclass" >
definition id = "org . eclipse . jdt . ui . edit . text . java . extract . interface" dcnl label = " % refactoring . extract interface action . label"
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
build context ( target , null , parsed unit , null , null ) ;
find modules ( ( completion on module reference ) target , true / * targetted * / ) ;
find modules ( ( completion on module reference ) reference , false / * targetted * / ) ;
private void find modules ( completion on module reference module reference , boolean targetted ) {
import org . eclipse . jdt . internal . compiler . lookup . module environment ;
public void find modules ( char [ ] prefix , i search requestor requestor , i java project java project ) {
* copyright ( c ) 2004 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* sets the type or package or module ( 1 . 9 ) signature of the relevant
* copyright ( c ) 2004 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* sets the type or package or module ( 1 . 9 ) signature of the relevant
import java . util . map ; dcnl
import org . eclipse . jdt . internal . compiler . impl . compiler options ;
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
" @ suppress warnings ( { \ "rawtypes \ " } ) \ n" +
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
"1 . warning in example \ \ collection factory . java ( at line 42 ) \ n" +
"2 . warning in example \ \ collection factory . java ( at line 55 ) \ n" +
"3 . warning in example \ \ collection factory . java ( at line 87 ) \ n" +
"4 . warning in example \ \ collection factory . java ( at line 87 ) \ n" +
"5 . warning in example \ \ collection factory . java ( at line 87 ) \ n" +
"6 . warning in example \ \ collection factory . java ( at line 87 ) \ n" +
"7 . warning in example \ \ collection factory . java ( at line 94 ) \ n" +
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
} , null , options ,
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
options ,
"2 . warning in eclipse bug . java ( at line 8 ) \ n" +
"3 . warning in eclipse bug . java ( at line 10 ) \ n" +
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
options ,
options ,
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
options ,
map < string , string > options = get compiler options ( ) ; dcnl options . put ( compiler options . option report deprecation , compiler options . ignore ) ;
options ,
* returns the type signature or package name or module name ( 1 . 9 ) of the relevant
* < li > < code > module ref < / code > - dcnl * name of the module that is referenced < / li >
if ( local contents offset + 6 > = this . contents . length ) { dcnl resize contents ( 6 ) ;
int requires size = 2 + module . requires count * 4 ; dcnl if ( local contents offset + requires size > = this . contents . length ) { dcnl resize contents ( requires size ) ; dcnl }
if ( local contents offset + 4 > = this . contents . length ) { dcnl resize contents ( 4 ) ; dcnl }
int exports size = 2 + module . exports count * 4 ; dcnl if ( local contents offset + exports size > = this . contents . length ) { dcnl resize contents ( exports size ) ; dcnl }
int target size = 2 * exports to count ; dcnl if ( local contents offset + target size > = this . contents . length ) { dcnl resize contents ( target size ) ; dcnl }
attr length + = target size ;
attr length + = exports size ;
int uses size = 2 + 2 * module . uses count ; dcnl if ( local contents offset + uses size > = this . contents . length ) { dcnl resize contents ( uses size ) ; dcnl }
attr length + = uses size ;
int services size = 2 + 4 * module . services count ; dcnl if ( local contents offset + services size > = this . contents . length ) { dcnl resize contents ( services size ) ; dcnl }
this . progress monitor . set work remaining ( project length - i ) ;
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , 3 ) ;
sub monitor . split ( 1 ) ;
sub monitor unit loop monitor = sub monitor . split ( 1 ) . set work remaining ( units index ) ;
unit loop monitor . split ( 1 ) ;
sub monitor complete loop monitor = sub monitor . split ( 1 ) . set work remaining ( units index ) ;
sub monitor sub monitor = sub monitor . convert ( monitor , 10 ) ;
sub monitor . split ( 1 ) ;
this . hierarchy resolver . resolve ( new openable [ ] { openable } , local types , sub monitor . split ( 9 ) ) ;
this . hierarchy resolver . resolve ( openables , local types , sub monitor . split ( 9 ) ) ;
sub monitor sub monitor = sub monitor . convert ( monitor , 100 ) ;
sub monitor . split ( 5 ) ;
sub monitor loop monitor = sub monitor . split ( 95 ) ;
loop monitor . set work remaining ( length - i + 1 ) ;
build for project ( ( java project ) current project , potential subtypes , working copies , local types , loop monitor . split ( 1 ) ) ;
loop monitor . set work remaining ( 2 ) ;
build for project ( ( java project ) current project , potential subtypes , working copies , local types , loop monitor . split ( 1 ) ) ;
loop monitor . set work remaining ( 1 ) ; dcnl
build for project ( ( java project ) current project , potential subtypes , working copies , local types , loop monitor . split ( 1 ) ) ;
sub monitor . done ( monitor ) ;
search all possible sub types ( dcnl get type ( ) , dcnl this . scope , dcnl this . binaries from index matches , dcnl collector , dcnl i java search constants . wait until ready to search , dcnl monitor ) ;
* @ param monitor
final i progress monitor monitor ) {
sub monitor sub monitor = sub monitor . convert ( monitor ) ;
sub monitor . set work remaining ( math . max ( queue . end - queue . start + 1 , 100 ) ) ;
public boolean perform concurrent job ( i job search job , int waiting policy , i progress monitor monitor ) {
sub monitor sub monitor = sub monitor . convert ( monitor ) ;
if ( sub progress . is canceled ( ) | | this . processing thread = = null )
icon = "$nl$ / icons / full / obj16 / jsbook obj . png"
hover icon = "$nl$ / icons / full / etool16 / run sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
hover icon = "$nl$ / icons / full / etool16 / disp sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
hover icon = "$nl$ / icons / full / etool16 / insp sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / insp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "$nl$ / icons / full / obj16 / class obj . png"
icon = "$nl$ / icons / full / elcl16 / exc catch . png"
hover icon = "$nl$ / icons / full / etool16 / run sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
hover icon = "$nl$ / icons / full / etool16 / disp sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / disp sbook . png" dcnl icon = "$nl$ / icons / full / etool16 / disp sbook . png"
hover icon = "$nl$ / icons / full / etool16 / insp sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / insp sbook . png" dcnl icon = "$nl$ / icons / full / etool16 / insp sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / watch exp . png"
hover icon = "$nl$ / icons / full / etool16 / watch exp . png" dcnl icon = "$nl$ / icons / full / etool16 / watch exp . png"
icon = "icons / full / elcl16 / all instances . png"
icon = "icons / full / elcl16 / all references . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "icons / full / obj16 / brkp obj . png"
icon = "icons / full / obj16 / brkp obj . png"
icon = "icons / full / elcl16 / runtoline co . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "$nl$ / icons / full / etool16 / watch exp . png"
icon = "icons / full / elcl16 / all instances . png"
icon = "icons / full / elcl16 / runtoline co . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "$nl$ / icons / full / etool16 / watch exp . png"
icon = "icons / full / elcl16 / all instances . png"
icon = "icons / full / obj16 / brkp obj . png"
icon = "icons / full / obj16 / readwrite obj . png"
icon = "icons / full / obj16 / class obj . png"
icon = "icons / full / obj16 / readwrite obj . png"
icon = "icons / full / elcl16 / all instances . png"
icon = "icons / full / elcl16 / all references . png"
icon = "$nl$ / icons / full / elcl16 / sethitcount co . png"
icon = "$nl$ / icons / full / elcl16 / suspend co . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "$nl$ / icons / full / etool16 / watch exp . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "icons / full / elcl16 / all instances . png"
icon = "icons / full / elcl16 / all instances . png"
icon = "icons / full / elcl16 / all references . png"
icon = "$nl$ / icons / full / obj16 / package obj . png"
icon = "$nl$ / icons / full / elcl16 / static co . png"
icon = "$nl$ / icons / full / elcl16 / constant co . png"
icon = "icons / full / elcl16 / all references . png"
icon = "$nl$ / icons / full / obj16 / package obj . png"
icon = "$nl$ / icons / full / elcl16 / static co . png"
icon = "$nl$ / icons / full / elcl16 / constant co . png"
hover icon = "$nl$ / icons / full / elcl16 / exc catch . png"
disabled icon = "$nl$ / icons / full / dlcl16 / exc catch . png" dcnl icon = "$nl$ / icons / full / elcl16 / exc catch . png"
icon = "$nl$ / icons / full / obj16 / package obj . png"
icon = "$nl$ / icons / full / obj16 / threadgroup obj . png"
icon = "$nl$ / icons / full / obj16 / package obj . png"
icon = "$nl$ / icons / full / obj16 / thread obj . png"
icon = "$nl$ / icons / full / obj16 / thread and monitor obj . png"
disabled icon = "$nl$ / icons / full / dtool16 / watch exp . png"
hover icon = "$nl$ / icons / full / etool16 / watch exp . png" dcnl icon = "$nl$ / icons / full / etool16 / watch exp . png"
hover icon = "$nl$ / icons / full / etool16 / run sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / run sbook . png"
icon = "$nl$ / icons / full / etool16 / run sbook . png"
hover icon = "$nl$ / icons / full / etool16 / disp sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / disp sbook . png"
icon = "$nl$ / icons / full / etool16 / disp sbook . png"
hover icon = "$nl$ / icons / full / etool16 / insp sbook . png"
disabled icon = "$nl$ / icons / full / dtool16 / insp sbook . png"
icon = "$nl$ / icons / full / etool16 / insp sbook . png"
icon = "$nl$ / icons / full / etool16 / java app . png"
icon = "$nl$ / icons / full / etool16 / java attach . png"
icon = "$nl$ / icons / full / etool16 / java applet . png"
icon = "$nl$ / icons / full / etool16 / java app . png"
icon = "$nl$ / icons / full / etool16 / java applet . png"
icon = "$nl$ / icons / full / obj16 / envvar obj . png"
icon = "$nl$ / icons / full / obj16 / library obj . png"
icon = "$nl$ / icons / full / obj16 / prj obj . png"
icon = "$nl$ / icons / full / obj16 / jar obj . png"
icon = "$nl$ / icons / full / obj16 / library obj . png"
icon = "$nl$ / icons / full / elcl16 / var cntnt prvdr . png"
* copyright ( c ) 2000 , 2016 ibm corporation and others .
declare registry image ( img objs exception , t obj + "jexception obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs exception disabled , t obj + "jexceptiond obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr breakpoint installed , t ovr + "installed ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr breakpoint installed disabled , t ovr + "installed ovr disabled . png" ) ; / / $non - nls - 1$
declare registry image ( img objs local variable , t obj + "localvariable obj . png" ) ; / / $non - nls - 1$
declare registry image ( img ovr method breakpoint entry , t ovr + "entry ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr method breakpoint entry disabled , t ovr + "entry ovr disabled . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr method breakpoint exit , t ovr + "exit ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr method breakpoint exit disabled , t ovr + "exit ovr disabled . png" ) ; / / $non - nls - 1$
declare registry image ( img ovr conditional breakpoint , t ovr + "conditional ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr conditional breakpoint disabled , t ovr + "conditional ovr disabled . png" ) ; / / $non - nls - 1$
declare registry image ( img ovr scoped breakpoint , t ovr + "scoped ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr scoped breakpoint disabled , t ovr + "scoped ovr disabled . png" ) ; / / $non - nls - 1$
declare registry image ( img ovr uncaught breakpoint , t ovr + "uncaught ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr uncaught breakpoint disabled , t ovr + "uncaught ovr disabled . png" ) ; / / $non - nls - 1$
declare registry image ( img ovr caught breakpoint , t ovr + "caught ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr caught breakpoint disabled , t ovr + "caught ovr disabled . png" ) ; / / $non - nls - 1$
declare registry image ( img objs error , t obj + "jrtexception obj . png" ) ; / / $non - nls - 1$
declare registry image ( img objs snippet evaluating , t obj + "jsbook run obj . png" ) ; / / $non - nls - 1$
declare registry image ( img view arguments tab , t eview + "variable tab . png" ) ; / / $non - nls - 1$
declare registry image ( img ovr out of synch , t ovr + "error co . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr may be out of synch , t ovr + "warning co . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr synchronized , t ovr + "sync ovr . png" ) ; / / $non - nls - 1$
declare registry image ( img objs monitor , t obj + "monitor obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr owned , t ovr + "owned ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr owns monitor , t ovr + "ownsmonitor ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr in contention , t ovr + "contention ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr in contention for monitor , t ovr + "contentionformonitor ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img ovr in deadlock , t ovr + "deadlock ovr . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs contended monitor , t obj + "contended monitor obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs owned monitor , t obj + "owned monitor obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs thread group , t obj + "threadgroup obj . png" ) ; / / $non - nls - 1$
declare registry image ( img tool termsnippet , t elcl + "term sbook . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img tool termsnippet hover , t elcl + "term sbook . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img tool termsnippet disabled , t dlcl + "term sbook . png" ) ; / / $non - nls - 1$
declare registry image ( img obj java inspect expression , t obj + "insp sbook . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs classpath , t obj + "classpath obj . png" ) ; / / $non - nls - 1$
declare registry image ( img objs exception brkpt type , t obj + "jexcept obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs line brkpt type , t obj + "jline obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs classload brkpt type , t obj + "jload obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs method brkpt type , t obj + "jmeth obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs jsp brkpt type , t obj + "jspbrkpt obj . png" ) ; / / $non - nls - 1$ dcnl declare registry image ( img objs watchpoint type , t obj + "jwatch obj . png" ) ; / / $non - nls - 1$
declare registry image ( img elcl auto format , e lcl + "autoform menu . png" ) ; / / $non - nls - 1$
* copyright ( c ) 2000 , 2016 ibm corporation and others .
i java project project = get java project ( stack frame ) ; dcnl if ( project ! = null ) {
protected i java project get java project ( i stack frame stack frame ) {
i java project java project = null ; dcnl if ( stack frame instanceof i java stack frame ) { dcnl java project = java debug utils . resolve java project ( ( i java stack frame ) stack frame ) ;
* copyright ( c ) 2005 , 2016 ibm corporation and others .
object source element = resolve source element ( object , launch ) ; dcnl i java element java element = get java element ( source element ) ; dcnl if ( java element = = null ) { dcnl / / fallback if default stratum does not provide a java element dcnl source element = resolve source element ( object , java stratum , launch ) ; dcnl java element = get java element ( source element ) ; dcnl } dcnl return java element ;
object source element = resolve source element ( frame , launch ) ;
* copyright ( c ) 2011 , 2016 gk software ag and others .
import org . eclipse . jdt . core . i java element ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
string level = this . compliance level > = class file constants . jdk9 ? "error" : "warning" ;
protected boolean parsing java9 plus ;
this . parsing java9 plus = this . options . source level > = class file constants . jdk9 ;
private boolean under score is error ;
return this . under score is error ? problem severities . error : problem severities . warning ;
public void illegal use of underscore as an identifier ( int source start , int source end , boolean report error ) { dcnl this . under score is error = report error ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
private show stack trace in console view action f show trace in console action ;
f show trace in console action = new show stack trace in console view action ( this ) ; dcnl f show trace in console action . set enabled ( false ) ; dcnl failure tool barmanager . add ( f show trace in console action ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
# copyright ( c ) 2000 , 2016 ibm corporation and others .
bundle - version : 3 . 8 . 0 . qualifier
" constant #20 utf8 : \ "args \ " \ n" + dcnl " constant #21 utf8 : \ " [ ljava / lang / string ; \ " \ n" + dcnl " constant #22 utf8 : \ "i \ " \ n" + dcnl " constant #23 utf8 : \ "li ; \ " \ n" + dcnl " constant #24 utf8 : \ "lambda$0 \ " \ n" + dcnl " constant #25 utf8 : \ "$deserialize lambda$ \ " \ n" + dcnl " constant #26 utf8 : \ " ( ljava / lang / invoke / serialized lambda ; ) ljava / lang / object ; \ " \ n" + dcnl " constant #27 method ref : #28 . #30 java / lang / invoke / serialized lambda . get impl method name ( ) ljava / lang / string ; \ n" + dcnl " constant #28 class : #29 java / lang / invoke / serialized lambda \ n" + dcnl " constant #29 utf8 : \ "java / lang / invoke / serialized lambda \ " \ n" + dcnl " constant #30 name and type : #31 . #32 get impl method name ( ) ljava / lang / string ; \ n" + dcnl " constant #31 utf8 : \ "get impl method name \ " \ n" + dcnl " constant #32 utf8 : \ " ( ) ljava / lang / string ; \ " \ n" + dcnl " constant #33 method ref : #34 . #36 java / lang / string . hash code ( ) i \ n" + dcnl " constant #34 class : #35 java / lang / string \ n" + dcnl " constant #35 utf8 : \ "java / lang / string \ " \ n" + dcnl " constant #36 name and type : #37 . #38 hash code ( ) i \ n" + dcnl " constant #37 utf8 : \ "hash code \ " \ n" + dcnl " constant #38 utf8 : \ " ( ) i \ " \ n" + dcnl " constant #39 string : #24 \ "lambda$0 \ " \ n" + dcnl " constant #40 method ref : #34 . #41 java / lang / string . equals ( ljava / lang / object ; ) z \ n" + dcnl " constant #41 name and type : #42 . #43 equals ( ljava / lang / object ; ) z \ n" + dcnl " constant #42 utf8 : \ "equals \ " \ n" + dcnl " constant #43 utf8 : \ " ( ljava / lang / object ; ) z \ " \ n" + dcnl " constant #44 method ref : #28 . #45 java / lang / invoke / serialized lambda . get impl method kind ( ) i \ n" + dcnl " constant #45 name and type : #46 . #38 get impl method kind ( ) i \ n" + dcnl " constant #46 utf8 : \ "get impl method kind \ " \ n" + dcnl " constant #47 method ref : #28 . #48 java / lang / invoke / serialized lambda . get functional interface class ( ) ljava / lang / string ; \ n" + dcnl " constant #48 name and type : #49 . #32 get functional interface class ( ) ljava / lang / string ; \ n" + dcnl " constant #49 utf8 : \ "get functional interface class \ " \ n" + dcnl " constant #50 string : #51 \ "i \ " \ n" + dcnl " constant #51 utf8 : \ "i \ " \ n" + dcnl " constant #52 method ref : #3 . #41 java / lang / object . equals ( ljava / lang / object ; ) z \ n" + dcnl " constant #53 method ref : #28 . #54 java / lang / invoke / serialized lambda . get functional interface method name ( ) ljava / lang / string ; \ n" + dcnl " constant #54 name and type : #55 . #32 get functional interface method name ( ) ljava / lang / string ; \ n" + dcnl " constant #55 utf8 : \ "get functional interface method name \ " \ n" + dcnl " constant #56 string : #17 \ "foo \ " \ n" + dcnl " constant #57 method ref : #28 . #58 java / lang / invoke / serialized lambda . get functional interface method signature ( ) ljava / lang / string ; \ n" + dcnl " constant #58 name and type : #59 . #32 get functional interface method signature ( ) ljava / lang / string ; \ n" + dcnl " constant #59 utf8 : \ "get functional interface method signature \ " \ n" + dcnl " constant #60 string : #6 \ " ( ) v \ " \ n" + dcnl " constant #61 method ref : #28 . #62 java / lang / invoke / serialized lambda . get impl class ( ) ljava / lang / string ; \ n" + dcnl " constant #62 name and type : #63 . #32 get impl class ( ) ljava / lang / string ; \ n" + dcnl " constant #63 utf8 : \ "get impl class \ " \ n" + dcnl " constant #64 string : #2 \ "x \ " \ n" + dcnl " constant #65 method ref : #28 . #66 java / lang / invoke / serialized lambda . get impl method signature ( ) ljava / lang / string ; \ n" + dcnl " constant #66 name and type : #67 . #32 get impl method signature ( ) ljava / lang / string ; \ n" + dcnl " constant #67 utf8 : \ "get impl method signature \ " \ n" + dcnl " constant #68 invoke dynamic : #0 #16 foo ( ) li ; \ n" + dcnl " constant #69 class : #70 java / lang / illegal argument exception \ n" + dcnl " constant #70 utf8 : \ "java / lang / illegal argument exception \ " \ n" + dcnl " constant #71 string : #72 \ " invalid lambda deserialization \ " \ n" + dcnl " constant #72 utf8 : \ " invalid lambda deserialization \ " \ n" + dcnl " constant #73 method ref : #69 . #74 java / lang / illegal argument exception . < init > ( ljava / lang / string ; ) v \ n" + dcnl " constant #74 name and type : #5 . #75 < init > ( ljava / lang / string ; ) v \ n" + dcnl " constant #75 utf8 : \ " ( ljava / lang / string ; ) v \ " \ n" + dcnl " constant #76 utf8 : \ " stack map table \ " \ n" + dcnl " constant #77 utf8 : \ " source file \ " \ n" + dcnl " constant #78 utf8 : \ "x . java \ " \ n" + dcnl " constant #79 utf8 : \ " bootstrap methods \ " \ n" + dcnl " constant #80 method ref : #81 . #83 java / lang / invoke / lambda metafactory . alt metafactory ( ljava / lang / invoke / method handles$ lookup ; ljava / lang / string ; ljava / lang / invoke / method type ; [ ljava / lang / object ; ) ljava / lang / invoke / call site ; \ n" + dcnl " constant #81 class : #82 java / lang / invoke / lambda metafactory \ n" + dcnl " constant #82 utf8 : \ "java / lang / invoke / lambda metafactory \ " \ n" + dcnl " constant #83 name and type : #84 . #85 alt metafactory ( ljava / lang / invoke / method handles$ lookup ; ljava / lang / string ; ljava / lang / invoke / method type ; [ ljava / lang / object ; ) ljava / lang / invoke / call site ; \ n" + dcnl " constant #84 utf8 : \ "alt metafactory \ " \ n" + dcnl " constant #85 utf8 : \ " ( ljava / lang / invoke / method handles$ lookup ; ljava / lang / string ; ljava / lang / invoke / method type ; [ ljava / lang / object ; ) ljava / lang / invoke / call site ; \ " \ n" + dcnl " constant #86 method handle : invokestatic ( 6 ) #80 \ n" + dcnl " constant #87 method type : #6 ( ) v \ n" + dcnl " constant #88 method ref : #1 . #89 x . lambda$0 ( ) v \ n" + dcnl " constant #89 name and type : #24 . #6 lambda$0 ( ) v \ n" + dcnl " constant #90 method handle : invokestatic ( 6 ) #88 \ n" + dcnl " constant #91 method type : #6 ( ) v \ n" + dcnl " constant #92 integer : 1 \ n" + dcnl " constant #93 utf8 : \ " inner classes \ " \ n" + dcnl " constant #94 class : #95 java / lang / invoke / method handles$ lookup \ n" + dcnl " constant #95 utf8 : \ "java / lang / invoke / method handles$ lookup \ " \ n" + dcnl " constant #96 class : #97 java / lang / invoke / method handles \ n" + dcnl " constant #97 utf8 : \ "java / lang / invoke / method handles \ " \ n" + dcnl " constant #98 utf8 : \ " lookup \ " \ n" +
" 0 invokedynamic 0 foo ( ) : i [ 19 ] \ n" + dcnl " 5 astore 1 [ i ] \ n" + dcnl " 6 return \ n" +
" [ pc : 6 , line : 7 ] \ n" +
" [ pc : 0 , pc : 7 ] local : args index : 0 type : java . lang . string [ ] \ n" + dcnl " [ pc : 6 , pc : 7 ] local : i index : 1 type : i \ n" +
" / / method descriptor #26 ( ljava / lang / invoke / serialized lambda ; ) ljava / lang / object ; \ n" +
" 1 invokevirtual java . lang . invoke . serialized lambda . get impl method name ( ) : java . lang . string [ 27 ] \ n" +
" 8 invokevirtual java . lang . string . hash code ( ) : int [ 33 ] \ n" +
" 29 ldc < string \ "lambda$0 \ " > [ 39 ] \ n" + dcnl " 31 invokevirtual java . lang . string . equals ( java . lang . object ) : boolean [ 40 ] \ n" +
" 61 invokevirtual java . lang . invoke . serialized lambda . get impl method kind ( ) : int [ 44 ] \ n" +
" 70 invokevirtual java . lang . invoke . serialized lambda . get functional interface class ( ) : java . lang . string [ 47 ] \ n" + dcnl " 73 ldc < string \ "i \ " > [ 50 ] \ n" + dcnl " 75 invokevirtual java . lang . object . equals ( java . lang . object ) : boolean [ 52 ] \ n" +
" 82 invokevirtual java . lang . invoke . serialized lambda . get functional interface method name ( ) : java . lang . string [ 53 ] \ n" + dcnl " 85 ldc < string \ "foo \ " > [ 56 ] \ n" + dcnl " 87 invokevirtual java . lang . object . equals ( java . lang . object ) : boolean [ 52 ] \ n" +
" 94 invokevirtual java . lang . invoke . serialized lambda . get functional interface method signature ( ) : java . lang . string [ 57 ] \ n" + dcnl " 97 ldc < string \ " ( ) v \ " > [ 60 ] \ n" + dcnl " 99 invokevirtual java . lang . object . equals ( java . lang . object ) : boolean [ 52 ] \ n" +
" 106 invokevirtual java . lang . invoke . serialized lambda . get impl class ( ) : java . lang . string [ 61 ] \ n" + dcnl " 109 ldc < string \ "x \ " > [ 64 ] \ n" + dcnl " 111 invokevirtual java . lang . object . equals ( java . lang . object ) : boolean [ 52 ] \ n" +
" 118 invokevirtual java . lang . invoke . serialized lambda . get impl method signature ( ) : java . lang . string [ 65 ] \ n" + dcnl " 121 ldc < string \ " ( ) v \ " > [ 60 ] \ n" + dcnl " 123 invokevirtual java . lang . object . equals ( java . lang . object ) : boolean [ 52 ] \ n" +
" 129 invokedynamic 0 foo ( ) : i [ 68 ] \ n" +
" 135 new java . lang . illegal argument exception [ 69 ] \ n" +
" 139 ldc < string \ " invalid lambda deserialization \ " > [ 71 ] \ n" + dcnl " 141 invokespecial java . lang . illegal argument exception ( java . lang . string ) [ 73 ] \ n" +
" [ inner class info : #94 java / lang / invoke / method handles$ lookup , outer class info : #96 java / lang / invoke / method handles \ n" + dcnl " inner name : #98 lookup , accessflags : 25 public static final ] \ n" +
" 0 : # 86 invokestatic java / lang / invoke / lambda metafactory . alt metafactory : ( ljava / lang / invoke / method handles$ lookup ; ljava / lang / string ; ljava / lang / invoke / method type ; [ ljava / lang / object ; ) ljava / lang / invoke / call site ; \ n" +
ground type = find ground target type ( block scope , this . expected type , expected sam type , arguments type elided ) ;
private reference binding find ground target type ( block scope block scope , type binding target type , type binding expected sam type , boolean argument types elided ) {
if ( expected sam type instanceof intersection type binding18 ) dcnl expected sam type = ( ( intersection type binding18 ) expected sam type ) . get sam type ( block scope ) ;
if ( expected sam type instanceof reference binding & & expected sam type . is valid binding ( ) ) { dcnl parameterized type binding with wild cards = inference context18 . parameterized with wildcard ( expected sam type ) ;
if ( target type instanceof reference binding ) dcnl return ( reference binding ) target type ;
target type = find ground target type ( this . enclosing scope , target type , target type , arguments type elided ( ) ) ;
throw new illegal argument exception ( ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
private button f skip button ;
f skip button = create button ( parent , i dialog constants . skip id , i dialog constants . skip label , false ) ;
if ( button id = = i dialog constants . skip id ) { dcnl boolean is last page = f current page = = f number of pages - 1 ? true : false ; dcnl turn page ( true , true ) ; dcnl if ( is last page ) { dcnl button pressed ( i dialog constants . ok id ) ; dcnl } dcnl } else if ( button id = = i dialog constants . back id ) { dcnl turn page ( false , false ) ;
turn page ( true , false ) ;
/ / since there will always be a default selection - see filtered list . table update job . default select ( ) dcnl f skip button . set enabled ( true ) ; dcnl
private void turn page ( boolean to next page , boolean skip selection ) {
/ * dcnl * this constant is referenced from an upper - layer bundle dcnl * @ see org . eclipse . jdt . internal . debug . core . model . jdi debug target#prepare breakpoints search scope ( ) dcnl * /
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
expected problem attributes . put ( " illegal modifier combination for private interface method9" , new problem attributes ( categorized problem . cat member ) ) ;
expected problem attributes . put ( " illegal modifier for interface method9" , new problem attributes ( categorized problem . cat member ) ) ;
expected problem attributes . put ( " illegal modifier combination for private interface method9" , skip ) ;
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* todo : add the spec section number for private interface methods from jls 9
long source level = compiler options ( ) . source level ; dcnl if ( source level > = class file constants . jdk1 8 & & !declaring class . is annotation type ( ) ) {
expected modifiers | = source level > = class file constants . jdk9 ? class file constants . acc private : 0 ; dcnl if ( method binding . is abstract ( ) ) { dcnl if ( method binding . is strictfp ( ) )
if ( is default method | | method binding . is static ( ) ) { dcnl problem reporter ( ) . illegal modifier combination for interface method ( ( abstract method declaration ) this . reference context ) ;
} else if ( is default method & & method binding . is static ( ) ) {
} dcnl if ( source level > = class file constants . jdk9 & & ( method binding . modifiers & class file constants . acc private ) ! = 0 ) { dcnl int remaining = real modifiers & ~ expected modifiers ; dcnl if ( remaining = = 0 ) { / / check for the combination of allowed modifiers with private dcnl remaining = real modifiers & ~ ( class file constants . acc private | class file constants . acc static | class file constants . acc strictfp ) ; dcnl if ( is default method | | remaining ! = 0 ) dcnl problem reporter ( ) . illegal modifier combination for private interface method ( ( abstract method declaration ) this . reference context ) ; dcnl }
problem reporter ( ) . illegal modifier for interface method ( ( abstract method declaration ) this . reference context , source level ) ;
long source level = compiler options ( ) . source level ;
public void illegal modifier combination for private interface method ( abstract method declaration method decl ) { dcnl string [ ] arguments = new string [ ] { new string ( method decl . selector ) } ; dcnl this . handle ( dcnl i problem . illegal modifier combination for private interface method9 , dcnl arguments , dcnl arguments , dcnl method decl . source start , dcnl method decl . source end ) ; dcnl }
public void illegal modifier for interface method ( abstract method declaration method decl , long level ) { dcnl dcnl int problem = level < class file constants . jdk1 8 ? i problem . illegal modifier for interface method : dcnl level < class file constants . jdk9 ? i problem . illegal modifier for interface method18 : i problem . illegal modifier for interface method9 ;
# this is an implementation of an early - draft specification developed under the java dcnl # community process ( jcp ) and is made available for testing and evaluation purposes dcnl # only . the code is not compatible with any specification of the jcp .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
< version > 4 . 6 . 1 - snapshot < / version >
copyright ( c ) 2013 , 2016 eclipse foundation and others .
< version > 4 . 6 . 1 - snapshot < / version >
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
< version > 4 . 6 . 1 - snapshot < / version >
copyright ( c ) 2012 , 2016 eclipse foundation and others .
< version > 4 . 7 . 0 - snapshot < / version >
* dcnl * this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
copyright ( c ) 2012 , 2016 eclipse foundation and others .
< version > 4 . 6 . 1 - snapshot < / version >
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
< version > 4 . 7 . 0 - snapshot < / version >
< version > 4 . 7 . 0 - snapshot < / version >
< version > 4 . 7 . 0 - snapshot < / version >
< version > 4 . 7 . 0 - snapshot < / version >
< version > 4 . 6 . 1 - snapshot < / version >
< version > 4 . 6 . 1 - snapshot < / version >
< version > 4 . 6 . 1 - snapshot < / version >
copyright ( c ) 2012 , 2016 eclipse foundation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . debug . ui . console . java stack trace console ; dcnl import org . eclipse . ui . console . console plugin ; dcnl import org . eclipse . ui . console . i console ; dcnl import org . eclipse . ui . console . i console factory ; dcnl import org . eclipse . ui . console . i console listener ; dcnl import org . eclipse . ui . console . i console manager ; dcnl
* creates a new console into which users can paste stack traces and follow the hyperlinks .
public class java stack trace console factory implements i console factory { dcnl private i console manager f console manager = null ; dcnl private java stack trace console f console = null ;
f console manager = console plugin . get default ( ) . get console manager ( ) ; dcnl f console manager . add console listener ( new i console listener ( ) { dcnl @ override dcnl public void consoles added ( i console [ ] consoles ) { dcnl } dcnl dcnl @ override dcnl public void consoles removed ( i console [ ] consoles ) { dcnl for ( int i = 0 ; i < consoles . length ; i + + ) { dcnl if ( consoles [ i ] = = f console ) { dcnl f console . save document ( ) ; dcnl f console = null ; dcnl } dcnl } dcnl } dcnl dcnl } ) ;
* opens the console ( creating a new one if not previously initialized ) .
@ override
open console ( null ) ;
* opens the console ( creating a new one if not previously initialized ) . if the passed string is not < code > null < / code > , the text of the console is dcnl * set to the string .
* copyright ( c ) 2010 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
public void initialize document ( ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* creates a new console into which users can paste stack traces and follow the hyperlinks .
* @ deprecated use org . eclipse . jdt . debug . ui . console . java stack trace console factory
expected problem attributes . put ( " abstract service implementation" , new problem attributes ( categorized problem . cat type ) ) ;
expected problem attributes . put ( " default constructor required for service impl" , new problem attributes ( categorized problem . cat type ) ) ;
expected problem attributes . put ( " service impl default constructor not public" , new problem attributes ( categorized problem . cat type ) ) ;
expected problem attributes . put ( " abstract service implementation" , skip ) ;
expected problem attributes . put ( " default constructor required for service impl" , skip ) ;
import java . io . byte array input stream ;
import org . eclipse . core . runtime . i progress monitor ; dcnl import org . eclipse . core . runtime . null progress monitor ;
int name index = this . constant pool . literal index for type ( module . uses [ i ] . resolved type . constant pool name ( ) ) ;
int name index = this . constant pool . literal index for type ( module . interfaces [ i ] . resolved type . constant pool name ( ) ) ;
import org . eclipse . jdt . internal . compiler . lookup . method binding ;
import org . eclipse . jdt . internal . compiler . lookup . problem reasons ; dcnl import org . eclipse . jdt . internal . compiler . lookup . reference binding ;
reference binding imp = ( reference binding ) this . implementations [ i ] . resolved type ; dcnl if ( inf . is valid binding ( ) & & imp . is valid binding ( ) ) { dcnl validate ( this . interfaces [ i ] , this . implementations [ i ] ) ; dcnl if ( services . get ( inf ) = = imp ) { / / $identity - comparison$ dcnl this . scope . problem reporter ( ) . duplicate type reference ( i problem . duplicate services , dcnl this . interfaces [ i ] , this . implementations [ i ] ) ; dcnl } else { dcnl services . put ( inf , imp ) ; dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
import org . eclipse . jdt . internal . ui . text . java . lazy module completion proposal ;
case completion proposal . module ref : dcnl return create module proposal ( proposal ) ;
case completion proposal . module ref :
* copyright ( c ) 2005 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
import org . eclipse . ui . ide . ide ; dcnl
import org . eclipse . jdt . internal . ui . java plugin ;
styled string create module proposal label ( completion proposal proposal ) { dcnl assert . is true ( proposal . get kind ( ) = = completion proposal . module ref ) ; dcnl return strings . mark java element label ltr ( new styled string ( string . value of ( proposal . get declaration signature ( ) ) ) ) ; dcnl } dcnl
case completion proposal . module ref : dcnl return create module proposal label ( proposal ) ;
expected problem attributes . put ( " cannot infer invocation type" , new problem attributes ( categorized problem . cat type ) ) ;
/ / 8u20 emits just one message inferred type not conforming to upper bound .
"1 . error in x . java ( at line 8 ) \ n" + dcnl " ss . stream ( ) . map ( s - > { \ n" + dcnl " class l1 { } ; \ n" + dcnl " class l2 { \ n" + dcnl " void mm ( l1 l ) { } \ n" + dcnl " } \ n" + dcnl " return new l2 ( ) . mm ( new l1 ( ) ) ; \ n" + dcnl " } ) . for each ( e - > system . out . println ( e ) ) ; \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " cannot infer type argument ( s ) for < r > map ( function < ? super t , ? extends r > ) \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "2 . error in x . java ( at line 13 ) \ n" +
import org . eclipse . jdt . internal . compiler . ast . expression context ;
if ( problem method . return type = = shown method . return type ) { / / $identity - comparison$ dcnl if ( message send . expression context = = expression context . vanilla context ) { dcnl type variable binding [ ] type variables = method . shallow original ( ) . type variables ; dcnl string type arguments = types as string ( type variables , false ) ; dcnl this . handle ( i problem . cannot infer invocation type , dcnl new string [ ] { type arguments , string . value of ( shown method . original ( ) . readable name ( ) ) } , dcnl new string [ ] { type arguments , string . value of ( shown method . original ( ) . short readable name ( ) ) } , dcnl message send . source start , dcnl message send . source end ) ; dcnl }
import org . eclipse . jdt . core . dom . method invocation ;
run conform test (
/ / not spec'd : dcnl bound set connectivity bound set = this . current bounds . copy ( ) ; dcnl for ( constraint formula cf : c ) dcnl connectivity bound set . reduce one constraint ( this , cf ) ;
list < set < inference variable > > components = connectivity bound set . compute connected components ( this . inference variables ) ;
if ( interleaved & & inner context ! = null ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
string us level = this . compliance level < class file constants . jdk9 ? "warning" : "error" ;
"1 . " + us level + " in x . java ( at line 2 ) \ n" +
"2 . " + us level + " in x . java ( at line 4 ) \ n" +
"4 . " + us level + " in x . java ( at line 8 ) \ n" +
* copyright ( c ) 2013 , 2016 gk software ag , ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
string inf mod = this . compliance level > = class file constants . jdk9 ? " private , " : "" ;
" illegal modifier for the interface method foo2 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
" illegal modifier for the interface method foo4 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
" illegal modifier for the interface method foo5 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
string inf mod = this . compliance level > = class file constants . jdk9 ? " private , " : "" ;
" illegal modifier for the interface method foo2 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
" illegal modifier for the interface method foo4 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
" illegal modifier for the interface method foo5 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
string inf mod = this . compliance level > = class file constants . jdk9 ? " private , " : "" ;
" illegal modifier for the interface method foo1 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
" illegal modifier for the interface method foo3 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
" illegal modifier for the interface method foo4 ; only public , " + inf mod + " abstract , default , static and strictfp are permitted \ n" +
string inf mod = this . compliance level > = class file constants . jdk9 ? " private , " : "" ;
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
url = jrt . to path ( ) . to uri ( ) . to url ( ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
reference binding [ ] types per token ;
if ( this . resolved type = = null | | !this . resolved type . is valid binding ( ) ) return ;
if ( index > 0 ) { dcnl reference binding enclosing type = this . types per token [ index - 1 ] ; dcnl if ( enclosing type ! = null ) dcnl check bounds ( enclosing type , scope , index - 1 ) ;
int max = this . tokens . length ; dcnl this . types per token = new reference binding [ max ] ; dcnl for ( int i = package binding = = null ? 0 : package binding . compound name . length ; i < max ; i + + ) {
statement then statement = node . get then statement ( ) ; dcnl statement else statement = node . get else statement ( ) ; dcnl if ( ! ( then statement instanceof block ) ) { dcnl boolean keep then on same line = this . options . keep then statement on same line dcnl | | ( this . options . keep simple if on one line & & else statement = = null ) ; dcnl if ( keep then on same line ) { dcnl this . wrap indexes . add ( this . tm . first index in ( then statement , - 1 ) ) ;
this . wrap group end = this . tm . last index in ( then statement , - 1 ) ;
if ( var . type parameter = = type parameter & & var . rank = = rank & & is same site ( var . site , site ) ) / / $identity - comparison$
dcnl boolean is same site ( invocation site site1 , invocation site site2 ) { dcnl if ( site1 = = site2 ) dcnl return true ; dcnl if ( site1 = = null | | site2 = = null ) dcnl return false ; dcnl if ( site1 . source start ( ) = = site2 . source start ( ) & & site1 . source end ( ) = = site2 . source end ( ) & & site1 . to string ( ) . equals ( site2 . to string ( ) ) ) dcnl return true ; dcnl return false ; dcnl }
if ( !t . is proper type ( true ) & & t . is parameterized type ( ) ) { dcnl / / prevent already resolved inference variables from leaking into the lambda dcnl t = ( reference binding ) scope . substitute ( get result substitution ( this . current bounds , false ) , t ) ; dcnl }
if ( inner context . step completed < inference context18 . applicability inferred ) / / shouldn't happen , but let's play safe dcnl inner context . infer invocation applicability ( shallow method , argument types , shallow method . is constructor ( ) ) ;
* copyright ( c ) 2005 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
import java . io . io exception ; dcnl import java . net . url class loader ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
if ( !use15specifics ) remove type arguments ( ) ;
if ( !use15specifics ) remove type arguments ( ) ;
public boolean is parameterized ( ) { dcnl return this . bracket = = this . end ; dcnl }
this . start = this . end + 1 ; / / skip ' ; ' or ' < '
import org . eclipse . core . resources . i container ; dcnl import org . eclipse . core . resources . i file ; dcnl import org . eclipse . core . resources . i folder ; dcnl import org . eclipse . core . resources . i marker ; dcnl import org . eclipse . core . resources . i project ; dcnl import org . eclipse . core . resources . i resource ; dcnl import org . eclipse . core . resources . i resource change event ; dcnl import org . eclipse . core . resources . i resource change listener ; dcnl import org . eclipse . core . resources . i workspace ; dcnl import org . eclipse . core . resources . i workspace description ; dcnl import org . eclipse . core . resources . i workspace runnable ; dcnl import org . eclipse . core . resources . incremental project builder ; dcnl import org . eclipse . core . resources . resources plugin ;
import org . eclipse . jdt . core . i access rule ; dcnl import org . eclipse . jdt . core . i class file ; dcnl import org . eclipse . jdt . core . i classpath attribute ; dcnl import org . eclipse . jdt . core . i classpath entry ; dcnl import org . eclipse . jdt . core . i compilation unit ; dcnl import org . eclipse . jdt . core . i jar entry resource ; dcnl import org . eclipse . jdt . core . i java element ; dcnl import org . eclipse . jdt . core . i java model marker ; dcnl import org . eclipse . jdt . core . i java model status constants ; dcnl import org . eclipse . jdt . core . i java project ; dcnl import org . eclipse . jdt . core . i method ; dcnl import org . eclipse . jdt . core . i package fragment ; dcnl import org . eclipse . jdt . core . i package fragment root ; dcnl import org . eclipse . jdt . core . i type ; dcnl import org . eclipse . jdt . core . java core ; dcnl import org . eclipse . jdt . core . java model exception ; dcnl import org . eclipse . jdt . core . working copy owner ;
import junit . framework . test ; dcnl import junit . framework . test suite ; dcnl
" void add method ( method info < string > . inner method info < string > mi ) { } " + dcnl " } "
* copyright ( c ) 2000 , 2016 ibm corporation and others .
char [ ] type name = this . compound name [ this . compound name . length - 1 ] ; dcnl target type = this . f package . get type0 ( type name ) ;
* copyright ( c ) 2015 , 2016 ibm corporation and others .
* its container won't be parameterized ( if it needs to be , you would need to use the form of
dcnl reference binding enclosing = element binding . enclosing type ( ) ; dcnl if ( enclosing ! = null ) { dcnl enclosing = this . env . get lookup environment ( ) . create raw type ( enclosing , null ) ; dcnl } dcnl
} else if ( diagnostic . get kind ( ) = = diagnostic . kind . error ) { dcnl count + + ; dcnl buffer . append ( diagnostic . get message ( locale . get default ( ) ) ) ; dcnl buffer . append ( " \ n" ) ; dcnl system . out . println ( buffer . to string ( ) ) ;
} else if ( current arg . equals ( "1 . 9" ) | | current arg . equals ( "9" ) | | current arg . equals ( "9 . 0" ) ) { / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ dcnl this . options . put ( compiler options . option target platform , compiler options . version 9 ) ;
@ override
@ override
@ override
/ / todo auto - generated method stub
@ override
@ override
@ override
@ override
@ override
@ override
/ / todo auto - generated method stub dcnl
@ override
/ / todo auto - generated method stub dcnl
@ override
/ / todo auto - generated method stub dcnl
@ override
import junit . framework . test ; dcnl
import org . eclipse . jdt . core . dom . rewrite . import rewrite ;
private static block create method stub ( final method declaration method , final ast ast , i compilation unit cu , ast rewrite rewrite , string target type name ) {
try { dcnl string delimiter = cu . find recommended line separator ( ) ; dcnl string body statement = "" ; / / $non - nls - 1$ dcnl if ( expression ! = null ) { dcnl final return statement return statement = ast . new return statement ( ) ; dcnl return statement . set expression ( expression ) ; dcnl body statement = ast nodes . as formatted string ( return statement , 0 , delimiter , cu . get java project ( ) . get options ( true ) ) ; dcnl } dcnl string place holder = code generation . get method body content ( cu , target type name , method . get name ( ) . get identifier ( ) , false , body statement , delimiter ) ; dcnl if ( place holder ! = null ) { dcnl return statement todo node = ( return statement ) rewrite . create string placeholder ( place holder , ast node . return statement ) ; dcnl body . statements ( ) . add ( todo node ) ; dcnl } dcnl } catch ( core exception e ) { dcnl / / return empty body
ast rewrite ast rewrite = rewriter . get ast rewrite ( ) ; dcnl new method . set body ( create method stub ( method to create stub for , ast , new cu , ast rewrite , bindings . get fully qualified name ( type to create stub in . resolve binding ( ) ) ) ) ;
copy return type ( ast rewrite , get declaring type ( ) . get compilation unit ( ) , method to create stub for , new method , mapping ) ; dcnl copy parameters ( ast rewrite , get declaring type ( ) . get compilation unit ( ) , method to create stub for , new method , mapping ) ;
new method . set javadoc ( create javadoc for stub ( type to create stub in . get name ( ) . get identifier ( ) , method to create stub for , new method , new cu , ast rewrite ) ) ; dcnl import rewrite import rewrite = rewriter . get import rewrite ( ) ; dcnl import rewrite context context = new context sensitive import rewrite context ( type to create stub in , import rewrite ) ; dcnl import rewrite util . add imports ( rewriter , context , method to create stub for , new hash map < name , string > ( ) , new hash map < name , string > ( ) , true ) ; dcnl i java project java project = new cu . get java project ( ) ; dcnl code generation settings code generation settings = java preferences settings . get code generation settings ( java project ) ; dcnl stub utility2 . add override annotation ( code generation settings , java project , ast rewrite , import rewrite , new method , get declaring type ( ) . is interface ( ) , dcnl rewriter . create categorized group description ( refactoring core messages . pull up refactoring add override annotation , set pull up ) ) ; dcnl ast rewrite . get list rewrite ( type to create stub in , type to create stub in . get body declarations property ( ) ) . insert at ( new method , ast nodes . get insertion index ( new method , type to create stub in . body declarations ( ) ) , rewriter . create categorized group description ( refactoring core messages . pull up refactoring add method stub , set pull up ) ) ;
import rewrite util . add imports ( target rewrite , context , old method , new hash map < name , string > ( ) , new hash map < name , string > ( ) , true ) ;
import rewrite util . add imports ( rewrite , context , old method , new hash map < name , string > ( ) , new hash map < name , string > ( ) , new method . get body ( ) = = null ) ;
* @ since 3 . 13 beta java9
* @ since 3 . 13 beta java9
import org . eclipse . jdt . internal . compiler . lookup . type constants ;
dcnl private module source path manager module path manager ;
import org . eclipse . jdt . internal . compiler . env . i module ;
char [ ] name array = module name . to char array ( ) ; dcnl seek modules ( name array , requestor ) ;
import org . eclipse . jdt . internal . compiler . classfmt . class file reader ;
if ( info ! = null ) dcnl return info . get module ( ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
@ suppress warnings ( "unchecked" )
public < t > t get adapter ( class < t > adapter ) {
i editor input active input = super . get adapter ( i editor input . class ) ;
* copyright ( c ) 2010 , 2016 ibm corporation and others .
import java . util . hashtable ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
boolean [ ] inferred return type out = new boolean [ 1 ] ; dcnl method binding constructor = infer diamond constructor ( scope , this , this . resolved type , this . argument types , inferred return type out ) ; dcnl if ( constructor ! = null ) { dcnl this . inferred return type = inferred return type out [ 0 ] ; dcnl if ( constructor instanceof parameterized generic method binding & & scope . compiler options ( ) . source level > = class file constants . jdk1 8 ) { dcnl / / force an inference context to be established for nested poly allocations ( to be able to transfer b2 ) , but avoid tunneling through overload resolution . we know this is the msmb . dcnl if ( this . expression context = = invocation context & & this . type expected = = null ) dcnl constructor = parameterized generic method binding . compute compatible method18 ( constructor . shallow original ( ) , this . argument types , scope , this ) ; dcnl } dcnl if ( this . type expected ! = null ) dcnl register result ( this . type expected , constructor ) ; dcnl } dcnl return constructor ; dcnl } dcnl dcnl public static method binding infer diamond constructor ( scope scope , invocation site site , type binding type , type binding [ ] argument types , boolean [ ] inferred return type out ) { dcnl reference binding generic type = ( ( parameterized type binding ) type ) . generic type ( ) ; dcnl reference binding enclosing type = type . enclosing type ( ) ;
method binding factory = scope . get static factory ( allocation type , enclosing type , argument types , site ) ;
inferred return type out [ 0 ] = generic factory . inferred return type ;
if ( needs inference ( reference , original ) ) {
inference context18 inner context = reference . get inference context ( ( parameterized method binding ) compile time decl ) ; dcnl int inner inference kind = determine inference kind ( compile time decl , argument types , inner context ) ;
return null ; / / already incorporated
private boolean needs inference ( reference expression reference , method binding original ) { dcnl if ( reference . type arguments ! = null ) dcnl return false ; dcnl type binding compile time return ; dcnl if ( original . is constructor ( ) ) { dcnl / / not checking r . mentions any for constructors , because a : : new resolves to the raw type dcnl / / whereas in fact the type of all expressions of this shape depend on their type variable ( if any ) dcnl if ( original . declaring class . type variables ( ) ! = binding . no type variables dcnl & & reference . receiver type . is raw type ( ) ) dcnl return true ; / / diamond dcnl compile time return = original . declaring class ; dcnl } else { dcnl compile time return = original . return type ; dcnl } dcnl return ( original . type variables ( ) ! = binding . no type variables dcnl & & compile time return . mentions any ( original . type variables ( ) , - 1 ) ) ; dcnl } dcnl dcnl private int determine inference kind ( method binding original , type binding [ ] argument types , inference context18 inner context ) { dcnl if ( inner context ! = null ) dcnl return inner context . inference kind ; dcnl if ( original . is varargs ( ) ) { dcnl int expected len = original . parameters . length ; dcnl int provided len = argument types . length ; dcnl if ( expected len < provided len ) { dcnl return inference context18 . check vararg ; dcnl } else if ( expected len = = provided len ) { dcnl type binding provided last = argument types [ expected len - 1 ] ; dcnl type binding expected last = original . parameters [ expected len - 1 ] ; dcnl if ( !provided last . is compatible with ( expected last ) ) { dcnl if ( expected last . is array type ( ) ) { dcnl expected last = expected last . leaf component type ( ) ; dcnl if ( provided last . is compatible with ( expected last ) ) dcnl return inference context18 . check vararg ; dcnl } dcnl } dcnl } dcnl } dcnl return inference context18 . check strict ; dcnl } dcnl
import org . eclipse . jdt . internal . compiler . lookup . array binding ;
} else if ( array binding . is array clone ( this . actual receiver type , this . binding )
type binding return type ; dcnl if ( ( this . bits & ast node . unchecked ) ! = 0 & & this . generic type arguments = = null ) { dcnl / / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 277643 , align with javac on jls 15 . 12 . 2 . 6 dcnl return type = this . binding . return type ; dcnl if ( return type ! = null ) { dcnl return type = scope . environment ( ) . convert to raw type ( return type . erasure ( ) , true ) ; dcnl }
return type = this . binding . return type ; dcnl if ( return type ! = null ) { dcnl return type = return type . capture ( scope , this . source start , this . source end ) ;
this . resolved type = return type ;
if ( this . binding . is constructor ( ) ) {
import org . eclipse . jdt . internal . compiler . class file ;
dcnl private method binding clone ;
return receiver type . get clone method ( method binding ) ;
public void test bug498362 comment0 ( ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* returns the type name entered into the type input field ( without the default file extension dcnl * < code > java < / code > , if entered ) .
string type name with extension = f type name dialog field . get text ( ) ; dcnl if ( !type name with extension . ends with ( java model util . default cu suffix ) ) { dcnl return type name with extension ; dcnl } else { dcnl int extension offset = type name with extension . last index of ( java model util . default cu suffix ) ; dcnl return type name with extension . substring ( 0 , extension offset ) ; dcnl }
dcnl string type name with extension = f type name dialog field . get text ( ) ;
if ( type name with extension . length ( ) = = 0 ) {
string type name without parameters = get type name without parameters ( get type name without extension ( e . text ) ) ;
expected problem attributes . put ( " interface static method invocation not below18" , new problem attributes ( categorized problem . cat syntax ) ) ; dcnl expected problem attributes . put ( " interface super invocation not below18" , new problem attributes ( categorized problem . cat syntax ) ) ;
* copyright ( c ) 2011 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . compiler . classfmt . class file constants ; dcnl import org . eclipse . jdt . internal . compiler . impl . compiler options ; dcnl import org . eclipse . jdt . internal . compiler . lookup . block scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . class scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reasons ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type binding ;
int find compatible enclosing ( reference binding enclosing type , type binding type , block scope scope ) {
compiler options compiler options = scope . compiler options ( ) ;
boolean is java8 = compiler options . compliance level > = class file constants . jdk1 8 ;
if ( !is legal | | !is java8 ) {
closest match , is java8 ? problem reasons . attempt to bypass direct super : problem reasons . interface method invocation not below18 ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
int depth = find compatible enclosing ( scope . reference type ( ) . binding , type , scope ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . compiler . ast . qualified super reference ;
public void interface super invocation not below18 ( qualified super reference qualified super reference ) { dcnl this . handle ( dcnl i problem . interface super invocation not below18 , dcnl no argument , dcnl no argument , dcnl qualified super reference . source start , dcnl qualified super reference . source end ) ; dcnl }
case problem reasons . interface method invocation not below18 : dcnl this . handle ( dcnl i problem . interface static method invocation not below18 , dcnl new string [ ] { dcnl new string ( method . declaring class . readable name ( ) ) , dcnl new string ( method . selector ) , dcnl } , dcnl new string [ ] { dcnl new string ( method . declaring class . short readable name ( ) ) , dcnl new string ( method . selector ) , dcnl } , dcnl ( int ) ( message send . name source position > > > 32 ) , dcnl ( int ) message send . name source position ) ; dcnl return ;
assert method body proposal ( " inner | " , " outer < e > . inner" , " inner | " ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import junit . framework . test ; dcnl
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . core . i package fragment ; dcnl import org . eclipse . jdt . core . i package fragment root ;
import org . eclipse . jdt . core . dom . i binding ;
import org . eclipse . jdt . core . dom . qualified name ;
public reference binding maybe create parameterized type ( reference binding non generic type , reference binding enclosing type ) { dcnl boolean can see enclosing type parameters = enclosing type ! = null dcnl & & ( enclosing type . is parameterized type ( ) | enclosing type . is raw type ( ) ) dcnl & & !non generic type . is static ( ) ; dcnl if ( can see enclosing type parameters ) dcnl return create parameterized type ( non generic type , null , enclosing type ) ; dcnl return non generic type ; dcnl }
reference binding current type = create parameterized type ( actual type , type arguments , actual enclosing , annotations ) ;
binary type binding . resolve type ( current type , this , false ) ; dcnl reference binding enclosing = ( current type instanceof parameterized type binding ) ? ( ( parameterized type binding ) current type ) . generic type ( ) : current type ; dcnl reference binding member type = enclosing . get member type ( member name ) ;
this . problem reporter . corrupted signature ( current type , wrapper . signature , member start ) ; / / aborts
if ( member type . is static ( ) ) { dcnl if ( annotations ! = binding . no annotations ) dcnl current type = ( reference binding ) create annotated type ( member type , annotations ) ; dcnl else dcnl current type = member type ; dcnl continue ; / / skip inaccessible type arguments of outer if any dcnl }
current type = create parameterized type ( member type , type arguments , current type , annotations ) ;
import org . eclipse . jdt . internal . compiler . compiler ;
import org . eclipse . jdt . internal . compiler . lookup . method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . reference binding ;
depth = count non static nesting levels ( binding ) + 1 ;
/ / compute depth below lowest static enclosing type dcnl private int count non static nesting levels ( type binding binding ) { dcnl if ( binding . is unresolved type ( ) ) { dcnl throw new illegal state exception ( ) ; dcnl } dcnl int depth = - 1 ; dcnl type binding current binding = binding ; dcnl while ( current binding ! = null ) { dcnl depth + + ; dcnl if ( current binding . is static ( ) ) dcnl break ; dcnl current binding = current binding . enclosing type ( ) ; dcnl } dcnl return depth ; dcnl } dcnl
dcnl i type annotation walker saved walker = walker ; dcnl if ( actual type . depth ( ) > 0 ) { dcnl int non static nesting levels = count non static nesting levels ( actual type ) ; dcnl for ( int i = 0 ; i < non static nesting levels ; i + + ) { dcnl walker = walker . to next nested type ( ) ; dcnl } dcnl } dcnl
reference binding current type = create parameterized type ( actual type , type arguments , actual enclosing ) ;
if ( member type . is static ( ) ) { dcnl / / may happen for class files generated by eclipse before bug 460491 was fixed . dcnl walker = saved walker ;
walker = walker . to next nested type ( ) ;
if ( member type . is static ( ) ) { dcnl current type = member type ; dcnl } else { dcnl current type = create parameterized type ( member type , type arguments , current type ) ; dcnl }
reference binding plain current = actual type ;
plain current = ( reference binding ) binary type binding . resolve type ( plain current , this , false ) ; dcnl reference binding member type = plain current . get member type ( member name ) ;
if ( type arguments ! = null | | / / has type arguments , or . . . dcnl ( !member type . is static ( ) & & current type . is parameterized type ( ) ) ) / / . . . can see type arguments of enclosing dcnl { dcnl if ( member type . is static ( ) ) dcnl current type = plain current ; / / ignore bogus parameterization of enclosing
} else { dcnl current type = member type ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
" - modulesourcepath < directories separated by " + file . path separator + " > \ n" +
import org . eclipse . jdt . internal . compiler . lookup . type constants ;
dcnl private module source path manager module path manager ;
import org . eclipse . jdt . internal . compiler . env . i module ;
char [ ] name array = module name . to char array ( ) ; dcnl seek modules ( name array , requestor ) ;
import org . eclipse . jdt . internal . compiler . classfmt . class file reader ;
if ( info ! = null ) dcnl return info . get module ( ) ;
" ^ ^ \ n" +
" ^ ^ \ n" +
" ^ ^ \ n" +
" ^ ^ \ n" +
check source range ( simple name , "y1" , source ) ;
check source range ( simple name , "y3" , contents ) ;
check source range ( expr , "y3" , contents ) ;
check source range ( super field access , "super . yz" , contents ) ;
check source range ( super field access , "super . yz" , contents ) ;
/ / ( note : this an upper bound , because class names may contain '$' )
/ / make sure modules in the workspace are resolved via the module source path container dcnl / / without needing to add a dependency to the project explicitly dcnl public void test module source path container ( ) throws core exception { dcnl if ( !is jre9 ) return ; dcnl try { dcnl string [ ] sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module org . astro { \ n" + dcnl " exports org . astro ; \ n" + dcnl " } " , dcnl "src / org / astro / world . java" , dcnl "package org . astro ; \ n" + dcnl "public interface world { \ n" + dcnl " public string name ( ) ; \ n" + dcnl " } " dcnl } ; dcnl setup module project ( "org . astro" , sources ) ; dcnl string [ ] src = new string [ ] { dcnl "src / module - info . java" , dcnl "module com . greetings { \ n" + dcnl " requires org . astro ; \ n" + dcnl " exports com . greetings ; \ n" + dcnl " } " , dcnl "src / com / greetings / my world . java" , dcnl "package com . greetings ; \ n" + dcnl "import org . astro . world ; \ n" + dcnl "public class my world implements world { \ n" + dcnl " public string name ( ) { \ n" + dcnl " return \ " my world!! \ " ; \ n" + dcnl " } \ n" + dcnl " } " dcnl } ; dcnl i classpath entry dep = java core . new container entry ( new path ( java core . module path container id ) ) ; dcnl i java project p2 = setup module project ( "com . greetings" , src , new i classpath entry [ ] { dep } ) ; dcnl p2 . get project ( ) . get workspace ( ) . build ( incremental project builder . full build , null ) ; dcnl i marker [ ] markers = p2 . get project ( ) . find markers ( null , true , i resource . depth infinite ) ; dcnl assert markers ( " unexpected markers" , "" , markers ) ; dcnl } finally { dcnl delete project ( "org . astro" ) ; dcnl delete project ( "com . greetings" ) ; dcnl } dcnl } dcnl / / make sure module path container picks up changes to module - info dcnl public void test module source path update ( ) throws core exception { dcnl if ( !is jre9 ) return ; dcnl try { dcnl string [ ] sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module some . mod { \ n" + dcnl " } " dcnl } ; dcnl setup module project ( "some . mod" , sources ) ; dcnl sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module org . astro { \ n" + dcnl " exports org . astro ; \ n" + dcnl " } " , dcnl "src / org / astro / world . java" , dcnl "package org . astro ; \ n" + dcnl "public interface world { \ n" + dcnl " public string name ( ) ; \ n" + dcnl " } " dcnl } ; dcnl setup module project ( "org . astro" , sources ) ; dcnl string [ ] src = new string [ ] { dcnl "src / module - info . java" , dcnl "module com . greetings { \ n" + dcnl " requires org . astro ; \ n" + dcnl " exports com . greetings ; \ n" + dcnl " } " , dcnl "src / com / greetings / my world . java" , dcnl "package com . greetings ; \ n" + dcnl "import org . astro . world ; \ n" + dcnl "public class my world implements world { \ n" + dcnl " public string name ( ) { \ n" + dcnl " return \ " my world!! \ " ; \ n" + dcnl " } \ n" + dcnl " } " dcnl } ; dcnl i classpath entry dep = java core . new container entry ( new path ( java core . module path container id ) ) ; dcnl i java project p2 = setup module project ( "com . greetings" , src , new i classpath entry [ ] { dep } ) ; dcnl this . edit file ( "com . greetings / src / module - info . java" , dcnl "module com . greetings { \ n" + dcnl " requires org . astro ; \ n" + dcnl " requires some . mod ; \ n" + dcnl " exports com . greetings ; \ n" + dcnl " } " ) ; dcnl p2 . get project ( ) . get workspace ( ) . build ( incremental project builder . full build , null ) ; dcnl i marker [ ] markers = p2 . get project ( ) . find markers ( null , true , i resource . depth infinite ) ; dcnl assert markers ( " unexpected markers" , "" , markers ) ; dcnl } finally { dcnl delete project ( "org . astro" ) ; dcnl delete project ( "some . mod" ) ; dcnl delete project ( "com . greetings" ) ; dcnl } dcnl } dcnl / / implicit module dependencies via the 'requires public' directive should be dcnl / / resolved via the module path container dcnl public void test module source path implicitdeps ( ) throws core exception { dcnl if ( !is jre9 ) return ; dcnl try { dcnl string [ ] sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module some . mod { \ n" + dcnl " requires public org . astro ; \ n" + dcnl " } " dcnl } ; dcnl i classpath entry dep = java core . new container entry ( new path ( java core . module path container id ) ) ; dcnl setup module project ( "some . mod" , sources , new i classpath entry [ ] { dep } ) ; dcnl sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module org . astro { \ n" + dcnl " exports org . astro ; \ n" + dcnl " } " , dcnl "src / org / astro / world . java" , dcnl "package org . astro ; \ n" + dcnl "public interface world { \ n" + dcnl " public string name ( ) ; \ n" + dcnl " } " dcnl } ; dcnl setup module project ( "org . astro" , sources , new i classpath entry [ ] { dep } ) ; dcnl string [ ] src = new string [ ] { dcnl "src / module - info . java" , dcnl "module com . greetings { \ n" + dcnl " requires some . mod ; \ n" + dcnl " exports com . greetings ; \ n" + dcnl " } " , dcnl "src / com / greetings / my world . java" , dcnl "package com . greetings ; \ n" + dcnl "import org . astro . world ; \ n" + dcnl "public class my world implements world { \ n" + dcnl " public string name ( ) { \ n" + dcnl " return \ " my world!! \ " ; \ n" + dcnl " } \ n" + dcnl " } " dcnl } ; dcnl dcnl i java project p2 = setup module project ( "com . greetings" , src , new i classpath entry [ ] { dep } ) ; dcnl p2 . get project ( ) . get workspace ( ) . build ( incremental project builder . full build , null ) ; dcnl i marker [ ] markers = p2 . get project ( ) . find markers ( null , true , i resource . depth infinite ) ; dcnl assert markers ( " unexpected markers" , "" , markers ) ; dcnl } finally { dcnl delete project ( "org . astro" ) ; dcnl delete project ( "some . mod" ) ; dcnl delete project ( "com . greetings" ) ; dcnl } dcnl } dcnl / / changes to implicit dependencies should be reflected dcnl public void test module source path implicitdeps2 ( ) throws core exception { dcnl if ( !is jre9 ) return ; dcnl try { dcnl string [ ] sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module some . mod { \ n" + dcnl " requires public org . astro ; \ n" + dcnl " } " dcnl } ; dcnl i classpath entry dep = java core . new container entry ( new path ( java core . module path container id ) ) ; dcnl setup module project ( "some . mod" , sources , new i classpath entry [ ] { dep } ) ; dcnl sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module org . astro { \ n" + dcnl " exports org . astro ; \ n" + dcnl " } " , dcnl "src / org / astro / world . java" , dcnl "package org . astro ; \ n" + dcnl "public interface world { \ n" + dcnl " public string name ( ) ; \ n" + dcnl " } " dcnl } ; dcnl setup module project ( "org . astro" , sources , new i classpath entry [ ] { dep } ) ; dcnl string [ ] src = new string [ ] { dcnl "src / module - info . java" , dcnl "module com . greetings { \ n" + dcnl " requires some . mod ; \ n" + dcnl " exports com . greetings ; \ n" + dcnl " } " , dcnl "src / com / greetings / my world . java" , dcnl "package com . greetings ; \ n" + dcnl "import org . astro . world ; \ n" + dcnl "public class my world implements world { \ n" + dcnl " public string name ( ) { \ n" + dcnl " return \ " my world!! \ " ; \ n" + dcnl " } \ n" + dcnl " } " dcnl } ; dcnl dcnl i java project p2 = setup module project ( "com . greetings" , src , new i classpath entry [ ] { dep } ) ; dcnl this . edit file ( "some . mod / src / module - info . java" , dcnl "module some . mod { \ n" + dcnl " requires org . astro ; \ n" + dcnl " } " ) ; dcnl p2 . get project ( ) . get workspace ( ) . build ( incremental project builder . full build , null ) ; dcnl i marker [ ] markers = p2 . get project ( ) . find markers ( null , true , i resource . depth infinite ) ; dcnl assert markers ( " unexpected markers" , dcnl " the import org cannot be resolved \ n" + dcnl " world cannot be resolved to a type" , markers ) ; dcnl } finally { dcnl delete project ( "org . astro" ) ; dcnl delete project ( "some . mod" ) ; dcnl delete project ( "com . greetings" ) ; dcnl } dcnl } dcnl / / changes to implicit dependencies should be reflected dcnl / / todo enable once we know how to update project cache dcnl public void test module source path implicitdeps3 ( ) throws core exception { dcnl if ( !is jre9 ) return ; dcnl try { dcnl string [ ] sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module some . mod { \ n" + dcnl " requires org . astro ; \ n" + dcnl " } " dcnl } ; dcnl i classpath entry dep = java core . new container entry ( new path ( java core . module path container id ) ) ; dcnl setup module project ( "some . mod" , sources , new i classpath entry [ ] { dep } ) ; dcnl sources = new string [ ] { dcnl "src / module - info . java" , dcnl "module org . astro { \ n" + dcnl " exports org . astro ; \ n" + dcnl " } " , dcnl "src / org / astro / world . java" , dcnl "package org . astro ; \ n" + dcnl "public interface world { \ n" + dcnl " public string name ( ) ; \ n" + dcnl " } " dcnl } ; dcnl setup module project ( "org . astro" , sources , new i classpath entry [ ] { dep } ) ; dcnl string [ ] src = new string [ ] { dcnl "src / module - info . java" , dcnl "module com . greetings { \ n" + dcnl " requires some . mod ; \ n" + dcnl " exports com . greetings ; \ n" + dcnl " } " , dcnl "src / com / greetings / my world . java" , dcnl "package com . greetings ; \ n" + dcnl "import org . astro . world ; \ n" + dcnl "public class my world implements world { \ n" + dcnl " public string name ( ) { \ n" + dcnl " return \ " my world!! \ " ; \ n" + dcnl " } \ n" + dcnl " } " dcnl } ; dcnl dcnl i java project p2 = setup module project ( "com . greetings" , src , new i classpath entry [ ] { dep } ) ; dcnl this . edit file ( "some . mod / src / module - info . java" , dcnl "module some . mod { \ n" + dcnl " requires public org . astro ; \ n" + dcnl " } " ) ; dcnl p2 . get project ( ) . get workspace ( ) . build ( incremental project builder . full build , null ) ; dcnl i marker [ ] markers = p2 . get project ( ) . find markers ( null , true , i resource . depth infinite ) ; dcnl assert markers ( " unexpected markers" , "" , markers ) ; dcnl } finally { dcnl delete project ( "org . astro" ) ; dcnl delete project ( "some . mod" ) ; dcnl delete project ( "com . greetings" ) ; dcnl } dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
final string path = "jar : " + "platform : / resource / attached javadoc project / doc . zip" + "! / doc" ;
* copyright ( c ) 2005 , 2016 ibm corporation and others .
int [ ] index ;
index = get anchor index ( from index ) ; dcnl while ( index [ 0 ] ! = - 1 & & ( index [ 0 ] < index of section bottom | | index of section bottom = = - 1 ) ) { dcnl from index = index [ 0 ] + 1 ; dcnl dcnl int anchor end start = index [ 0 ] + index [ 1 ] ; dcnl
index = get anchor index ( from index ) ;
private int [ ] get anchor index ( int from index ) { dcnl int index = char operation . index of ( javadoc constants . anchor prefix start , this . content , false , from index ) ; dcnl if ( index ! = - 1 ) { dcnl return new int [ ] { index , javadoc constants . anchor prefix start length } ; dcnl } dcnl if ( index = = - 1 ) { dcnl index = char operation . index of ( javadoc constants . anchor prefix start 2 , this . content , false , from index ) ; dcnl } dcnl if ( index = = - 1 ) { dcnl return new int [ ] { - 1 , - 1 } ; dcnl } else { dcnl return new int [ ] { index , javadoc constants . anchor prefix start2 length } ; dcnl } dcnl }
* copyright ( c ) 2011 , 2016 gk software ag and others .
import org . eclipse . jdt . core . i java element ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
java debug preference page show step result 1 = s & how method result after a step operation ( if supported by the vm ; may be slow )
expected problem attributes . put ( " cannot infer invocation type" , new problem attributes ( categorized problem . cat type ) ) ;
/ / 8u20 emits just one message inferred type not conforming to upper bound .
"1 . error in x . java ( at line 8 ) \ n" + dcnl " ss . stream ( ) . map ( s - > { \ n" + dcnl " class l1 { } ; \ n" + dcnl " class l2 { \ n" + dcnl " void mm ( l1 l ) { } \ n" + dcnl " } \ n" + dcnl " return new l2 ( ) . mm ( new l1 ( ) ) ; \ n" + dcnl " } ) . for each ( e - > system . out . println ( e ) ) ; \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " cannot infer type argument ( s ) for < r > map ( function < ? super t , ? extends r > ) \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "2 . error in x . java ( at line 13 ) \ n" +
import org . eclipse . jdt . internal . compiler . ast . expression context ;
if ( problem method . return type = = shown method . return type ) { / / $identity - comparison$ dcnl if ( message send . expression context = = expression context . vanilla context ) { dcnl type variable binding [ ] type variables = method . shallow original ( ) . type variables ; dcnl string type arguments = types as string ( type variables , false ) ; dcnl this . handle ( i problem . cannot infer invocation type , dcnl new string [ ] { type arguments , string . value of ( shown method . original ( ) . readable name ( ) ) } , dcnl new string [ ] { type arguments , string . value of ( shown method . original ( ) . short readable name ( ) ) } , dcnl message send . source start , dcnl message send . source end ) ; dcnl }
if ( manager . virtual machine ( ) . can get method return values ( ) & & show step result is enabled ( ) ) {
* copyright ( c ) 2015 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
i java project project = get java project ( stack frame ) ; dcnl if ( project ! = null ) {
protected i java project get java project ( i stack frame stack frame ) {
i java project java project = null ; dcnl if ( stack frame instanceof i java stack frame ) { dcnl java project = java debug utils . resolve java project ( ( i java stack frame ) stack frame ) ;
* copyright ( c ) 2005 , 2016 ibm corporation and others .
object source element = resolve source element ( object , launch ) ; dcnl i java element java element = get java element ( source element ) ; dcnl if ( java element = = null ) { dcnl / / fallback if default stratum does not provide a java element dcnl source element = resolve source element ( object , java stratum , launch ) ; dcnl java element = get java element ( source element ) ; dcnl } dcnl return java element ;
object source element = resolve source element ( frame , launch ) ;
import org . eclipse . jdt . internal . compiler . flow . field inits faking flow context ;
if ( current instanceof field inits faking flow context ) { dcnl return flow info . dead end ; / / is definitely assigned will return true for all fields dcnl }
file output directory = new file ( output dir ) ; dcnl util . flush directory content ( output directory ) ; dcnl string out = "bin" ; dcnl string directory = output dir + file . separator + "src" ; dcnl string module loc = directory + file . separator + "mod . one" ; dcnl write file ( module loc , "module - info . java" , dcnl "module mod . one { \ n" + dcnl " exports p ; \ n" + dcnl " requires mod . two ; \ n" + dcnl " requires public java . sql ; \ n" + dcnl " } " ) ; dcnl write file ( module loc + file . separator + "p" , "x . java" , dcnl "package p ; \ n" + dcnl "import q . y ; \ n" + dcnl "public class x { \ n" + dcnl " public static java . sql . connection get connection ( ) { \ n" + dcnl " return y . con ; \ n" + dcnl " } \ n" + dcnl " } " ) ; dcnl module loc = directory + file . separator + "mod . two" ; dcnl write file ( module loc , "module - info . java" , dcnl "module mod . two { \ n" + dcnl " exports q ; \ n" + dcnl " requires java . base ; \ n" + dcnl " } " ) ; dcnl write file ( module loc + file . separator + "q" , "y . java" , dcnl "package q ; \ n" + dcnl "public class y { \ n" + dcnl " public static java . sql . connection con = null ; \ n" + dcnl " } " ) ; dcnl dcnl string buffer buffer = new string buffer ( ) ; dcnl buffer . append ( " - d " + output dir + file . separator + out ) dcnl . append ( " - 9 " ) dcnl . append ( " - classpath \ "" ) dcnl . append ( util . get java class libs as string ( ) ) dcnl . append ( " \ " " ) dcnl . append ( " - modulesourcepath " + " \ "" + directory + " \ "" ) ; dcnl dcnl run conform test ( new string [ ] { } , dcnl buffer . to string ( ) , dcnl "" , dcnl "" , dcnl false ) ; dcnl } dcnl public void test008a ( ) {
/ / this one is not exported ( i . e . internal to this module ) dcnl write file ( module loc + file . separator + "p1" , "x1 . java" , dcnl "package p1 ; \ n" + dcnl "public class x1 { \ n" + dcnl " public static java . sql . connection get connection ( ) { \ n" + dcnl " return null ; \ n" + dcnl " } \ n" + dcnl " } " ) ;
write file ( module loc + file . separator + "r" , "z . java" ,
reference binding original reference type = ( reference binding ) original type . unannotated ( ) ;
import java . io . buffered input stream ;
string read fully ( i file file ) throws io exception , core exception { dcnl try ( buffered input stream bs = new buffered input stream ( file . get contents ( ) ) ) { dcnl int available = 0 ; dcnl string builder buf = new string builder ( ) ; dcnl while ( ( available = bs . available ( ) ) > 0 ) { dcnl byte [ ] contents = new byte [ available ] ; dcnl bs . read ( contents ) ; dcnl buf . append ( new string ( contents ) ) ; dcnl } dcnl return buf . to string ( ) ; dcnl } dcnl } dcnl
/ / check that the error is resolved now :
if ( !severity . is any mismatch ( ) & & ( provided bits & tag bits . annotation null mask ) = = tag bits . annotation non null )
/ * * dcnl * use only if no suitable flow info is available . dcnl * / dcnl public static int null status from expression type ( type binding type ) { dcnl if ( type . is free type variable ( ) ) dcnl return flow info . free typevariable ; dcnl long bits = type . tag bits & tag bits . annotation null mask ; dcnl if ( bits = = 0 ) dcnl return flow info . unknown ; dcnl if ( bits = = tag bits . annotation non null ) dcnl return flow info . non null ; dcnl return flow info . potentially non null | flow info . potentially null ; dcnl } dcnl
tests names = new string [ ] { "test495912" } ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
if ( this . initializer body = = null ) { dcnl block block = new block ( 0 ) ; dcnl block . source start = ( ( initializer ) this . field declaration ) . source start ; dcnl recovered element element = this . add ( block , 1 ) ; dcnl if ( this . bracket balance > 0 ) { dcnl for ( int i = 0 ; i < this . bracket balance - 1 ; i + + ) { dcnl element = element . add ( new block ( 0 ) , 1 ) ; dcnl } dcnl this . bracket balance = 1 ; dcnl } dcnl return element . add ( local declaration , bracket balance value ) ; dcnl } dcnl this . initializer body . attach pending modifiers (
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ / from either package is imported from com . notimported , instead of preserving the existing dcnl / / unresolvable import from com . notfound .
import java . util . map . entry ;
f imports added . add ( type name ) ; dcnl f unresolved types . put ( type name , new unresolved type data ( ref ) ) ;
for ( entry < string , unresolved type data > entry : f unresolved types . entry set ( ) ) { dcnl if ( entry . get value ( ) . found infos . size ( ) = = 0 ) { / / no result found in search dcnl set < string > matching unresolvable imports = f unresolvable import matcher . match type imports ( entry . get key ( ) ) ; dcnl if ( !matching unresolvable imports . is empty ( ) ) { dcnl / / if there are matching unresolvable import ( s ) , rely on them to provide the type . dcnl for ( string string : matching unresolvable imports ) { dcnl f imp structure . add import ( string , unresolvable import context ) ; dcnl } dcnl } dcnl } dcnl } dcnl
try ( input stream in = file . get contents ( ) ) {
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
* @ throws exception multiple causes
static final string constructor selector = " < init > " ; / / $non - nls - 1$ dcnl
buffer . append ( " < dt > " ) . append ( get html representation ( f selector ) ) . append ( " < / dt > " ) ; / / $non - nls - 1$ / / $non - nls - 2$
/ * quick assist on class file , propose changes on any type detail . * /
if ( inner = = null | | inner . get node type ( ) = = ast node . primitive type )
run conform test (
/ / not spec'd : dcnl bound set connectivity bound set = this . current bounds . copy ( ) ; dcnl for ( constraint formula cf : c ) dcnl connectivity bound set . reduce one constraint ( this , cf ) ;
list < set < inference variable > > components = connectivity bound set . compute connected components ( this . inference variables ) ;
if ( interleaved & & inner context ! = null ) {
if ( var . type parameter = = type parameter & & var . rank = = rank & & is same site ( var . site , site ) ) / / $identity - comparison$
dcnl boolean is same site ( invocation site site1 , invocation site site2 ) { dcnl if ( site1 = = site2 ) dcnl return true ; dcnl if ( site1 = = null | | site2 = = null ) dcnl return false ; dcnl if ( site1 . source start ( ) = = site2 . source start ( ) & & site1 . source end ( ) = = site2 . source end ( ) & & site1 . to string ( ) . equals ( site2 . to string ( ) ) ) dcnl return true ; dcnl return false ; dcnl }
if ( !t . is proper type ( true ) & & t . is parameterized type ( ) ) { dcnl / / prevent already resolved inference variables from leaking into the lambda dcnl t = ( reference binding ) scope . substitute ( get result substitution ( this . current bounds , false ) , t ) ; dcnl }
if ( inner context . step completed < inference context18 . applicability inferred ) / / shouldn't happen , but let's play safe dcnl inner context . infer invocation applicability ( shallow method , argument types , shallow method . is constructor ( ) ) ;
< resource path = "meta - inf / manifest . mf" > dcnl < filter comment = " new constant in i problem is not api announced in 3 . 12" id = "924844039" >
copyright ( c ) 2012 , 2016 eclipse foundation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ / from either package is imported from com . notimported , instead of preserving the existing dcnl / / unresolvable import from com . notfound .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import java . util . map . entry ;
f imports added . add ( type name ) ; dcnl f unresolved types . put ( type name , new unresolved type data ( ref ) ) ;
for ( entry < string , unresolved type data > entry : f unresolved types . entry set ( ) ) { dcnl if ( entry . get value ( ) . found infos . size ( ) = = 0 ) { / / no result found in search dcnl set < string > matching unresolvable imports = f unresolvable import matcher . match type imports ( entry . get key ( ) ) ; dcnl if ( !matching unresolvable imports . is empty ( ) ) { dcnl / / if there are matching unresolvable import ( s ) , rely on them to provide the type . dcnl for ( string string : matching unresolvable imports ) { dcnl f imp structure . add import ( string , unresolvable import context ) ; dcnl } dcnl } dcnl } dcnl } dcnl
* @ deprecated in the jls9 api , this property is replaced by { @ link #resources2 property } .
/ / "i bar [ type ref ] { i bar , test , ltest . i bar ; , null , " + ( r default + 39 ) + " } \ n" + dcnl / / "i foo [ type ref ] { i foo , test , ltest . i foo ; , null , " + ( r default + 39 ) + " } "
"i bar [ type ref ] { i bar , test , ltest . i bar ; , null , " + ( r default + 39 ) + " } " ,
/ / " interface1 [ type ref ] { interface1 , test , ltest . interface1 ; , null , " + ( r default + 39 ) + " } \ n" + dcnl " interface2 [ type ref ] { interface2 , test , ltest . interface2 ; , null , " + ( r default + 39 ) + " } " ,
" enclosing . interface2 [ type ref ] { p . enclosing . interface2 , p , lp . enclosing$ interface2 ; , null , " + ( r default + 39 ) + " } " ,
" enclosing . interface1 [ type ref ] { p . enclosing . interface1 , p , lp . enclosing$ interface1 ; , null , " + ( r default + 39 ) + " } \ n" + dcnl " enclosing . interface2 [ type ref ] { p . enclosing . interface2 , p , lp . enclosing$ interface2 ; , null , " + ( r default + 39 ) + " } " ,
" tr [ potential method declaration ] { tr , ltest . try ; , ( ) v , tr , null , " + ( r default + 9 ) + " } \ n" + dcnl "transient [ keyword ] { transient , null , null , transient , null , " + ( r default + 9 ) + " } \ n" + dcnl " try [ type ref ] { try , test , ltest . try ; , null , null , " + ( r default + 22 ) + " } " ,
" error [ type ref ] { error , java . lang , ljava . lang . error ; , null , null , " + ( r default + 12 ) + " } \ n" + dcnl " exception [ type ref ] { exception , java . lang , ljava . lang . exception ; , null , null , " + ( r default + 12 ) + " } \ n" + dcnl "equals [ method ref ] { try . this . equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 19 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } " ,
"a class [ type ref ] { a class , test , ltest . a class ; , null , null , " + ( r default + 22 ) + " } " ,
"a class [ type ref ] { a class , test , ltest . a class ; , null , null , " + ( r default + 22 ) + " } " ,
" inn . inn2 [ type ref ] { test . inn . inn2 , test , ltest . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl "abc . abc interface [ type ref ] { abc interface , test , ltest . abc$abc interface ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " in [ type ref ] { in , test , ltest . in ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " inn [ type ref ] { inn , test , ltest . inn ; , null , null , " + ( r default + 42 ) + " } " ,
" inn . inn2 [ type ref ] { test . inn . inn2 , test , ltest . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl " inn . inn2 . inn3 [ type ref ] { test . inn . inn2 . inn3 , test , ltest . inn$ inn2$ inn3 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl "abc [ type ref ] { abc , test , ltest . abc ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " in [ type ref ] { in , test , ltest . in ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " inn [ type ref ] { inn , test , ltest . inn ; , null , null , " + ( r default + 42 ) + " } " ,
int relevance1 = r default + 52 ; dcnl int relevance2 = r default + 22 ; dcnl int relevance3 = r default + 17 ;
"my var1 [ local variable ref ] { my var1 , null , i , my var1 , null , " + ( r default + 52 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ field ref ] { my string , ltest . x ; , ljava . lang . string ; , my string , null , " + ( r default + 22 ) + " } \ n" + dcnl "my string2 [ field ref ] { my string2 , ltest . x ; , ljava . lang . string ; , my string2 , null , " + ( r default + 22 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ field ref ] { my string , ltest . x ; , ljava . lang . string ; , my string , null , " + ( r default + 52 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ local variable ref ] { my string , null , ljava . lang . string ; , my string , null , " + ( r default + 52 ) + " } \ n" + dcnl "my string2 [ local variable ref ] { my string2 , null , ljava . lang . string ; , my string2 , null , " + ( r default + 52 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ local variable ref ] { my string , null , ljava . lang . string ; , my string , null , " + ( r default + 52 ) + " } \ n" + dcnl "my string1 [ local variable ref ] { my string1 , null , ljava . lang . string ; , my string1 , null , " + ( r default + 52 ) + " } " ,
int relevance = r default + 21 ;
"def [ potential method declaration ] { def , ltest . p ; , ( ) v , def , null , " + ( r default + 9 ) + " } \ n" + "default [ keyword ] { default , null , null , default , null , " + ( r default + 19 ) + " } " ,
"def [ potential method declaration ] { def , ltest . p ; , ( ) v , def , null , " + ( r default + 9 ) + " } " ,
"def [ potential method declaration ] { def , ltest . zz$i ; , ( ) v , def , null , " + ( r default + 9 ) + " } \ n" + "default [ keyword ] { default , null , null , default , null , " + ( r default + 19 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( l number ; ) v , txyu , ( t ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( l number ; ) v , txyu , ( t ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } " ,
"mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 19 ) + " } \ n" + dcnl " my class [ type ref ] { my class , test , ltest . my class ; , null , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class field [ field ref ] { my class field , ltest . try ; , ltest . my class ; , my class field , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class method [ method ref ] { my class method ( ) , ltest . try ; , ( ) ltest . my class ; , my class method , null , " + ( r default + 52 ) + " } " ,
"finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , notify , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , notify all , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , wait , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , wait , ( millis ) , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , wait , ( millis , nanos ) , " + ( r default + 17 ) + " } \ n" + dcnl " try [ type ref ] { try , test , ltest . try ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class ; , get class , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } \ n" + dcnl " my class [ type ref ] { my class , test , ltest . my class ; , null , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class field [ field ref ] { my class field , ltest . try ; , ltest . my class ; , my class field , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class method [ method ref ] { my class method ( ) , ltest . try ; , ( ) ltest . my class ; , my class method , null , " + ( r default + 52 ) + " } " ,
"finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , notify , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , notify all , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , wait , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , wait , ( millis ) , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , wait , ( millis , nanos ) , " + ( r default + 17 ) + " } \ n" + dcnl " try [ type ref ] { try , test , ltest . try ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class ; , get class , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } \ n" + dcnl " my class [ type ref ] { my class , test , ltest . my class ; , null , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class field [ field ref ] { my class field , ltest . try ; , ltest . my class ; , my class field , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class method [ method ref ] { my class method ( ) , ltest . try ; , ( ) ltest . my class ; , my class method , null , " + ( r default + 52 ) + " } " ,
"it may be due to mixing perhaps [ field ref ] { it may be due to mixing perhaps , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , it may be due to mixing perhaps , null , " + ( r default + 21 ) + " } \ n" + dcnl "more stuff [ field ref ] { more stuff , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , more stuff , null , " + ( r default + 21 ) + " } \ n" + dcnl "other [ field ref ] { other , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , other , null , " + ( r default + 21 ) + " } \ n" + dcnl "still other [ field ref ] { still other , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , still other , null , " + ( r default + 21 ) + " } \ n" + dcnl "stuff [ field ref ] { stuff , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , stuff , null , " + ( r default + 21 ) + " } \ n" + dcnl "things [ field ref ] { things , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , things , null , " + ( r default + 21 ) + " } \ n" + dcnl "class [ field ref ] { class , null , ljava . lang . class < ltest . example enum no autocomplete ; > ; , class , null , " + ( r default + 21 ) + " } \ n" + dcnl "value of [ method ref ] { value of ( ) , ltest . example enum no autocomplete ; , ( ljava . lang . string ; ) ltest . example enum no autocomplete ; , value of , ( arg0 ) , " + ( r default + 21 ) + " } \ n" + dcnl "values [ method ref ] { values ( ) , ltest . example enum no autocomplete ; , ( ) [ ltest . example enum no autocomplete ; , values , null , " + ( r default + 21 ) + " } " ,
"static method [ method ref ] { static method ( ) , ltest . test ; , ( ) v , static method , null , " + ( r default + 22 ) + " } " ,
"static method [ method ref ] { static method ( ) , ltest . i ; , ( ) v , static method , null , " + ( r default + 21 ) + " } " ,
"default method [ method ref ] { default method ( ) , ltest . i ; , ( ) v , default method , null , " + ( r default + 30 ) + " } " ,
"default method [ method ref ] { default method ( ) , ltest . i ; , ( ) v , default method , null , " + ( r default + 22 ) + " } " ,
"to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 60 ) + " } " ,
"i [ type ref ] { i , test , ltest . i ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x [ type ref ] { x , test , ltest . x ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "args [ local variable ref ] { args , null , [ ljava . lang . string ; , args , null , " + ( r default + 22 ) + " } \ n" + dcnl "i [ local variable ref ] { i , null , ltest . i ; , i , null , " + ( r default + 22 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , ltest . x ; , ( [ ljava . lang . string ; ) v , main , ( args ) , " + ( r default + 22 ) + " } \ n" + dcnl "x [ local variable ref ] { x , null , [ [ [ ltest . x ; , x , null , " + ( r default + 22 ) + " } " ,
"i [ type ref ] { i , test , ltest . i ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "s [ type ref ] { s , null , ts ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x < s > [ type ref ] { x , test , ltest . x < ts ; > ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "args [ local variable ref ] { args , null , [ ljava . lang . string ; , args , null , " + ( r default + 22 ) + " } \ n" + dcnl "i [ local variable ref ] { i , null , ltest . i ; , i , null , " + ( r default + 22 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , ltest . x < ts ; > ; , ( [ ljava . lang . string ; ) v , main , ( args ) , " + ( r default + 22 ) + " } \ n" + dcnl "x [ local variable ref ] { x , null , ltest . x ; , x , null , " + ( r default + 22 ) + " } " ,
"pqrqwerty [ local variable ref ] { pqrqwerty , null , i , pqrqwerty , null , " + ( r default + 22 ) + " } " ,
"first [ local variable ref ] { first , null , i , first , null , " + ( r default + 22 ) + " } " ,
"first [ local variable ref ] { first , null , i , first , null , " + ( r default + 22 ) + " } " ,
"case insensitive order [ field ref ] { case insensitive order , ljava . lang . string ; , ljava . util . comparator < ljava . lang . string ; > ; , case insensitive order , null , " + ( r default + 9 ) + " } \ n" + dcnl "copy value of [ method ref ] { copy value of ( ) , ljava . lang . string ; , ( [ c ) ljava . lang . string ; , copy value of , ( arg0 ) , " + ( r default + 19 ) + " } \ n" + dcnl "copy value of [ method ref ] { copy value of ( ) , ljava . lang . string ; , ( [ cii ) ljava . lang . string ; , copy value of , ( arg0 , arg1 , arg2 ) , " + ( r default + 19 ) + " } \ n" + dcnl "char at [ method ref ] { char at ( ) , ljava . lang . string ; , ( i ) c , char at , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "chars [ method ref ] { chars ( ) , ljava . lang . char sequence ; , ( ) ljava . util . stream . int stream ; , chars , null , " + ( r default + 30 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 30 ) + " } \ n" + dcnl "code point at [ method ref ] { code point at ( ) , ljava . lang . string ; , ( i ) i , code point at , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "code point before [ method ref ] { code point before ( ) , ljava . lang . string ; , ( i ) i , code point before , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "code point count [ method ref ] { code point count ( ) , ljava . lang . string ; , ( ii ) i , code point count , ( arg0 , arg1 ) , " + ( r default + 30 ) + " } \ n" + dcnl "code points [ method ref ] { code points ( ) , ljava . lang . char sequence ; , ( ) ljava . util . stream . int stream ; , code points , null , " + ( r default + 30 ) + " } \ n" + dcnl "compare to [ method ref ] { compare to ( ) , ljava . lang . string ; , ( ljava . lang . string ; ) i , compare to , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "compare to ignore case [ method ref ] { compare to ignore case ( ) , ljava . lang . string ; , ( ljava . lang . string ; ) i , compare to ignore case , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "concat [ method ref ] { concat ( ) , ljava . lang . string ; , ( ljava . lang . string ; ) ljava . lang . string ; , concat , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "contains [ method ref ] { contains ( ) , ljava . lang . string ; , ( ljava . lang . char sequence ; ) z , contains , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "content equals [ method ref ] { content equals ( ) , ljava . lang . string ; , ( ljava . lang . char sequence ; ) z , content equals , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "content equals [ method ref ] { content equals ( ) , ljava . lang . string ; , ( ljava . lang . string buffer ; ) z , content equals , ( arg0 ) , " + ( r default + 30 ) + " } " ,
"lpx5 [ local variable ref ] { lpx5 , null , i , lpx5 , null , " + ( r default + 22 ) + " } \ n" + dcnl "lpx6 [ local variable ref ] { lpx6 , null , i , lpx6 , null , " + ( r default + 22 ) + " } " ,
"argument [ local variable ref ] { argument , null , i , argument , null , " + ( r default + 52 ) + " } " ,
"argument [ local variable ref ] { argument , null , i , argument , null , " + ( r default + 22 ) + " } " ,
"class [ field ref ] { class , null , ljava . lang . class < lx ; > ; , class , null , " + ( r default + 21 ) + " } \ n" + dcnl "f [ field ref ] { f , lx ; , l foo ; , f , null , " + ( r default + 21 ) + " } \ n" + dcnl "this [ keyword ] { this , null , null , this , null , " + ( r default + 21 ) + " } \ n" + dcnl "x1 [ field ref ] { x1 , lx ; , i , x1 , null , " + ( r default + 51 ) + " } " ,
" [ potential method declaration ] { , lx ; , ( ) v , , null , " + ( r default + 9 ) + " } \ n" + dcnl "abstract [ keyword ] { abstract , null , null , abstract , null , " + ( r default + 19 ) + " } \ n" + dcnl "class [ keyword ] { class , null , null , class , null , " + ( r default + 19 ) + " } \ n" + dcnl "enum [ keyword ] { enum , null , null , enum , null , " + ( r default + 19 ) + " } \ n" + dcnl "final [ keyword ] { final , null , null , final , null , " + ( r default + 19 ) + " } \ n" + dcnl "interface [ keyword ] { interface , null , null , interface , null , " + ( r default + 19 ) + " } \ n" + dcnl "native [ keyword ] { native , null , null , native , null , " + ( r default + 19 ) + " } \ n" + dcnl "private [ keyword ] { private , null , null , private , null , " + ( r default + 19 ) + " } \ n" + dcnl "protected [ keyword ] { protected , null , null , protected , null , " + ( r default + 19 ) + " } \ n" + dcnl "public [ keyword ] { public , null , null , public , null , " + ( r default + 19 ) + " } \ n" + dcnl "static [ keyword ] { static , null , null , static , null , " + ( r default + 19 ) + " } \ n" + dcnl "strictfp [ keyword ] { strictfp , null , null , strictfp , null , " + ( r default + 19 ) + " } \ n" + dcnl "synchronized [ keyword ] { synchronized , null , null , synchronized , null , " + ( r default + 19 ) + " } \ n" + dcnl "transient [ keyword ] { transient , null , null , transient , null , " + ( r default + 19 ) + " } \ n" + dcnl "volatile [ keyword ] { volatile , null , null , volatile , null , " + ( r default + 19 ) + " } \ n" + dcnl "i [ type ref ] { i , , li ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "j [ type ref ] { j , , lj ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x [ type ref ] { x , , lx ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method declaration ] { protected object clone ( ) throws clone not supported exception , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method declaration ] { public boolean equals ( object obj ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "finalize [ method declaration ] { protected void finalize ( ) throws throwable , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method declaration ] { public int hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method declaration ] { public string to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } " ,
" [ potential method declaration ] { , lx ; , ( ) v , , null , " + ( r default + 9 ) + " } \ n" + dcnl "abstract [ keyword ] { abstract , null , null , abstract , null , " + ( r default + 19 ) + " } \ n" + dcnl "class [ keyword ] { class , null , null , class , null , " + ( r default + 19 ) + " } \ n" + dcnl "enum [ keyword ] { enum , null , null , enum , null , " + ( r default + 19 ) + " } \ n" + dcnl "final [ keyword ] { final , null , null , final , null , " + ( r default + 19 ) + " } \ n" + dcnl "interface [ keyword ] { interface , null , null , interface , null , " + ( r default + 19 ) + " } \ n" + dcnl "native [ keyword ] { native , null , null , native , null , " + ( r default + 19 ) + " } \ n" + dcnl "private [ keyword ] { private , null , null , private , null , " + ( r default + 19 ) + " } \ n" + dcnl "protected [ keyword ] { protected , null , null , protected , null , " + ( r default + 19 ) + " } \ n" + dcnl "public [ keyword ] { public , null , null , public , null , " + ( r default + 19 ) + " } \ n" + dcnl "static [ keyword ] { static , null , null , static , null , " + ( r default + 19 ) + " } \ n" + dcnl "strictfp [ keyword ] { strictfp , null , null , strictfp , null , " + ( r default + 19 ) + " } \ n" + dcnl "synchronized [ keyword ] { synchronized , null , null , synchronized , null , " + ( r default + 19 ) + " } \ n" + dcnl "transient [ keyword ] { transient , null , null , transient , null , " + ( r default + 19 ) + " } \ n" + dcnl "volatile [ keyword ] { volatile , null , null , volatile , null , " + ( r default + 19 ) + " } \ n" + dcnl "i [ type ref ] { i , , li ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "j [ type ref ] { j , , lj ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x [ type ref ] { x , , lx ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method declaration ] { protected object clone ( ) throws clone not supported exception , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method declaration ] { public boolean equals ( object obj ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "finalize [ method declaration ] { protected void finalize ( ) throws throwable , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method declaration ] { public int hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method declaration ] { public string to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } " ,
"goo [ method ref ] { goo ( ) , lx ; , ( li ; ) v , goo , ( i ) , " + ( r default + 19 ) + " } \ n" + dcnl "goo [ method ref ] { goo ( ) , lx ; , ( ljava . lang . string ; ) v , goo , ( s ) , " + ( r default + 19 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , lx ; , ( [ ljava . lang . string ; ) v , main , ( args ) , " + ( r default + 19 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 30 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 30 ) + " } \ n" + dcnl "finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 30 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , get class , null , " + ( r default + 30 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 30 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , notify , null , " + ( r default + 30 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , notify all , null , " + ( r default + 30 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , wait , null , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , wait , ( millis ) , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , wait , ( millis , nanos ) , " + ( r default + 30 ) + " } " ,
assert results ( "array of strings [ local variable ref ] { array of strings , null , [ ljava . lang . string ; , null , null , array of strings , null , [ 168 , 174 ] , " + ( r default + 22 ) + " } \ n" + dcnl "array of ints [ local variable ref ] { array of ints , null , [ i , null , null , array of ints , null , [ 168 , 174 ] , " + ( r default + 52 ) + " } " , requestor . get results ( ) ) ;
assert results ( "xyz after [ local variable ref ] { xyz after , null , ljava . lang . object ; , null , null , xyz after , null , [ 132 , 135 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( "xyz before [ local variable ref ] { xyz before , null , ljava . lang . object ; , null , null , xyz before , null , [ 163 , 166 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( " string buffer input stream [ type ref ] { java . io . string buffer input stream , java . io , ljava . io . string buffer input stream ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string char buffer [ type ref ] { java . nio . string char buffer , java . nio , ljava . nio . string char buffer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string character iterator [ type ref ] { java . text . string character iterator , java . text , ljava . text . string character iterator ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string joiner [ type ref ] { java . util . string joiner , java . util , ljava . util . string joiner ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string reader [ type ref ] { java . io . string reader , java . io , ljava . io . string reader ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string tokenizer [ type ref ] { java . util . string tokenizer , java . util , ljava . util . string tokenizer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string writer [ type ref ] { java . io . string writer , java . io , ljava . io . string writer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " strict math [ type ref ] { strict math , java . lang , ljava . lang . strict math ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string [ type ref ] { string , java . lang , ljava . lang . string ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string buffer [ type ref ] { string buffer , java . lang , ljava . lang . string buffer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string builder [ type ref ] { string builder , java . lang , ljava . lang . string builder ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string coding [ type ref ] { string coding , java . lang , ljava . lang . string coding ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string index out of bounds exception [ type ref ] { string index out of bounds exception , java . lang , ljava . lang . string index out of bounds exception ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string parameter [ local variable ref ] { string parameter , null , lx ; , null , null , string parameter , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( " string parameter [ local variable ref ] { string parameter , null , lx ; , null , null , string parameter , null , [ 155 , 162 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "goo [ method ref ] { goo ( ) , lx ; , ( li ; ) v , null , null , goo , ( i ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , lx ; , ( [ ljava . lang . string ; ) v , null , null , main , ( args ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , null , null , clone , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , null , null , equals , ( obj ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "field [ field ref ] { field , lx ; , i , null , null , field , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , null , null , finalize , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "foo [ method ref ] { foo ( ) , lx ; , ( ) v , null , null , foo , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , null , null , hash code , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , null , null , notify , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , null , null , notify all , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , null , null , to string , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , null , null , wait , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , null , null , wait , ( millis ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , null , null , wait , ( millis , nanos ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "goo [ method ref ] { goo ( ) , lx ; , ( li ; ) v , null , null , goo , ( i ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , lx ; , ( [ ljava . lang . string ; ) v , null , null , main , ( args ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , null , null , clone , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , null , null , equals , ( obj ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "field [ field ref ] { field , lx ; , i , null , null , field , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , null , null , finalize , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "foo [ method ref ] { foo ( ) , lx ; , ( ) v , null , null , foo , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , null , null , hash code , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , null , null , notify , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , null , null , notify all , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , null , null , to string , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , null , null , wait , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , null , null , wait , ( millis ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , null , null , wait , ( millis , nanos ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
"bars [ method ref ] { bars ( ) , lb ; , ( ) i , bars , null , " + ( r default + 22 ) + " } " ,
"another [ field ref ] { another , lb ; , i , another , null , " + ( r default + 22 ) + " } " ,
"tryit [ local variable ref ] { tryit , null , i , null , null , tryit , null , [ 99 , 102 ] , " + ( r default + 22 ) + " } \ n" + dcnl "try [ keyword ] { try , null , null , null , null , try , null , [ 99 , 102 ] , " + ( r default + 23 ) + " } " ,
assert results ( " type use [ type ref ] { type use , , l type use ; , null , null , null , null , [ 131 , 133 ] , " + ( r default + 47 ) + " } " , requestor . get results ( ) ) ;
assert results ( " annotation [ type ref ] { annotation , , l annotation ; , null , null , null , null , [ 138 , 141 ] , " + ( r default + 42 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 186 , 189 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 186 , 189 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 267 , 270 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 267 , 270 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 293 , 296 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 293 , 296 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 285 , 288 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 285 , 288 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 272 , 275 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 272 , 275 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 203 , 206 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 203 , 206 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "long method name [ method name reference ] { long method name , lx ; , ( ljava . lang . string ; ) ljava . lang . string ; , null , null , long method name , ( x ) , [ 183 , 187 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
"long method name [ method name reference ] { long method name , ltest . x ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"long method name [ method name reference ] { long method name , ltest . x < ljava . lang . string ; > ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"long method name [ method name reference ] { long method name , ltest . y ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"long method name [ method name reference ] { long method name , ltest . y ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"as list [ local variable ref ] { as list , null , ljava . lang . object ; , as list , null , " + ( r default + 42 ) + " } " ,
"remove node from graph [ method ref ] { remove node from graph ( ) , ltest . x ; , ( ltest . x$ node ; ) v , remove node from graph , ( node ) , " + ( r default + 22 ) + " } " ,
"get class [ method name reference ] { get class , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , get class , null , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method name reference ] { get last name , ltest . person ; , ( ) ljava . lang . string ; , get last name , null , " + ( r default + 30 ) + " } " ,
assert results ( "out [ field ref ] { out , ljava . lang . system ; , ljava . io . print stream ; , null , null , out , null , [ 83 , 84 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( c ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( d ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( f ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( i ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( j ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( z ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( [ c ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method ref ] { printf ( ) , ljava . io . print stream ; , ( ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , ( arg0 , arg1 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method ref ] { printf ( ) , ljava . io . print stream ; , ( ljava . util . locale ; ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , ( arg0 , arg1 , arg2 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( ) v , null , null , println , null , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( c ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( d ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( f ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( i ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( j ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( z ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( [ c ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "start [ method ref ] { start ( ) , ljava . lang . thread ; , ( ) v , null , null , start , null , [ 103 , 105 ] , " + ( r default + 30 ) + " } \ n" + dcnl "stop [ method ref ] { stop ( ) , ljava . lang . thread ; , ( ) v , null , null , stop , null , [ 103 , 105 ] , " + ( r default + 30 ) + " } \ n" + dcnl "stop [ method ref ] { stop ( ) , ljava . lang . thread ; , ( ljava . lang . throwable ; ) v , null , null , stop , ( arg0 ) , [ 103 , 105 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( i ) i , null , null , hash code , ( arg0 ) , [ 187 , 188 ] , " + ( r default + 49 ) + " } \ n" + dcnl "highest one bit [ method ref ] { highest one bit ( ) , ljava . lang . integer ; , ( i ) i , null , null , highest one bit , ( arg0 ) , [ 187 , 188 ] , " + ( r default + 49 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( ) i , null , null , hash code , null , [ 187 , 188 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "print [ method name reference ] { print , ljava . io . print stream ; , ( c ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( d ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( f ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( i ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( j ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( z ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( [ c ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( c ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( d ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( f ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( i ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( j ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( z ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( [ c ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 219 , 222 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . util . locale ; ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 219 , 222 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 355 , 358 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 355 , 358 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 355 , 358 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 391 , 392 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get [ method ref ] { get ( ) , ljava . util . optional < ljava . lang . double ; > ; , ( ) ljava . lang . double ; , null , null , get , null , [ 391 , 392 ] , " + ( r default + 50 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 376 , 379 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 376 , 379 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 376 , 379 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "trim [ method ref ] { trim ( ) , ljava . lang . string ; , ( ) ljava . lang . string ; , null , null , trim , null , [ 237 , 239 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "trim [ method ref ] { trim ( ) , ljava . lang . string ; , ( ) ljava . lang . string ; , null , null , trim , null , [ 246 , 248 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "d f [ potential method declaration ] { d f , ld demo refactorings ; , ( ) v , null , null , d f , null , [ 195 , 198 ] , " + ( r default + 9 ) + " } \ n" + dcnl "d fi [ type ref ] { d fi , , ld fi ; , null , null , null , null , [ 195 , 198 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "d f [ potential method declaration ] { d f , ld demo refactorings ; , ( ) v , null , null , d f , null , [ 150 , 153 ] , " + ( r default + 9 ) + " } \ n" + dcnl "d fi [ type ref ] { d fi , , ld fi ; , null , null , null , null , [ 150 , 153 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "d f [ potential method declaration ] { d f , ld demo refactorings ; , ( ) v , null , null , d f , null , [ 36 , 39 ] , " + ( r default + 9 ) + " } \ n" + dcnl "d fi [ type ref ] { d fi , , ld fi ; , null , null , null , null , [ 36 , 39 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "to binary string [ method name reference ] { to binary string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to binary string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to hex string [ method name reference ] { to hex string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to hex string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to octal string [ method name reference ] { to octal string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to octal string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to string [ method name reference ] { to string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to string [ method name reference ] { to string , ljava . lang . integer ; , ( ii ) ljava . lang . string ; , null , null , to string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to unsigned long [ method name reference ] { to unsigned long , ljava . lang . integer ; , ( i ) j , null , null , to unsigned long , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to unsigned string [ method name reference ] { to unsigned string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to unsigned string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to unsigned string [ method name reference ] { to unsigned string , ljava . lang . integer ; , ( ii ) ljava . lang . string ; , null , null , to unsigned string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to string [ method name reference ] { to string , ljava . lang . integer ; , ( ) ljava . lang . string ; , null , null , to string , null , [ 90 , 98 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "char at [ method ref ] { char at ( ) , ljava . lang . string ; , ( i ) c , null , null , char at , ( arg0 ) , [ 232 , 234 ] , " + ( r default + 30 ) + " } \ n" + dcnl "chars [ method ref ] { chars ( ) , ljava . lang . char sequence ; , ( ) ljava . util . stream . int stream ; , null , null , chars , null , [ 232 , 234 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( i ) i , null , null , hash code , ( arg0 ) , [ 164 , 165 ] , " + ( r default + 49 ) + " } \ n" + dcnl "highest one bit [ method ref ] { highest one bit ( ) , ljava . lang . integer ; , ( i ) i , null , null , highest one bit , ( arg0 ) , [ 164 , 165 ] , " + ( r default + 49 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( ) i , null , null , hash code , null , [ 164 , 165 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "print [ method name reference ] { print , ljava . io . print stream ; , ( c ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( d ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( f ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( i ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( j ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( z ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( [ c ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( c ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( d ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( f ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( i ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( j ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( z ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( [ c ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 188 , 191 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . util . locale ; ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 188 , 191 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 235 , 238 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 235 , 238 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 235 , 238 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 271 , 272 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get [ method ref ] { get ( ) , ljava . util . optional < ljava . lang . double ; > ; , ( ) ljava . lang . double ; , null , null , get , null , [ 271 , 272 ] , " + ( r default + 50 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 256 , 259 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 256 , 259 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 256 , 259 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "fi2 [ type ref ] { p4a . fi2 , p4a , lp4a . fi2 ; , null , null , null , null , [ 104 , 107 ] , " + ( r default + 23 ) + " } " , requestor . get results ( ) ) ;
assert results ( "super [ keyword ] { super , null , null , null , null , super , null , [ 192 , 194 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( "localmethod1 [ method ref ] { localmethod1 ( ) , l lambda bug ; , ( ) v , null , null , localmethod1 , null , [ 181 , 190 ] , " + ( r default + 12 ) + " } \ n" + dcnl "localmethod2 [ method ref ] { localmethod2 ( ) , l lambda bug ; , ( ) v , null , null , localmethod2 , null , [ 181 , 190 ] , " + ( r default + 12 ) + " } " , requestor . get results ( ) ) ;
assert results ( "localmethod1 [ method ref ] { localmethod1 ( ) , l lambda bug ; , ( ) v , null , null , localmethod1 , null , [ 282 , 291 ] , " + ( r default + 12 ) + " } \ n" + dcnl "localmethod2 [ method ref ] { localmethod2 ( ) , l lambda bug ; , ( ) v , null , null , localmethod2 , null , [ 282 , 291 ] , " + ( r default + 12 ) + " } " , requestor . get results ( ) ) ;
" retention [ type ref ] { java . lang . annotation . retention , java . lang . annotation , ljava . lang . annotation . retention ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " retention policy [ type ref ] { java . lang . annotation . retention policy , java . lang . annotation , ljava . lang . annotation . retention policy ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "return [ keyword ] { return , null , null , return , null , " + ( r default + 19 ) + " } " ,
" retention [ type ref ] { java . lang . annotation . retention , java . lang . annotation , ljava . lang . annotation . retention ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " retention policy [ type ref ] { java . lang . annotation . retention policy , java . lang . annotation , ljava . lang . annotation . retention policy ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "return [ keyword ] { return , null , null , return , null , " + ( r default + 19 ) + " } " ,
"catch [ keyword ] { catch , null , null , catch , null , " + ( r default + 19 ) + " } \ n" + dcnl "finally [ keyword ] { finally , null , null , finally , null , " + ( r default + 19 ) + " } " ,
"while [ keyword ] { while , null , null , while , null , " + ( r default + 19 ) + " } " ,
"some method [ method ref ] { some method ( ) , lx ; , ( ) v , some method , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" resource bundle [ type ref ] { java . util . resource bundle , java . util , ljava . util . resource bundle ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " response cache [ type ref ] { java . net . response cache , java . net , ljava . net . response cache ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set [ type ref ] { java . sql . result set , java . sql , ljava . sql . result set ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set meta data [ type ref ] { java . sql . result set meta data , java . sql , ljava . sql . result set meta data ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "result [ local variable ref ] { result , null , ljava . lang . string ; , result , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" resource bundle [ type ref ] { java . util . resource bundle , java . util , ljava . util . resource bundle ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " response cache [ type ref ] { java . net . response cache , java . net , ljava . net . response cache ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set [ type ref ] { java . sql . result set , java . sql , ljava . sql . result set ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set meta data [ type ref ] { java . sql . result set meta data , java . sql , ljava . sql . result set meta data ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "result [ local variable ref ] { result , null , ljava . lang . string ; , result , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" resource bundle [ type ref ] { java . util . resource bundle , java . util , ljava . util . resource bundle ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " response cache [ type ref ] { java . net . response cache , java . net , ljava . net . response cache ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set [ type ref ] { java . sql . result set , java . sql , ljava . sql . result set ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set meta data [ type ref ] { java . sql . result set meta data , java . sql , ljava . sql . result set meta data ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "result [ local variable ref ] { result , null , ljava . lang . string ; , result , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" enum [ type ref ] { enum , java . lang , ljava . lang . enum ; , null , null , " + ( r default + 12 ) + " } " ,
" enum [ type ref ] { org . apache . commons . lang . enum . enum , org . apache . commons . lang . enum , lorg . apache . commons . lang . enum . enum ; , null , null , " + ( r default + 9 ) + " } " ,
"org . apache . commons . lang . enum [ package ref ] { org . apache . commons . lang . enum . * ; , org . apache . commons . lang . enum , null , null , null , " + ( r default + 19 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" nested [ type ref ] { nested , myannotations , lmyannotations . nested ; , null , null , " + ( r default + 42 ) + " } " ,
* copyright ( c ) 2000 , 2016 ibm corporation and others .
" this class is final [ type ref ] { this class is final , test , ltest . this class is final ; , null , null , " + ( r default + r resolved + r interesting + r case + r expected type + r unqualified + r non restricted ) + " } \ n" + dcnl " this class is not final [ type ref ] { this class is not final , test , ltest . this class is not final ; , null , null , " + ( r default + r resolved + r interesting + r case + r expected type + r unqualified + r non restricted ) + " } " ,
" inn . inn2 [ type ref ] { label . inn . inn2 , label , llabel . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl " in [ type ref ] { in , label , llabel . in ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " inn [ type ref ] { inn , label , llabel . inn ; , null , null , " + ( r default + 42 ) + " } " ,
" inn . inn2 [ type ref ] { inn2 , label , llabel . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl " inn . inn3 [ type ref ] { inn3 , label , llabel . inn$ inn3 ; , null , null , " + ( r default + 39 ) + " } " ,
"name [ annotation attribute ref ] { name , ltestxxx . ya annot ; , ljava . lang . string ; , name , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "val [ annotation attribute ref ] { val , ltestxxx . ya annot ; , i , val , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
"xxyy [ field ref ] { xxyy , ltestxxx . test type2 ; , i , xxyy , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "xxyy1 [ field ref ] { xxyy1 , ltestxxx . test type2 ; , ljava . lang . string ; , xxyy1 , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted + r exact expected type ) + " } " ,
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , [ 105 , 108 ] , " + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , [ 105 , 108 ] , " + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
* copyright ( c ) 2000 , 2016 ibm corporation and others .
" int items ; \ n" + dcnl " int other items ; \ n" + dcnl " long items count ; \ n" +
" this . item \ n" +
string complete behind = "this . item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r non static + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + + r case + r non static + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r non static + r non restricted ) + " } " ,
" int items ; \ n" + dcnl " int other items ; \ n" + dcnl " long items count ; \ n" +
" item \ n" +
string complete behind = "item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" +
" test . item \ n" +
string complete behind = " test . item" ;
"items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + r case + r non restricted + r non inherited ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r non restricted + r non inherited ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" +
" item \ n" +
string complete behind = "item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" +
" int temporary item = 0 ; \ n" + dcnl " item \ n" +
string complete behind = "item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "temporary item [ local variable ref ] { temporary item , null , i , temporary item , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r case + r interesting + r unqualified + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" + dcnl " void foo ( int init items ) { \ n" + dcnl " item \ n" +
string complete behind = "item" ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
return build model test suite ( substring completion tests . class , bytecode declaration order ) ;
completion project = set up java project ( " completion" , "1 . 8" , true ) ;
set up project compliance ( completion project , "1 . 8" , true ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
int r default = 30 ;
* @ deprecated clients should use the { @ link #jls9 } ast api instead .
* @ deprecated clients should use the { @ link #jls9 } ast api instead .
* @ deprecated clients should use the { @ link #jls9 } ast api instead .
* @ deprecated clients should use the { @ link #jls9 } ast api instead .
/ * * dcnl * internal synonym for { @ link #jls8 } . use to alleviate dcnl * deprecation warnings . dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl / * package * / static final int jls8 internal = jls8 ; dcnl
* clients should use this method specifying { @ link #jls9 } as the
* @ deprecated clients should port their code to use the latest jls * ast api and call dcnl * { @ link #new ast ( int ) ast . new ast ( ast . jls9 ) } instead of using this constructor .
case jls8 internal :
* @ deprecated clients should port their code to use the latest jls * ast api and call dcnl * { @ link #new ast ( int ) ast . new ast ( ast . jls9 ) } instead of using this constructor .
if ( this . api level < jls8 internal ) {
if ( this . ast . api level ( ) > = ast . jls8 internal ) {
if ( this . ast . api level ( ) < ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
| | ( is interface & & ( this . ast . api level < ast . jls8 internal | |
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level ( ) > = ast . jls8 internal ) {
if ( this . ast . api level ( ) > = ast . jls8 internal ) {
if ( this . ast . api level ( ) < ast . jls8 internal ) {
if ( this . ast . api level < ast . jls8 internal ) {
if ( this . ast . api level < ast . jls8 internal ) {
case ast . jls8 internal :
if ( this . ast . api level ( ) < ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( create name qualified type & & this . ast . api level > = ast . jls8 internal ) {
if ( type . is array type ( ) & & ( this . ast . api level ( ) < ast . jls8 internal ) ) {
if ( level < ast . jls8 internal ) {
& & ( level > = ast . jls8 internal
& & ( level > = ast . jls8 internal
return ( level > = ast . jls8 internal ? safe subtree list match ( node . annotations ( ) , o . annotations ( ) ) : true )
& & ( level > = ast . jls8 internal ? safe subtree list match ( node . annotations ( ) , o . annotations ( ) ) : true )
return ( level > = ast . jls8 internal ? safe subtree list match ( node . annotations ( ) , o . annotations ( ) ) : true )
& & ( level > = ast . jls8 internal & & node . is varargs ( )
& & ( ( level > = ast . jls8 internal )
return ( level > = ast . jls8 internal ? safe subtree list match ( node . modifiers ( ) , o . modifiers ( ) ) : true )
& & ( level > = ast . jls8 internal
if ( this . ast . api level < ast . jls8 internal ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
if ( ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level < ast . jls8 internal ) {
if ( this . ast . api level < ast . jls8 internal ) {
if ( this . ast . api level ( ) < ast . jls8 internal ) {
if ( this . ast . api level ( ) > = ast . jls8 internal ) {
} else if ( api level < ast . jls8 internal ) {
if ( ast . api level < ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level ( ) > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level ( ) > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
} else if ( api level < ast . jls8 internal ) {
if ( ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal & & is varargs ( ) ) {
if ( ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
if ( this . ast . api level > = ast . jls8 internal ) {
/ * * @ deprecated using deprecated code * / dcnl private static final int jls8 internal = ast . jls8 ; dcnl
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ * * dcnl * internal synonym for { @ link ast#jls8 } . use to alleviate dcnl * deprecation warnings . dcnl * @ deprecated dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl private static final int jls8 = ast . jls8 ; dcnl
if ( node . get ast ( ) . api level ( ) > = jls8 ) {
if ( node . get ast ( ) . api level ( ) < jls8 ) {
if ( node . get ast ( ) . api level ( ) > = jls8 ) {
if ( node . get ast ( ) . api level ( ) > = jls8 ) {
if ( node . get ast ( ) . api level ( ) < jls8 ) {
if ( node . get ast ( ) . api level ( ) > = jls8 ) {
if ( node . get ast ( ) . api level ( ) > = jls8 ) {
if ( node . get ast ( ) . api level ( ) > = jls8 ) {
/ * * @ deprecated using deprecated code * / dcnl private static final child list property descriptor internal try statement resources property = try statement . resources property ; dcnl
/ * * @ deprecated using deprecated code * / dcnl private static final int jls8 internal = ast . jls8 ; dcnl dcnl private static final int jls9 internal = ast . jls9 ; dcnl
if ( method . get ast ( ) . api level ( ) < jls8 internal ) {
child list property descriptor exceptions property = api level < jls8 internal ? internal method thrown exceptions property : method declaration . thrown exception types property ;
if ( api level < jls8 internal ) {
boolean ast level gte8 = node . get ast ( ) . api level ( ) > = jls8 internal ;
if ( parent . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( parent . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( node . get ast ( ) . api level ( ) < jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( api level > = jls8 internal ) {
int no of annotations = api level > = jls8 internal ? node . varargs annotations ( ) . size ( ) : 0 ;
if ( api level > = jls8 internal & & node . is varargs ( ) ) {
if ( api level < jls8 internal ) {
structural property descriptor desc = level < jls9 internal ? internal try statement resources property : try statement . resources2 property ;
if ( node . get ast ( ) . api level ( ) < jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
/ * * @ deprecated using deprecated code * / dcnl private static final child list property descriptor internal try statement resources property = try statement . resources property ; dcnl
/ * * @ deprecated using deprecated code * / dcnl private static final int jls8 internal = ast . jls8 ; dcnl dcnl private static final int jls9 internal = ast . jls9 ; dcnl
if ( node . get ast ( ) . api level ( ) < jls8 internal ) {
boolean ast level gte8 = node . get ast ( ) . api level ( ) > = jls8 internal ;
if ( node . get ast ( ) . api level ( ) < jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
child list property descriptor exceptions property = node . get ast ( ) . api level ( ) < jls8 internal ?
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal & & node . is varargs ( ) ) {
structural property descriptor desc = level < jls9 internal ? internal try statement resources property : try statement . resources2 property ;
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
if ( node . get ast ( ) . api level ( ) > = jls8 internal ) {
* copyright ( c ) 2005 , 2016 ibm corporation and others .
return get ast ( ast . jls3 ) ;
return get ast ( ast . jls4 ) ;
* @ deprecated jls8 has been deprecated . this method has been replaced by { @ link #get ast ( int ) } which returns an ast dcnl * with the given level .
return get ast ( ast . jls8 ) ; dcnl } dcnl dcnl / * * dcnl * returns a resolved ast with the given ast level . dcnl * it is created from the current state of the working copy . dcnl * creates one if none exists yet . dcnl * returns < code > null < / code > if the current state of the working copy dcnl * doesn't allow the ast to be created ( e . g . if the working copy's content dcnl * cannot be parsed ) . dcnl * < p > dcnl * if the ast level requested during reconciling is not the latest available ast level dcnl * or if binding resolutions was not requested , then a different ast is created . dcnl * note that this ast does not become the current ast and it is only valid for dcnl * the requestor . dcnl * < / p > dcnl * dcnl * @ param level the api level ; one of the < code > . jls * < / code > level constants dcnl * declared on { @ link ast } dcnl * @ return the ast created from the current state of the working copy , dcnl * or < code > null < / code > if none could be created dcnl * @ exception java model exception if the contents of the working copy dcnl * cannot be accessed . reasons include : dcnl * < ul > dcnl * < li > the working copy does not exist ( element does not exist ) < / li > dcnl * < / ul > dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public org . eclipse . jdt . core . dom . compilation unit get ast ( int level ) throws java model exception { dcnl if ( this . operation . ast level ! = level | | !this . operation . resolve bindings ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
ast parser parser = ast parser . new parser ( ast . jls9 ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* < p > a resource is either a { @ link variable declaration expression } or ( since jls9 ) a { @ link name } . < / p > dcnl *
case ast . jls8 internal :
* the resource expressions ( element type : { @ link expression } ) . dcnl * null in jls2 and jls3 . added in jls4 . dcnl * in the deprecated jls4 and jls8 ap is , this used to be dcnl * ( element type : { @ link variable declaration expression } ) . dcnl * defaults to an empty list ( see constructor ) .
* dcnl * < p > a resource is either a { @ link variable declaration expression } or ( since jls9 ) a { @ link name } . < / p >
* copyright ( c ) 2000 , 2016 ibm corporation and others .
ast parser parser = ast parser . new parser ( ast . jls9 ) ;
expected problem attributes . put ( " interface static method invocation not below18" , new problem attributes ( categorized problem . cat syntax ) ) ; dcnl expected problem attributes . put ( " interface super invocation not below18" , new problem attributes ( categorized problem . cat syntax ) ) ;
* copyright ( c ) 2011 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . compiler . classfmt . class file constants ; dcnl import org . eclipse . jdt . internal . compiler . impl . compiler options ; dcnl import org . eclipse . jdt . internal . compiler . lookup . block scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . class scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reasons ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type binding ;
int find compatible enclosing ( reference binding enclosing type , type binding type , block scope scope ) {
compiler options compiler options = scope . compiler options ( ) ;
boolean is java8 = compiler options . compliance level > = class file constants . jdk1 8 ;
if ( !is legal | | !is java8 ) {
closest match , is java8 ? problem reasons . attempt to bypass direct super : problem reasons . interface method invocation not below18 ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
int depth = find compatible enclosing ( scope . reference type ( ) . binding , type , scope ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . compiler . ast . qualified super reference ;
public void interface super invocation not below18 ( qualified super reference qualified super reference ) { dcnl this . handle ( dcnl i problem . interface super invocation not below18 , dcnl no argument , dcnl no argument , dcnl qualified super reference . source start , dcnl qualified super reference . source end ) ; dcnl }
case problem reasons . interface method invocation not below18 : dcnl this . handle ( dcnl i problem . interface static method invocation not below18 , dcnl new string [ ] { dcnl new string ( method . declaring class . readable name ( ) ) , dcnl new string ( method . selector ) , dcnl } , dcnl new string [ ] { dcnl new string ( method . declaring class . short readable name ( ) ) , dcnl new string ( method . selector ) , dcnl } , dcnl ( int ) ( message send . name source position > > > 32 ) , dcnl ( int ) message send . name source position ) ; dcnl return ;
if ( actual type . is array type ( ) & & ( ( array binding ) actual type ) . leaf component type . erasure ( ) . id = = type ids . t java lang class ) { dcnl dcnl object [ ] bindings ; dcnl if ( actual value instanceof object [ ] ) { dcnl bindings = ( object [ ] ) actual value ; dcnl } else if ( actual value instanceof type binding ) { dcnl / / when a single class element is passed to array : @ annotation type ( something . class ) dcnl bindings = new object [ ] { actual value } ; dcnl } else { dcnl bindings = null ; dcnl } dcnl dcnl if ( bindings ! = null ) { dcnl list < type mirror > mirrors = new array list < > ( bindings . length ) ; dcnl for ( int i = 0 ; i < bindings . length ; + + i ) { dcnl if ( bindings [ i ] instanceof type binding ) { dcnl mirrors . add ( env . get factory ( ) . new type mirror ( ( type binding ) bindings [ i ] ) ) ; dcnl }
reference binding [ ] types per token ;
if ( this . resolved type = = null | | !this . resolved type . is valid binding ( ) ) return ;
if ( index > 0 ) { dcnl reference binding enclosing type = this . types per token [ index - 1 ] ; dcnl if ( enclosing type ! = null ) dcnl check bounds ( enclosing type , scope , index - 1 ) ;
int max = this . tokens . length ; dcnl this . types per token = new reference binding [ max ] ; dcnl for ( int i = package binding = = null ? 0 : package binding . compound name . length ; i < max ; i + + ) {
bundle - version : 1 . 3 . 0 . qualifier
static final int jls latest = ast . jls9 ;
private static final int jls9 = ast . jls9 ; dcnl dcnl / * * dcnl * @ deprecated to get rid of deprecation warnings in code dcnl * / dcnl @ deprecated
case jls9 :
/ / "i bar [ type ref ] { i bar , test , ltest . i bar ; , null , " + ( r default + 39 ) + " } \ n" + dcnl / / "i foo [ type ref ] { i foo , test , ltest . i foo ; , null , " + ( r default + 39 ) + " } "
"i bar [ type ref ] { i bar , test , ltest . i bar ; , null , " + ( r default + 39 ) + " } " ,
/ / " interface1 [ type ref ] { interface1 , test , ltest . interface1 ; , null , " + ( r default + 39 ) + " } \ n" + dcnl " interface2 [ type ref ] { interface2 , test , ltest . interface2 ; , null , " + ( r default + 39 ) + " } " ,
" enclosing . interface2 [ type ref ] { p . enclosing . interface2 , p , lp . enclosing$ interface2 ; , null , " + ( r default + 39 ) + " } " ,
" enclosing . interface1 [ type ref ] { p . enclosing . interface1 , p , lp . enclosing$ interface1 ; , null , " + ( r default + 39 ) + " } \ n" + dcnl " enclosing . interface2 [ type ref ] { p . enclosing . interface2 , p , lp . enclosing$ interface2 ; , null , " + ( r default + 39 ) + " } " ,
" tr [ potential method declaration ] { tr , ltest . try ; , ( ) v , tr , null , " + ( r default + 9 ) + " } \ n" + dcnl "transient [ keyword ] { transient , null , null , transient , null , " + ( r default + 9 ) + " } \ n" + dcnl " try [ type ref ] { try , test , ltest . try ; , null , null , " + ( r default + 22 ) + " } " ,
" error [ type ref ] { error , java . lang , ljava . lang . error ; , null , null , " + ( r default + 12 ) + " } \ n" + dcnl " exception [ type ref ] { exception , java . lang , ljava . lang . exception ; , null , null , " + ( r default + 12 ) + " } \ n" + dcnl "equals [ method ref ] { try . this . equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 19 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } " ,
"a class [ type ref ] { a class , test , ltest . a class ; , null , null , " + ( r default + 22 ) + " } " ,
"a class [ type ref ] { a class , test , ltest . a class ; , null , null , " + ( r default + 22 ) + " } " ,
" inn . inn2 [ type ref ] { test . inn . inn2 , test , ltest . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl "abc . abc interface [ type ref ] { abc interface , test , ltest . abc$abc interface ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " in [ type ref ] { in , test , ltest . in ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " inn [ type ref ] { inn , test , ltest . inn ; , null , null , " + ( r default + 42 ) + " } " ,
" inn . inn2 [ type ref ] { test . inn . inn2 , test , ltest . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl " inn . inn2 . inn3 [ type ref ] { test . inn . inn2 . inn3 , test , ltest . inn$ inn2$ inn3 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl "abc [ type ref ] { abc , test , ltest . abc ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " in [ type ref ] { in , test , ltest . in ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " inn [ type ref ] { inn , test , ltest . inn ; , null , null , " + ( r default + 42 ) + " } " ,
int relevance1 = r default + 52 ; dcnl int relevance2 = r default + 22 ; dcnl int relevance3 = r default + 17 ;
"my var1 [ local variable ref ] { my var1 , null , i , my var1 , null , " + ( r default + 52 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ field ref ] { my string , ltest . x ; , ljava . lang . string ; , my string , null , " + ( r default + 22 ) + " } \ n" + dcnl "my string2 [ field ref ] { my string2 , ltest . x ; , ljava . lang . string ; , my string2 , null , " + ( r default + 22 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ field ref ] { my string , ltest . x ; , ljava . lang . string ; , my string , null , " + ( r default + 52 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ local variable ref ] { my string , null , ljava . lang . string ; , my string , null , " + ( r default + 52 ) + " } \ n" + dcnl "my string2 [ local variable ref ] { my string2 , null , ljava . lang . string ; , my string2 , null , " + ( r default + 52 ) + " } " ,
" my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 19 ) + " } \ n" + dcnl "my string [ local variable ref ] { my string , null , ljava . lang . string ; , my string , null , " + ( r default + 52 ) + " } \ n" + dcnl "my string1 [ local variable ref ] { my string1 , null , ljava . lang . string ; , my string1 , null , " + ( r default + 52 ) + " } " ,
int relevance = r default + 21 ;
"def [ potential method declaration ] { def , ltest . p ; , ( ) v , def , null , " + ( r default + 9 ) + " } \ n" + "default [ keyword ] { default , null , null , default , null , " + ( r default + 19 ) + " } " ,
"def [ potential method declaration ] { def , ltest . p ; , ( ) v , def , null , " + ( r default + 9 ) + " } " ,
"def [ potential method declaration ] { def , ltest . zz$i ; , ( ) v , def , null , " + ( r default + 9 ) + " } \ n" + "default [ keyword ] { default , null , null , default , null , " + ( r default + 19 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < tt ; > ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . test < ljava . lang . object ; > . txyu ; , ( tt ; ) v , txyu , ( t ) , " + ( r default + 25 ) + " } \ n" + dcnl " test . txyu [ type ref ] { txyu , test , ltest . test$txyu ; , null , null , " + ( r default + 25 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( l number ; ) v , txyu , ( t ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } " ,
"txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( l number ; ) v , txyu , ( t ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } \ n" + dcnl "txyu [ constructor invocation ] { ( ) , ltest . txyu < l number ; > ; , ( ljava . lang . string ; ljava . lang . string ; ) v , txyu , ( s , s2 ) , " + ( r default + 55 ) + " } \ n" + dcnl " txyu [ type ref ] { txyu , test , ltest . txyu ; , null , null , " + ( r default + 55 ) + " } " ,
"mypackage [ package ref ] { mypackage , mypackage , null , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " my class [ type ref ] { mypackage . my class , mypackage , lmypackage . my class ; , null , null , " + ( r default + 19 ) + " } \ n" + dcnl " my class [ type ref ] { my class , test , ltest . my class ; , null , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class field [ field ref ] { my class field , ltest . try ; , ltest . my class ; , my class field , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class method [ method ref ] { my class method ( ) , ltest . try ; , ( ) ltest . my class ; , my class method , null , " + ( r default + 52 ) + " } " ,
"finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , notify , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , notify all , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , wait , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , wait , ( millis ) , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , wait , ( millis , nanos ) , " + ( r default + 17 ) + " } \ n" + dcnl " try [ type ref ] { try , test , ltest . try ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class ; , get class , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } \ n" + dcnl " my class [ type ref ] { my class , test , ltest . my class ; , null , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class field [ field ref ] { my class field , ltest . try ; , ltest . my class ; , my class field , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class method [ method ref ] { my class method ( ) , ltest . try ; , ( ) ltest . my class ; , my class method , null , " + ( r default + 52 ) + " } " ,
"finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , notify , null , " + ( r default + 17 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , notify all , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , wait , null , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , wait , ( millis ) , " + ( r default + 17 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , wait , ( millis , nanos ) , " + ( r default + 17 ) + " } \ n" + dcnl " try [ type ref ] { try , test , ltest . try ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class ; , get class , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } \ n" + dcnl " my class [ type ref ] { my class , test , ltest . my class ; , null , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class field [ field ref ] { my class field , ltest . try ; , ltest . my class ; , my class field , null , " + ( r default + 52 ) + " } \ n" + dcnl " my class method [ method ref ] { my class method ( ) , ltest . try ; , ( ) ltest . my class ; , my class method , null , " + ( r default + 52 ) + " } " ,
"it may be due to mixing perhaps [ field ref ] { it may be due to mixing perhaps , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , it may be due to mixing perhaps , null , " + ( r default + 21 ) + " } \ n" + dcnl "more stuff [ field ref ] { more stuff , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , more stuff , null , " + ( r default + 21 ) + " } \ n" + dcnl "other [ field ref ] { other , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , other , null , " + ( r default + 21 ) + " } \ n" + dcnl "still other [ field ref ] { still other , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , still other , null , " + ( r default + 21 ) + " } \ n" + dcnl "stuff [ field ref ] { stuff , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , stuff , null , " + ( r default + 21 ) + " } \ n" + dcnl "things [ field ref ] { things , ltest . example enum no autocomplete ; , ltest . example enum no autocomplete ; , things , null , " + ( r default + 21 ) + " } \ n" + dcnl "class [ field ref ] { class , null , ljava . lang . class < ltest . example enum no autocomplete ; > ; , class , null , " + ( r default + 21 ) + " } \ n" + dcnl "value of [ method ref ] { value of ( ) , ltest . example enum no autocomplete ; , ( ljava . lang . string ; ) ltest . example enum no autocomplete ; , value of , ( arg0 ) , " + ( r default + 21 ) + " } \ n" + dcnl "values [ method ref ] { values ( ) , ltest . example enum no autocomplete ; , ( ) [ ltest . example enum no autocomplete ; , values , null , " + ( r default + 21 ) + " } " ,
"static method [ method ref ] { static method ( ) , ltest . test ; , ( ) v , static method , null , " + ( r default + 22 ) + " } " ,
"static method [ method ref ] { static method ( ) , ltest . i ; , ( ) v , static method , null , " + ( r default + 21 ) + " } " ,
"default method [ method ref ] { default method ( ) , ltest . i ; , ( ) v , default method , null , " + ( r default + 30 ) + " } " ,
"default method [ method ref ] { default method ( ) , ltest . i ; , ( ) v , default method , null , " + ( r default + 22 ) + " } " ,
"to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 60 ) + " } " ,
"i [ type ref ] { i , test , ltest . i ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x [ type ref ] { x , test , ltest . x ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "args [ local variable ref ] { args , null , [ ljava . lang . string ; , args , null , " + ( r default + 22 ) + " } \ n" + dcnl "i [ local variable ref ] { i , null , ltest . i ; , i , null , " + ( r default + 22 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , ltest . x ; , ( [ ljava . lang . string ; ) v , main , ( args ) , " + ( r default + 22 ) + " } \ n" + dcnl "x [ local variable ref ] { x , null , [ [ [ ltest . x ; , x , null , " + ( r default + 22 ) + " } " ,
"i [ type ref ] { i , test , ltest . i ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "s [ type ref ] { s , null , ts ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x < s > [ type ref ] { x , test , ltest . x < ts ; > ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "args [ local variable ref ] { args , null , [ ljava . lang . string ; , args , null , " + ( r default + 22 ) + " } \ n" + dcnl "i [ local variable ref ] { i , null , ltest . i ; , i , null , " + ( r default + 22 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , ltest . x < ts ; > ; , ( [ ljava . lang . string ; ) v , main , ( args ) , " + ( r default + 22 ) + " } \ n" + dcnl "x [ local variable ref ] { x , null , ltest . x ; , x , null , " + ( r default + 22 ) + " } " ,
"pqrqwerty [ local variable ref ] { pqrqwerty , null , i , pqrqwerty , null , " + ( r default + 22 ) + " } " ,
"first [ local variable ref ] { first , null , i , first , null , " + ( r default + 22 ) + " } " ,
"first [ local variable ref ] { first , null , i , first , null , " + ( r default + 22 ) + " } " ,
"case insensitive order [ field ref ] { case insensitive order , ljava . lang . string ; , ljava . util . comparator < ljava . lang . string ; > ; , case insensitive order , null , " + ( r default + 9 ) + " } \ n" + dcnl "copy value of [ method ref ] { copy value of ( ) , ljava . lang . string ; , ( [ c ) ljava . lang . string ; , copy value of , ( arg0 ) , " + ( r default + 19 ) + " } \ n" + dcnl "copy value of [ method ref ] { copy value of ( ) , ljava . lang . string ; , ( [ cii ) ljava . lang . string ; , copy value of , ( arg0 , arg1 , arg2 ) , " + ( r default + 19 ) + " } \ n" + dcnl "char at [ method ref ] { char at ( ) , ljava . lang . string ; , ( i ) c , char at , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "chars [ method ref ] { chars ( ) , ljava . lang . char sequence ; , ( ) ljava . util . stream . int stream ; , chars , null , " + ( r default + 30 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 30 ) + " } \ n" + dcnl "code point at [ method ref ] { code point at ( ) , ljava . lang . string ; , ( i ) i , code point at , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "code point before [ method ref ] { code point before ( ) , ljava . lang . string ; , ( i ) i , code point before , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "code point count [ method ref ] { code point count ( ) , ljava . lang . string ; , ( ii ) i , code point count , ( arg0 , arg1 ) , " + ( r default + 30 ) + " } \ n" + dcnl "code points [ method ref ] { code points ( ) , ljava . lang . char sequence ; , ( ) ljava . util . stream . int stream ; , code points , null , " + ( r default + 30 ) + " } \ n" + dcnl "compare to [ method ref ] { compare to ( ) , ljava . lang . string ; , ( ljava . lang . string ; ) i , compare to , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "compare to ignore case [ method ref ] { compare to ignore case ( ) , ljava . lang . string ; , ( ljava . lang . string ; ) i , compare to ignore case , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "concat [ method ref ] { concat ( ) , ljava . lang . string ; , ( ljava . lang . string ; ) ljava . lang . string ; , concat , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "contains [ method ref ] { contains ( ) , ljava . lang . string ; , ( ljava . lang . char sequence ; ) z , contains , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "content equals [ method ref ] { content equals ( ) , ljava . lang . string ; , ( ljava . lang . char sequence ; ) z , content equals , ( arg0 ) , " + ( r default + 30 ) + " } \ n" + dcnl "content equals [ method ref ] { content equals ( ) , ljava . lang . string ; , ( ljava . lang . string buffer ; ) z , content equals , ( arg0 ) , " + ( r default + 30 ) + " } " ,
"lpx5 [ local variable ref ] { lpx5 , null , i , lpx5 , null , " + ( r default + 22 ) + " } \ n" + dcnl "lpx6 [ local variable ref ] { lpx6 , null , i , lpx6 , null , " + ( r default + 22 ) + " } " ,
"argument [ local variable ref ] { argument , null , i , argument , null , " + ( r default + 52 ) + " } " ,
"argument [ local variable ref ] { argument , null , i , argument , null , " + ( r default + 22 ) + " } " ,
"class [ field ref ] { class , null , ljava . lang . class < lx ; > ; , class , null , " + ( r default + 21 ) + " } \ n" + dcnl "f [ field ref ] { f , lx ; , l foo ; , f , null , " + ( r default + 21 ) + " } \ n" + dcnl "this [ keyword ] { this , null , null , this , null , " + ( r default + 21 ) + " } \ n" + dcnl "x1 [ field ref ] { x1 , lx ; , i , x1 , null , " + ( r default + 51 ) + " } " ,
" [ potential method declaration ] { , lx ; , ( ) v , , null , " + ( r default + 9 ) + " } \ n" + dcnl "abstract [ keyword ] { abstract , null , null , abstract , null , " + ( r default + 19 ) + " } \ n" + dcnl "class [ keyword ] { class , null , null , class , null , " + ( r default + 19 ) + " } \ n" + dcnl "enum [ keyword ] { enum , null , null , enum , null , " + ( r default + 19 ) + " } \ n" + dcnl "final [ keyword ] { final , null , null , final , null , " + ( r default + 19 ) + " } \ n" + dcnl "interface [ keyword ] { interface , null , null , interface , null , " + ( r default + 19 ) + " } \ n" + dcnl "native [ keyword ] { native , null , null , native , null , " + ( r default + 19 ) + " } \ n" + dcnl "private [ keyword ] { private , null , null , private , null , " + ( r default + 19 ) + " } \ n" + dcnl "protected [ keyword ] { protected , null , null , protected , null , " + ( r default + 19 ) + " } \ n" + dcnl "public [ keyword ] { public , null , null , public , null , " + ( r default + 19 ) + " } \ n" + dcnl "static [ keyword ] { static , null , null , static , null , " + ( r default + 19 ) + " } \ n" + dcnl "strictfp [ keyword ] { strictfp , null , null , strictfp , null , " + ( r default + 19 ) + " } \ n" + dcnl "synchronized [ keyword ] { synchronized , null , null , synchronized , null , " + ( r default + 19 ) + " } \ n" + dcnl "transient [ keyword ] { transient , null , null , transient , null , " + ( r default + 19 ) + " } \ n" + dcnl "volatile [ keyword ] { volatile , null , null , volatile , null , " + ( r default + 19 ) + " } \ n" + dcnl "i [ type ref ] { i , , li ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "j [ type ref ] { j , , lj ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x [ type ref ] { x , , lx ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method declaration ] { protected object clone ( ) throws clone not supported exception , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method declaration ] { public boolean equals ( object obj ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "finalize [ method declaration ] { protected void finalize ( ) throws throwable , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method declaration ] { public int hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method declaration ] { public string to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } " ,
" [ potential method declaration ] { , lx ; , ( ) v , , null , " + ( r default + 9 ) + " } \ n" + dcnl "abstract [ keyword ] { abstract , null , null , abstract , null , " + ( r default + 19 ) + " } \ n" + dcnl "class [ keyword ] { class , null , null , class , null , " + ( r default + 19 ) + " } \ n" + dcnl "enum [ keyword ] { enum , null , null , enum , null , " + ( r default + 19 ) + " } \ n" + dcnl "final [ keyword ] { final , null , null , final , null , " + ( r default + 19 ) + " } \ n" + dcnl "interface [ keyword ] { interface , null , null , interface , null , " + ( r default + 19 ) + " } \ n" + dcnl "native [ keyword ] { native , null , null , native , null , " + ( r default + 19 ) + " } \ n" + dcnl "private [ keyword ] { private , null , null , private , null , " + ( r default + 19 ) + " } \ n" + dcnl "protected [ keyword ] { protected , null , null , protected , null , " + ( r default + 19 ) + " } \ n" + dcnl "public [ keyword ] { public , null , null , public , null , " + ( r default + 19 ) + " } \ n" + dcnl "static [ keyword ] { static , null , null , static , null , " + ( r default + 19 ) + " } \ n" + dcnl "strictfp [ keyword ] { strictfp , null , null , strictfp , null , " + ( r default + 19 ) + " } \ n" + dcnl "synchronized [ keyword ] { synchronized , null , null , synchronized , null , " + ( r default + 19 ) + " } \ n" + dcnl "transient [ keyword ] { transient , null , null , transient , null , " + ( r default + 19 ) + " } \ n" + dcnl "volatile [ keyword ] { volatile , null , null , volatile , null , " + ( r default + 19 ) + " } \ n" + dcnl "i [ type ref ] { i , , li ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "j [ type ref ] { j , , lj ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "x [ type ref ] { x , , lx ; , null , null , " + ( r default + 22 ) + " } \ n" + dcnl "clone [ method declaration ] { protected object clone ( ) throws clone not supported exception , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 22 ) + " } \ n" + dcnl "equals [ method declaration ] { public boolean equals ( object obj ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 22 ) + " } \ n" + dcnl "finalize [ method declaration ] { protected void finalize ( ) throws throwable , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 22 ) + " } \ n" + dcnl "hash code [ method declaration ] { public int hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 22 ) + " } \ n" + dcnl "to string [ method declaration ] { public string to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 22 ) + " } " ,
"goo [ method ref ] { goo ( ) , lx ; , ( li ; ) v , goo , ( i ) , " + ( r default + 19 ) + " } \ n" + dcnl "goo [ method ref ] { goo ( ) , lx ; , ( ljava . lang . string ; ) v , goo , ( s ) , " + ( r default + 19 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , lx ; , ( [ ljava . lang . string ; ) v , main , ( args ) , " + ( r default + 19 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , clone , null , " + ( r default + 30 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , equals , ( obj ) , " + ( r default + 30 ) + " } \ n" + dcnl "finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , finalize , null , " + ( r default + 30 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , get class , null , " + ( r default + 30 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , hash code , null , " + ( r default + 30 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , notify , null , " + ( r default + 30 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , notify all , null , " + ( r default + 30 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , to string , null , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , wait , null , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , wait , ( millis ) , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , wait , ( millis , nanos ) , " + ( r default + 30 ) + " } " ,
assert results ( "array of strings [ local variable ref ] { array of strings , null , [ ljava . lang . string ; , null , null , array of strings , null , [ 168 , 174 ] , " + ( r default + 22 ) + " } \ n" + dcnl "array of ints [ local variable ref ] { array of ints , null , [ i , null , null , array of ints , null , [ 168 , 174 ] , " + ( r default + 52 ) + " } " , requestor . get results ( ) ) ;
assert results ( "xyz after [ local variable ref ] { xyz after , null , ljava . lang . object ; , null , null , xyz after , null , [ 132 , 135 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( "xyz before [ local variable ref ] { xyz before , null , ljava . lang . object ; , null , null , xyz before , null , [ 163 , 166 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( " string buffer input stream [ type ref ] { java . io . string buffer input stream , java . io , ljava . io . string buffer input stream ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string char buffer [ type ref ] { java . nio . string char buffer , java . nio , ljava . nio . string char buffer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string character iterator [ type ref ] { java . text . string character iterator , java . text , ljava . text . string character iterator ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string joiner [ type ref ] { java . util . string joiner , java . util , ljava . util . string joiner ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string reader [ type ref ] { java . io . string reader , java . io , ljava . io . string reader ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string tokenizer [ type ref ] { java . util . string tokenizer , java . util , ljava . util . string tokenizer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " string writer [ type ref ] { java . io . string writer , java . io , ljava . io . string writer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 19 ) + " } \ n" + dcnl " strict math [ type ref ] { strict math , java . lang , ljava . lang . strict math ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string [ type ref ] { string , java . lang , ljava . lang . string ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string buffer [ type ref ] { string buffer , java . lang , ljava . lang . string buffer ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string builder [ type ref ] { string builder , java . lang , ljava . lang . string builder ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string coding [ type ref ] { string coding , java . lang , ljava . lang . string coding ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string index out of bounds exception [ type ref ] { string index out of bounds exception , java . lang , ljava . lang . string index out of bounds exception ; , null , null , null , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } \ n" + dcnl " string parameter [ local variable ref ] { string parameter , null , lx ; , null , null , string parameter , null , [ 155 , 159 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( " string parameter [ local variable ref ] { string parameter , null , lx ; , null , null , string parameter , null , [ 155 , 162 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "goo [ method ref ] { goo ( ) , lx ; , ( li ; ) v , null , null , goo , ( i ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , lx ; , ( [ ljava . lang . string ; ) v , null , null , main , ( args ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , null , null , clone , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , null , null , equals , ( obj ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "field [ field ref ] { field , lx ; , i , null , null , field , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , null , null , finalize , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "foo [ method ref ] { foo ( ) , lx ; , ( ) v , null , null , foo , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , null , null , hash code , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , null , null , notify , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , null , null , notify all , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , null , null , to string , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , null , null , wait , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , null , null , wait , ( millis ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , null , null , wait , ( millis , nanos ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "goo [ method ref ] { goo ( ) , lx ; , ( li ; ) v , null , null , goo , ( i ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "main [ method ref ] { main ( ) , lx ; , ( [ ljava . lang . string ; ) v , null , null , main , ( args ) , [ 173 , 173 ] , " + ( r default + 19 ) + " } \ n" + dcnl "clone [ method ref ] { clone ( ) , ljava . lang . object ; , ( ) ljava . lang . object ; , null , null , clone , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "equals [ method ref ] { equals ( ) , ljava . lang . object ; , ( ljava . lang . object ; ) z , null , null , equals , ( obj ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "field [ field ref ] { field , lx ; , i , null , null , field , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "finalize [ method ref ] { finalize ( ) , ljava . lang . object ; , ( ) v , null , null , finalize , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "foo [ method ref ] { foo ( ) , lx ; , ( ) v , null , null , foo , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . object ; , ( ) i , null , null , hash code , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify [ method ref ] { notify ( ) , ljava . lang . object ; , ( ) v , null , null , notify , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "notify all [ method ref ] { notify all ( ) , ljava . lang . object ; , ( ) v , null , null , notify all , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "to string [ method ref ] { to string ( ) , ljava . lang . object ; , ( ) ljava . lang . string ; , null , null , to string , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ) v , null , null , wait , null , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( j ) v , null , null , wait , ( millis ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } \ n" + dcnl "wait [ method ref ] { wait ( ) , ljava . lang . object ; , ( ji ) v , null , null , wait , ( millis , nanos ) , [ 173 , 173 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
"bars [ method ref ] { bars ( ) , lb ; , ( ) i , bars , null , " + ( r default + 22 ) + " } " ,
"another [ field ref ] { another , lb ; , i , another , null , " + ( r default + 22 ) + " } " ,
"tryit [ local variable ref ] { tryit , null , i , null , null , tryit , null , [ 99 , 102 ] , " + ( r default + 22 ) + " } \ n" + dcnl "try [ keyword ] { try , null , null , null , null , try , null , [ 99 , 102 ] , " + ( r default + 23 ) + " } " ,
assert results ( " type use [ type ref ] { type use , , l type use ; , null , null , null , null , [ 131 , 133 ] , " + ( r default + 47 ) + " } " , requestor . get results ( ) ) ;
assert results ( " annotation [ type ref ] { annotation , , l annotation ; , null , null , null , null , [ 138 , 141 ] , " + ( r default + 42 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 186 , 189 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 186 , 189 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 267 , 270 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 267 , 270 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 293 , 296 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 293 , 296 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 285 , 288 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 285 , 288 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 272 , 275 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 272 , 275 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 203 , 206 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method ref ] { get last name ( ) , l person ; , ( ) ljava . lang . string ; , null , null , get last name , null , [ 203 , 206 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "long method name [ method name reference ] { long method name , lx ; , ( ljava . lang . string ; ) ljava . lang . string ; , null , null , long method name , ( x ) , [ 183 , 187 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
"long method name [ method name reference ] { long method name , ltest . x ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"long method name [ method name reference ] { long method name , ltest . x < ljava . lang . string ; > ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"long method name [ method name reference ] { long method name , ltest . y ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"long method name [ method name reference ] { long method name , ltest . y ; , ( ljava . lang . string ; ) ljava . lang . string ; , long method name , ( x ) , " + ( r default + 30 ) + " } " ,
"as list [ local variable ref ] { as list , null , ljava . lang . object ; , as list , null , " + ( r default + 42 ) + " } " ,
"remove node from graph [ method ref ] { remove node from graph ( ) , ltest . x ; , ( ltest . x$ node ; ) v , remove node from graph , ( node ) , " + ( r default + 22 ) + " } " ,
"get class [ method name reference ] { get class , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , get class , null , " + ( r default + 30 ) + " } \ n" + dcnl "get last name [ method name reference ] { get last name , ltest . person ; , ( ) ljava . lang . string ; , get last name , null , " + ( r default + 30 ) + " } " ,
assert results ( "out [ field ref ] { out , ljava . lang . system ; , ljava . io . print stream ; , null , null , out , null , [ 83 , 84 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( c ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( d ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( f ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( i ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( j ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( z ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "print [ method ref ] { print ( ) , ljava . io . print stream ; , ( [ c ) v , null , null , print , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method ref ] { printf ( ) , ljava . io . print stream ; , ( ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , ( arg0 , arg1 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method ref ] { printf ( ) , ljava . io . print stream ; , ( ljava . util . locale ; ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , ( arg0 , arg1 , arg2 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( ) v , null , null , println , null , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( c ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( d ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( f ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( i ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( j ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( z ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } \ n" + dcnl "println [ method ref ] { println ( ) , ljava . io . print stream ; , ( [ c ) v , null , null , println , ( arg0 ) , [ 87 , 88 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "start [ method ref ] { start ( ) , ljava . lang . thread ; , ( ) v , null , null , start , null , [ 103 , 105 ] , " + ( r default + 30 ) + " } \ n" + dcnl "stop [ method ref ] { stop ( ) , ljava . lang . thread ; , ( ) v , null , null , stop , null , [ 103 , 105 ] , " + ( r default + 30 ) + " } \ n" + dcnl "stop [ method ref ] { stop ( ) , ljava . lang . thread ; , ( ljava . lang . throwable ; ) v , null , null , stop , ( arg0 ) , [ 103 , 105 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( i ) i , null , null , hash code , ( arg0 ) , [ 187 , 188 ] , " + ( r default + 49 ) + " } \ n" + dcnl "highest one bit [ method ref ] { highest one bit ( ) , ljava . lang . integer ; , ( i ) i , null , null , highest one bit , ( arg0 ) , [ 187 , 188 ] , " + ( r default + 49 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( ) i , null , null , hash code , null , [ 187 , 188 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "print [ method name reference ] { print , ljava . io . print stream ; , ( c ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( d ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( f ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( i ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( j ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( z ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( [ c ) v , null , null , print , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( c ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( d ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( f ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( i ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( j ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( z ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( [ c ) v , null , null , println , null , [ 219 , 222 ] , " + ( r default + 25 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 219 , 222 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . util . locale ; ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 219 , 222 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 355 , 358 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 355 , 358 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 355 , 358 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 391 , 392 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get [ method ref ] { get ( ) , ljava . util . optional < ljava . lang . double ; > ; , ( ) ljava . lang . double ; , null , null , get , null , [ 391 , 392 ] , " + ( r default + 50 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 376 , 379 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 376 , 379 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 376 , 379 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "trim [ method ref ] { trim ( ) , ljava . lang . string ; , ( ) ljava . lang . string ; , null , null , trim , null , [ 237 , 239 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "trim [ method ref ] { trim ( ) , ljava . lang . string ; , ( ) ljava . lang . string ; , null , null , trim , null , [ 246 , 248 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "d f [ potential method declaration ] { d f , ld demo refactorings ; , ( ) v , null , null , d f , null , [ 195 , 198 ] , " + ( r default + 9 ) + " } \ n" + dcnl "d fi [ type ref ] { d fi , , ld fi ; , null , null , null , null , [ 195 , 198 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "d f [ potential method declaration ] { d f , ld demo refactorings ; , ( ) v , null , null , d f , null , [ 150 , 153 ] , " + ( r default + 9 ) + " } \ n" + dcnl "d fi [ type ref ] { d fi , , ld fi ; , null , null , null , null , [ 150 , 153 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "d f [ potential method declaration ] { d f , ld demo refactorings ; , ( ) v , null , null , d f , null , [ 36 , 39 ] , " + ( r default + 9 ) + " } \ n" + dcnl "d fi [ type ref ] { d fi , , ld fi ; , null , null , null , null , [ 36 , 39 ] , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
assert results ( "to binary string [ method name reference ] { to binary string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to binary string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to hex string [ method name reference ] { to hex string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to hex string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to octal string [ method name reference ] { to octal string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to octal string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to string [ method name reference ] { to string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to string [ method name reference ] { to string , ljava . lang . integer ; , ( ii ) ljava . lang . string ; , null , null , to string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to unsigned long [ method name reference ] { to unsigned long , ljava . lang . integer ; , ( i ) j , null , null , to unsigned long , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to unsigned string [ method name reference ] { to unsigned string , ljava . lang . integer ; , ( i ) ljava . lang . string ; , null , null , to unsigned string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to unsigned string [ method name reference ] { to unsigned string , ljava . lang . integer ; , ( ii ) ljava . lang . string ; , null , null , to unsigned string , null , [ 90 , 98 ] , " + ( r default + 19 ) + " } \ n" + dcnl "to string [ method name reference ] { to string , ljava . lang . integer ; , ( ) ljava . lang . string ; , null , null , to string , null , [ 90 , 98 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "char at [ method ref ] { char at ( ) , ljava . lang . string ; , ( i ) c , null , null , char at , ( arg0 ) , [ 232 , 234 ] , " + ( r default + 30 ) + " } \ n" + dcnl "chars [ method ref ] { chars ( ) , ljava . lang . char sequence ; , ( ) ljava . util . stream . int stream ; , null , null , chars , null , [ 232 , 234 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( i ) i , null , null , hash code , ( arg0 ) , [ 164 , 165 ] , " + ( r default + 49 ) + " } \ n" + dcnl "highest one bit [ method ref ] { highest one bit ( ) , ljava . lang . integer ; , ( i ) i , null , null , highest one bit , ( arg0 ) , [ 164 , 165 ] , " + ( r default + 49 ) + " } \ n" + dcnl "hash code [ method ref ] { hash code ( ) , ljava . lang . integer ; , ( ) i , null , null , hash code , null , [ 164 , 165 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "print [ method name reference ] { print , ljava . io . print stream ; , ( c ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( d ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( f ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( i ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( j ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( z ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "print [ method name reference ] { print , ljava . io . print stream ; , ( [ c ) v , null , null , print , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( c ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( d ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( f ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( i ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( j ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . object ; ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( ljava . lang . string ; ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( z ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "println [ method name reference ] { println , ljava . io . print stream ; , ( [ c ) v , null , null , println , null , [ 188 , 191 ] , " + ( r default + 25 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 188 , 191 ] , " + ( r default + 30 ) + " } \ n" + dcnl "printf [ method name reference ] { printf , ljava . io . print stream ; , ( ljava . util . locale ; ljava . lang . string ; [ ljava . lang . object ; ) ljava . io . print stream ; , null , null , printf , null , [ 188 , 191 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 235 , 238 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 235 , 238 ] , " + ( r default + 19 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 235 , 238 ] , " + ( r default + 30 ) + " } " , requestor . get results ( ) ) ;
assert results ( "get class [ method ref ] { get class ( ) , ljava . lang . object ; , ( ) ljava . lang . class < * > ; , null , null , get class , null , [ 271 , 272 ] , " + ( r default + 30 ) + " } \ n" + dcnl "get [ method ref ] { get ( ) , ljava . util . optional < ljava . lang . double ; > ; , ( ) ljava . lang . double ; , null , null , get , null , [ 271 , 272 ] , " + ( r default + 50 ) + " } " , requestor . get results ( ) ) ;
assert results ( "double to long bits [ method ref ] { double to long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to long bits , ( arg0 ) , [ 256 , 259 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double to raw long bits [ method ref ] { double to raw long bits ( ) , ljava . lang . double ; , ( d ) j , null , null , double to raw long bits , ( arg0 ) , [ 256 , 259 ] , " + ( r default + 49 ) + " } \ n" + dcnl "double value [ method ref ] { double value ( ) , ljava . lang . double ; , ( ) d , null , null , double value , null , [ 256 , 259 ] , " + ( r default + 60 ) + " } " , requestor . get results ( ) ) ;
assert results ( "fi2 [ type ref ] { p4a . fi2 , p4a , lp4a . fi2 ; , null , null , null , null , [ 104 , 107 ] , " + ( r default + 23 ) + " } " , requestor . get results ( ) ) ;
assert results ( "super [ keyword ] { super , null , null , null , null , super , null , [ 192 , 194 ] , " + ( r default + 21 ) + " } " , requestor . get results ( ) ) ;
assert results ( "localmethod1 [ method ref ] { localmethod1 ( ) , l lambda bug ; , ( ) v , null , null , localmethod1 , null , [ 181 , 190 ] , " + ( r default + 12 ) + " } \ n" + dcnl "localmethod2 [ method ref ] { localmethod2 ( ) , l lambda bug ; , ( ) v , null , null , localmethod2 , null , [ 181 , 190 ] , " + ( r default + 12 ) + " } " , requestor . get results ( ) ) ;
assert results ( "localmethod1 [ method ref ] { localmethod1 ( ) , l lambda bug ; , ( ) v , null , null , localmethod1 , null , [ 282 , 291 ] , " + ( r default + 12 ) + " } \ n" + dcnl "localmethod2 [ method ref ] { localmethod2 ( ) , l lambda bug ; , ( ) v , null , null , localmethod2 , null , [ 282 , 291 ] , " + ( r default + 12 ) + " } " , requestor . get results ( ) ) ;
" retention [ type ref ] { java . lang . annotation . retention , java . lang . annotation , ljava . lang . annotation . retention ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " retention policy [ type ref ] { java . lang . annotation . retention policy , java . lang . annotation , ljava . lang . annotation . retention policy ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "return [ keyword ] { return , null , null , return , null , " + ( r default + 19 ) + " } " ,
" retention [ type ref ] { java . lang . annotation . retention , java . lang . annotation , ljava . lang . annotation . retention ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " retention policy [ type ref ] { java . lang . annotation . retention policy , java . lang . annotation , ljava . lang . annotation . retention policy ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "return [ keyword ] { return , null , null , return , null , " + ( r default + 19 ) + " } " ,
"catch [ keyword ] { catch , null , null , catch , null , " + ( r default + 19 ) + " } \ n" + dcnl "finally [ keyword ] { finally , null , null , finally , null , " + ( r default + 19 ) + " } " ,
"while [ keyword ] { while , null , null , while , null , " + ( r default + 19 ) + " } " ,
"some method [ method ref ] { some method ( ) , lx ; , ( ) v , some method , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" resource bundle [ type ref ] { java . util . resource bundle , java . util , ljava . util . resource bundle ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " response cache [ type ref ] { java . net . response cache , java . net , ljava . net . response cache ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set [ type ref ] { java . sql . result set , java . sql , ljava . sql . result set ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set meta data [ type ref ] { java . sql . result set meta data , java . sql , ljava . sql . result set meta data ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "result [ local variable ref ] { result , null , ljava . lang . string ; , result , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" resource bundle [ type ref ] { java . util . resource bundle , java . util , ljava . util . resource bundle ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " response cache [ type ref ] { java . net . response cache , java . net , ljava . net . response cache ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set [ type ref ] { java . sql . result set , java . sql , ljava . sql . result set ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set meta data [ type ref ] { java . sql . result set meta data , java . sql , ljava . sql . result set meta data ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "result [ local variable ref ] { result , null , ljava . lang . string ; , result , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" resource bundle [ type ref ] { java . util . resource bundle , java . util , ljava . util . resource bundle ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " response cache [ type ref ] { java . net . response cache , java . net , ljava . net . response cache ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set [ type ref ] { java . sql . result set , java . sql , ljava . sql . result set ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl " result set meta data [ type ref ] { java . sql . result set meta data , java . sql , ljava . sql . result set meta data ; , null , null , " + ( r default + 9 ) + " } \ n" + dcnl "result [ local variable ref ] { result , null , ljava . lang . string ; , result , null , " + ( r default + 22 ) + " } " , requestor . get results ( ) ) ;
" enum [ type ref ] { enum , java . lang , ljava . lang . enum ; , null , null , " + ( r default + 12 ) + " } " ,
" enum [ type ref ] { org . apache . commons . lang . enum . enum , org . apache . commons . lang . enum , lorg . apache . commons . lang . enum . enum ; , null , null , " + ( r default + 9 ) + " } " ,
"org . apache . commons . lang . enum [ package ref ] { org . apache . commons . lang . enum . * ; , org . apache . commons . lang . enum , null , null , null , " + ( r default + 19 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" main [ type ref ] { main , p , lp . main ; , null , null , " + ( r default + 22 ) + " } " ,
" nested [ type ref ] { nested , myannotations , lmyannotations . nested ; , null , null , " + ( r default + 42 ) + " } " ,
* copyright ( c ) 2000 , 2016 ibm corporation and others .
" this class is final [ type ref ] { this class is final , test , ltest . this class is final ; , null , null , " + ( r default + r resolved + r interesting + r case + r expected type + r unqualified + r non restricted ) + " } \ n" + dcnl " this class is not final [ type ref ] { this class is not final , test , ltest . this class is not final ; , null , null , " + ( r default + r resolved + r interesting + r case + r expected type + r unqualified + r non restricted ) + " } " ,
" inn . inn2 [ type ref ] { label . inn . inn2 , label , llabel . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl " in [ type ref ] { in , label , llabel . in ; , null , null , " + ( r default + 42 ) + " } \ n" + dcnl " inn [ type ref ] { inn , label , llabel . inn ; , null , null , " + ( r default + 42 ) + " } " ,
" inn . inn2 [ type ref ] { inn2 , label , llabel . inn$ inn2 ; , null , null , " + ( r default + 39 ) + " } \ n" + dcnl " inn . inn3 [ type ref ] { inn3 , label , llabel . inn$ inn3 ; , null , null , " + ( r default + 39 ) + " } " ,
"name [ annotation attribute ref ] { name , ltestxxx . ya annot ; , ljava . lang . string ; , name , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "val [ annotation attribute ref ] { val , ltestxxx . ya annot ; , i , val , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
"xxyy [ field ref ] { xxyy , ltestxxx . test type2 ; , i , xxyy , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "xxyy1 [ field ref ] { xxyy1 , ltestxxx . test type2 ; , ljava . lang . string ; , xxyy1 , null , " + dcnl ( r default + r resolved + r interesting + r case + r unqualified + r non restricted + r exact expected type ) + " } " ,
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
int relevance = r default + r resolved + r interesting + r exact name + r case + r unqualified + r non restricted ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , [ 105 , 108 ] , " + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , [ 105 , 108 ] , " + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
"xtm [ javadoc param ref ] { xtm , null , null , xtm , null , " + this . positions + ( r default + 14 ) + " } \ n" + dcnl "xtc [ javadoc param ref ] { xtc , null , null , xtc , null , " + this . positions + ( r default + 13 ) + " } \ n" +
* copyright ( c ) 2000 , 2016 ibm corporation and others .
" int items ; \ n" + dcnl " int other items ; \ n" + dcnl " long items count ; \ n" +
" this . item \ n" +
string complete behind = "this . item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r non static + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + + r case + r non static + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r non static + r non restricted ) + " } " ,
" int items ; \ n" + dcnl " int other items ; \ n" + dcnl " long items count ; \ n" +
" item \ n" +
string complete behind = "item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" +
" test . item \ n" +
string complete behind = " test . item" ;
"items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + r case + r non restricted + r non inherited ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r non restricted + r non inherited ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" +
" item \ n" +
string complete behind = "item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" +
" int temporary item = 0 ; \ n" + dcnl " item \ n" +
string complete behind = "item" ;
"other items [ field ref ] { other items , ltest . test ; , i , other items , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "temporary item [ local variable ref ] { temporary item , null , i , temporary item , null , " + ( r default + r resolved + r interesting + r unqualified + r non restricted + r substring ) + " } \ n" + dcnl "items [ field ref ] { items , ltest . test ; , i , items , null , " + ( r default + r resolved + r case + r interesting + r unqualified + r non restricted ) + " } \ n" + dcnl "items count [ field ref ] { items count , ltest . test ; , j , items count , null , " + ( r default + r resolved + r interesting + r case + r unqualified + r non restricted ) + " } " ,
" static int items ; \ n" + dcnl " int other items ; \ n" + dcnl " static long items count ; \ n" + dcnl " void foo ( int init items ) { \ n" + dcnl " item \ n" +
string complete behind = "item" ;
return build model test suite ( substring completion tests . class , bytecode declaration order ) ;
completion project = set up java project ( " completion" , "1 . 8" , true ) ;
set up project compliance ( completion project , "1 . 8" , true ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
int r default = 30 ;
import org . eclipse . jdt . ui . tests . wizardapi . importer test ;
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8 dcnl org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
* copyright ( c ) 2003 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . compiler . classfmt . class file constants ; dcnl
set token wrap policy ( 0 , policy , true ) ;
set token wrap policy ( i , policy , wrap preceeding comments ) ;
private void set token wrap policy ( int wrap indexes index , wrap policy policy , boolean wrap preceeding comments ) { dcnl int index = this . wrap indexes . get ( wrap indexes index ) ;
expected problem attributes . put ( " field must be final" , new problem attributes ( categorized problem . cat internal ) ) ;
" field y2 must be final \ n" +
* copyright ( c ) 2000 , 2016 ibm corporation and others .
@ suppress warnings ( "unchecked" )
public < t > t get adapter ( class < t > adapter ) {
assert start token . get line breaks before ( ) > 0 ;
token . set indent ( this . line indent ) ;
* ensure that creating an excluded package doesn't make it appear as a child of its package fragment root but it is a non - java resource .
switch ( delta . get kind ( ) ) { dcnl case i resource delta . added : dcnl case i resource delta . removed : dcnl / / close the containing package fragment root to reset its cached children . dcnl / / see http : / / bugs . eclipse . org / 500714 dcnl i package fragment root root = find containing package fragment root ( resource ) ; dcnl if ( root ! = null & & root . is open ( ) ) { dcnl try { dcnl root . close ( ) ; dcnl } catch ( java model exception e ) { dcnl util . log ( e ) ; dcnl } dcnl } dcnl break ; dcnl dcnl case i resource delta . changed : / / look for . jar file change to update classpath dcnl children = delta . get affected children ( ) ; dcnl break ;
private i package fragment root find containing package fragment root ( i resource resource ) { dcnl i project project = resource . get project ( ) ; dcnl if ( java project . has java nature ( project ) ) { dcnl i java project java project = java core . create ( project ) ; dcnl try { dcnl i path path = resource . get project relative path ( ) ; dcnl i package fragment root [ ] roots = java project . get package fragment roots ( ) ; dcnl for ( i package fragment root root : roots ) { dcnl i resource root resource = root . get underlying resource ( ) ; dcnl if ( root resource ! = null & & !resource . equals ( root resource ) & & dcnl root resource . get project relative path ( ) . is prefix of ( path ) ) { dcnl return root ; dcnl } dcnl } dcnl } catch ( java model exception e ) { dcnl util . log ( e ) ; dcnl } dcnl } dcnl return null ; dcnl } dcnl
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
* dcnl * < p > dcnl * note : this internal interface has been implemented illegally by the dcnl * org . apache . jasper . glassfish bundle from orbit , see dcnl * < a href = "https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 500211" > bug 500211 < / a > . dcnl * avoid changing the api or supply default methods to avoid breaking the eclipse help system . dcnl * < / p >
default boolean ignore optional problems ( ) { dcnl return false ; dcnl }
* dcnl * < p > dcnl * note : this internal interface has been implemented illegally by the dcnl * org . apache . jasper . glassfish bundle from orbit , see dcnl * < a href = "https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 500211" > bug 500211 < / a > . dcnl * avoid changing the api or supply default methods to avoid breaking the eclipse help system . dcnl * < / p >
* dcnl * note : implementers must reimplement this method!
default name environment answer find type ( char [ ] [ ] compound type name , char [ ] client ) { dcnl return find type ( compound type name ) ; dcnl } dcnl / * * dcnl * @ deprecated don't override this method any more , but override { @ link #find type ( char [ ] [ ] , char [ ] ) } dcnl * / dcnl @ deprecated dcnl default name environment answer find type ( char [ ] [ ] compound type name ) { dcnl return find type ( compound type name , null / * jrt util . java base char * / ) ; dcnl }
* dcnl * note : implementers must reimplement this method!
default name environment answer find type ( char [ ] type name , char [ ] [ ] package name , char [ ] client ) { dcnl return find type ( type name , package name ) ; dcnl } dcnl / * * dcnl * @ deprecated don't override this method any more , but override { @ link #find type ( char [ ] , char [ ] [ ] , char [ ] ) } dcnl * / dcnl @ deprecated dcnl default name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) { dcnl return find type ( type name , package name , null / * jrt util . java base char * / ) ; dcnl }
* dcnl * note : implementers must reimplement this method!
default boolean is package ( char [ ] [ ] parent package name , char [ ] package name , char [ ] client ) { dcnl return is package ( parent package name , package name ) ; dcnl } dcnl / * * dcnl * @ deprecated don't override this method any more , but override { @ link #is package ( char [ ] [ ] , char [ ] , char [ ] ) } dcnl * / dcnl @ deprecated dcnl default boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) { dcnl return is package ( parent package name , package name , null / * jrt util . java base char * / ) ; dcnl }
* note : implementers must reimplement this method! dcnl *
import org . eclipse . jdt . internal . compiler . lookup . polymorphic method binding ;
/ / tests names = new string [ ] { "test495912" } ;
if ( this . initializer body = = null ) { dcnl return this . initializer body = new recovered block ( nested block declaration , this , bracket balance value ) ; dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
buffer . append ( "provides " ) ; / / $non - nls - 1$
if ( this . requires ! = null & & this . requires . length > 0 ) { dcnl buffer . append ( ' \ n' ) ;
buffer . append ( "public " ) ; / / $non - nls - 1$
if ( this . exports ! = null & & this . exports . length > 0 ) {
buffer . append ( this . exports [ i ] . to string ( ) ) . append ( ' \ n' ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . debug . core . logicalstructures . jdi return value variable ;
public static final string img objs method result = "img objs method result" ; / / $non - nls - 1$
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . resources . i project ;
* < p > note : although { @ link #close } is exposed in the api , clients are
* dcnl * < p > note : this method doesn't tell whether an { @ link i java project } 's { @ link i java project#get project ( ) get project ( ) } is open . dcnl * it is < b > not < / b > equivalent to { @ link i project#is open ( ) } ! < / p > dcnl * dcnl * < p > note : although { @ link #is open } is exposed in the api , clients dcnl * rarely have a need to rely on this internal state of the java model . < / p > dcnl
int [ ] cap ids = this . compliance level < class file constants . jdk1 8 dcnl ? new int [ ] { 1 , 3 , 4 , 6 , 13 } dcnl : new int [ ] { 1 , 2 , 3 , 4 , 8 } ;
" type mismatch : cannot convert from list < capture#" + cap ids [ 0 ] + " - of ? extends collection < ? > > to list < collection > \ n" +
" type mismatch : cannot convert from list < capture#" + cap ids [ 1 ] + " - of ? extends collection > to list < collection > \ n" +
" type mismatch : cannot convert from list < capture#" + cap ids [ 2 ] + " - of ? extends collection < ? > > to list < collection < ? > > \ n" +
" type mismatch : cannot convert from list < capture#" + cap ids [ 3 ] + " - of ? extends collection > to list < collection < ? > > \ n" +
" type mismatch : cannot convert from list < capture#" + cap ids [ 4 ] + " - of ? extends collection > to list < ? extends collection < ? > > \ n" +
string source = "import java . util . list ; \ n" +
boolean is18plus = scope . compiler options ( ) . compliance level > = class file constants . jdk1 8 ;
type binding captured wildcard bound = is18plus dcnl ? original wildcard bound / / as spec'd dcnl : original wildcard bound . capture ( scope , this . start , this . end ) ; / / for compatibility with old behavior at 1 . 7 -
* copyright ( c ) 2006 , 2016 bea systems , inc .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
public void test processor arguments with eclipse compiler ( ) throws io exception {
public void test compiler one class with eclipse compiler ( ) throws io exception {
this . ast = ast . new ast ( get ast8 ( ) ) ;
/ * * dcnl * @ deprecated dcnl * / dcnl static int get ast8 ( ) { dcnl return ast . jls8 ; dcnl }
compilation unit compilation unit = this . working copy . reconcile ( get ast8 ( ) , i compilation unit . force problem detection , null , null ) ;
final ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
build ast ( get ast8 ( ) , contents , this . working copy , false , true , true ) ;
ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
build ast ( get ast8 ( ) , contents , this . working copy , false , true , true ) ;
build ast ( get ast8 ( ) , contents , this . working copy , false , true , true ) ;
build ast ( get ast8 ( ) , contents , this . working copy , false , true , true ) ;
build ast ( get ast8 ( ) , contents , this . working copy , false , true , true ) ;
build ast ( get ast8 ( ) , contents , this . working copy , false , true , true ) ;
final ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
final ast parser parser = ast parser . new parser ( get ast8 ( ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* commented since reverted to original behaviour as per bug 495598
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2015 ibm corporation and others .
if ( this . methods [ i ] . does parameter length match ( suggested parameter length ) )
if ( this . methods [ i ] . does parameter length match ( suggested parameter length ) )
import org . eclipse . jdt . core . compiler . char operation ;
method binding [ ] ifc methods = super type . un resolved methods ( ) ;
f trigger point button active . set selection ( is active trigger point ( ) ) ;
f trigger point button active . set enabled ( is trigger point ( ) ) ; dcnl f trigger point button active . set selection ( is active trigger point ( ) ) ;
* copyright ( c ) 2009 , 2016 ibm corporation and others .
* copyright ( c ) 2010 , 2016 ibm corporation and others .
* copyright ( c ) 2009 , 2016 ibm corporation and others .
* copyright ( c ) 2009 , 2016 ibm corporation and others .
* copyright ( c ) 2009 , 2016 ibm corporation and others .
disable trigger point ( event ) ;
protected void disable trigger point ( event event ) {
import org . eclipse . debug . core . debug plugin ;
* copyright ( c ) 2005 , 2016 bea systems , inc .
import org . eclipse . jdt . internal . compiler . env . i module environment ;
import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class classpath jsr199 extends classpath location implements i module environment {
public name environment answer find class ( char [ ] type name , string qualified package name , string a qualified binary file name , dcnl boolean as binary only ) {
/ / do nothing
public i module get module ( ) {
new classpath jar ( new file ( "relative . jar" ) , true , null , null ) .
import org . eclipse . jdt . internal . compiler . env . i module environment ;
import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class classpath directory extends classpath location implements i module environment {
private i module module ;
private name environment answer find class internal ( char [ ] type name , string qualified package name , string qualified binary file name , boolean as binary only ) {
string file name = new string ( type name ) ; dcnl boolean binary exists = ( ( this . mode & binary ) ! = 0 ) & & does file exist ( file name + suffix string class , qualified package name ) ; dcnl boolean source exists = ( ( this . mode & source ) ! = 0 ) & & does file exist ( file name + suffix string java , qualified package name ) ;
unit . module = this . module . name ( ) ;
qualified package name . replace ( file . separator char , ' / ' ) + " / " + file name / / $non - nls - 1$ dcnl : file name ;
public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name ) { dcnl return find class ( type name , qualified package name , qualified binary file name , false ) ; dcnl } dcnl public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name , boolean as binary only ) { dcnl string qp2 = file . separator char = = ' / ' ? qualified package name : qualified package name . replace ( ' / ' , file . separator char ) ; dcnl if ( qp2 = = qualified package name ) { dcnl return find class internal ( type name , qualified package name , qualified binary file name , as binary only ) ; dcnl } else { dcnl string qb2 = qualified binary file name . replace ( ' / ' , file . separator char ) ; dcnl return find class internal ( type name , qp2 , qb2 , as binary only ) ; dcnl } dcnl }
string qp2 = file . separator char = = ' / ' ? qualified package name : qualified package name . replace ( ' / ' , file . separator char ) ; dcnl if ( qualified package name = = qp2 ) { dcnl return directory list ( qualified package name ) ! = null ; dcnl } dcnl return directory list ( qp2 ) ! = null ;
public i module get module ( ) { dcnl return this . module ; dcnl }
import org . eclipse . jdt . internal . compiler . classfmt . module info ;
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module location ;
import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class classpath jar extends classpath location implements i module environment {
private i module module ;
access rule set access rule set , string destination path ) {
result . add ( new classpath jar ( new file ( directory path + ( string ) called files iterator . next ( ) ) , this . close zip file at end , this . access rule set , this . destination path ) ) ;
public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name ) { dcnl return find class ( type name , qualified package name , qualified binary file name , false ) ;
public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name , boolean as binary only ) {
class file reader reader = class file reader . read ( this . zip file , qualified binary file name ) ;
if ( this . zip file = = null ) {
i module module decl = reader . get module declaration ( ) ; dcnl if ( module decl ! = null ) { dcnl this . module = module decl ; dcnl ( ( module info ) module decl ) . entry = this ;
reader = new class file reader ( content , i module location . module info class . to char array ( ) , null ) ;
dcnl for ( enumeration e = this . zip file . entries ( ) ; e . has more elements ( ) ; ) { dcnl string file name = ( ( zip entry ) e . next element ( ) ) . get name ( ) ; dcnl add to package cache ( file name , false ) ;
if ( this . annotation paths ! = null ) {
public i module get module ( ) { dcnl return this . module ; dcnl } dcnl / / @ override dcnl / / public boolean serves module ( i module mod ) { dcnl / / if ( !this . is jrt ) { dcnl / / return super . serves module ( mod ) ; dcnl / / } dcnl / / if ( mod = = null ) dcnl / / return false ; dcnl / / if ( mod = = module environment . unnamed module ) dcnl / / return true ; dcnl / / return modules cache . contains key ( new string ( mod . name ( ) ) ) ; dcnl / / }
public type lookup type lookup ( ) { dcnl return this : : find class ;
import java . util . stream . stream ;
import org . eclipse . jdt . internal . compiler . env . i module path entry ;
import org . eclipse . jdt . internal . compiler . env . i module environment ;
import org . eclipse . jdt . internal . compiler . env . i module context ;
import org . eclipse . jdt . internal . compiler . env . type lookup ;
public interface classpath extends i module path entry {
public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name ) ; dcnl public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name , boolean as binary only ) ;
result = new classpath jrt ( file , true , access rule set , null ) ;
result = new classpath jar ( file , true , access rule set , null ) ;
/ / private name environment answer find class ( string qualified type name , char [ ] type name , boolean as binary only ) { dcnl / / string qualified binary file name = qualified type name + suffix string class ; dcnl / / string qualified package name = dcnl / / qualified type name . length ( ) = = type name . length dcnl / / ? util . empty string dcnl / / : qualified binary file name . substring ( 0 , qualified type name . length ( ) - type name . length - 1 ) ; dcnl / / name environment answer suggested answer = null ; dcnl / / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl / / name environment answer answer = this . classpaths [ i ] . find class ( type name , qualified package name , qualified binary file name , as binary only ) ; dcnl / / if ( answer ! = null ) { dcnl / / if ( !answer . ignore if better ( ) ) { dcnl / / if ( answer . is better ( suggested answer ) ) dcnl / / return answer ; dcnl / / } else if ( answer . is better ( suggested answer ) ) dcnl / / / / remember suggestion and keep looking dcnl / / suggested answer = answer ; dcnl / / } dcnl / / } dcnl / / if ( this . annotations from classpath & & suggested answer ! = null & & suggested answer . get binary type ( ) instanceof class file reader ) { dcnl / / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl / / classpath classpath entry = this . classpaths [ i ] ; dcnl / / if ( classpath entry . has annotation file for ( qualified type name ) ) { dcnl / / zip file zip = classpath entry instanceof classpath jar ? ( ( classpath jar ) classpath entry ) . zip file : null ; dcnl / / try { dcnl / / ( ( class file reader ) suggested answer . get binary type ( ) ) . set external annotation provider ( classpath entry . get path ( ) , qualified type name , zip , null ) ; dcnl / / break ; dcnl / / } catch ( io exception e ) { dcnl / / / / ignore broken entry , keep searching dcnl / / } dcnl / / } dcnl / / } dcnl / / } dcnl / / return suggested answer ; dcnl / / } dcnl private name environment answer find class ( string qualified type name , char [ ] type name , boolean as binary only ) { dcnl name environment answer answer = internal find class ( qualified type name , type name , as binary only , module environment . unnamed module context ) ;
/ /
/ / string qp2 = file . separator char = = ' / ' ? qualified package name : qualified package name . replace ( ' / ' , file . separator char ) ; dcnl / / name environment answer suggested answer = null ; dcnl / / if ( qualified package name = = qp2 ) { dcnl / / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl / / name environment answer answer = null ; dcnl / / for ( i module i module : modules ) { dcnl / / boolean is unnamed = char operation . equals ( i module . name ( ) , module environment . unnamed ) ; dcnl / / if ( !is unnamed & & !this . classpaths [ i ] . serves module ( i module . name ( ) ) ) continue ; dcnl / / answer = is unnamed ? this . classpaths [ i ] . find class ( new string ( type name ) , qualified package name , qualified binary file name , as binary only ) : this . classpaths [ i ] . find class ( new string ( type name ) , qualified package name , qualified binary file name , as binary only , i module . name ( ) ) ; dcnl / / if ( answer ! = null ) break ; dcnl / / } dcnl / / if ( answer ! = null ) { dcnl / / if ( !answer . ignore if better ( ) ) { dcnl / / if ( answer . is better ( suggested answer ) ) dcnl / / return answer ; dcnl / / } else if ( answer . is better ( suggested answer ) ) dcnl / / / / remember suggestion and keep looking dcnl / / suggested answer = answer ; dcnl / / } dcnl / / } dcnl / / } else { dcnl / / string qb2 = qualified binary file name . replace ( ' / ' , file . separator char ) ; dcnl / / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl / / classpath p = this . classpaths [ i ] ; dcnl / / name environment answer answer = null ; dcnl / / for ( i module i module : modules ) { dcnl / / boolean is unnamed = char operation . equals ( i module . name ( ) , module environment . unnamed ) ; dcnl / / if ( !is unnamed & & !p . serves module ( i module . name ( ) ) ) continue ; dcnl / / if ( is unnamed ) { dcnl / / answer = ( p instanceof classpath jar ) dcnl / / ? p . find class ( new string ( type name ) , qualified package name , qualified binary file name , as binary only ) dcnl / / : p . find class ( new string ( type name ) , qp2 , qb2 , as binary only ) ; dcnl / / } else { dcnl / / answer = ( p instanceof classpath jar ) dcnl / / ? p . find class ( new string ( type name ) , qualified package name , qualified binary file name , as binary only ) dcnl / / : p . find class ( new string ( type name ) , qp2 , qb2 , as binary only , i module . name ( ) ) ; dcnl / / } dcnl / / if ( answer ! = null ) break ; dcnl / / } dcnl / / if ( answer ! = null ) { dcnl / / if ( !answer . ignore if better ( ) ) { dcnl / / if ( answer . is better ( suggested answer ) ) dcnl / / return answer ; dcnl / / } else if ( answer . is better ( suggested answer ) ) dcnl / / / / remember suggestion and keep looking dcnl / / suggested answer = answer ; dcnl / / } dcnl / / } dcnl / / } dcnl / / if ( suggested answer ! = null ) dcnl / / / / no better answer was found dcnl / / return suggested answer ; dcnl / / return null ; dcnl dcnl return stream . of ( modules ) dcnl . map ( m - > { dcnl if ( m = = module environment . unnamed module ) { dcnl type lookup t = null ; dcnl for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl classpath p = this . classpaths [ i ] ; dcnl if ( t = = null ) { dcnl t = p : : find class ; dcnl } else { dcnl t = t . chain ( p : : find class ) ; dcnl } dcnl } dcnl return t ; dcnl } dcnl i module environment env = m . get lookup environment ( ) ; dcnl return env = = null ? null : m . get lookup environment ( ) . type lookup ( ) ; dcnl } ) dcnl . filter ( t - > t ! = null ) dcnl . reduce ( type lookup : : chain ) dcnl . map ( lookup - > lookup . find class ( type name , qualified package name , qualified binary file name , as binary only ) ) dcnl . or else ( null ) ; dcnl } dcnl public name environment answer find type ( char [ ] [ ] compound name ) { dcnl if ( compound name ! = null ) dcnl return find class ( dcnl new string ( char operation . concat with ( compound name , ' / ' ) ) , dcnl compound name [ compound name . length - 1 ] , dcnl false ) ;
public name environment answer find type ( char [ ] [ ] compound name , boolean as binary only ) {
as binary only ) ; dcnl return null ; dcnl } dcnl public name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) { dcnl if ( type name ! = null ) dcnl return find class ( dcnl new string ( char operation . concat with ( package name , type name , ' / ' ) ) , dcnl type name , dcnl false ) ;
if ( ! char operation . equals ( mod . name ( ) , module environment . unnamed ) & & !this . classpaths [ i ] . serves module ( mod . name ( ) ) ) continue ;
if ( ! char operation . equals ( mod . name ( ) , module environment . unnamed ) & & !p . serves module ( mod . name ( ) ) ) continue ;
/ / public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , char [ ] client , boolean search secondary types ) { dcnl / / return find type ( type name , package name , client ) ; dcnl / / } dcnl / / public name environment answer find type ( char [ ] [ ] compound name , boolean as binary only , i module [ ] modules ) { dcnl / / if ( compound name ! = null ) dcnl / / return find class ( dcnl / / new string ( char operation . concat with ( compound name , ' / ' ) ) , dcnl / / compound name [ compound name . length - 1 ] , dcnl / / as binary only , modules ) ; dcnl / / return null ; dcnl / / } dcnl / / public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , i module [ ] modules ) { dcnl / / if ( type name ! = null ) dcnl / / return find class ( dcnl / / new string ( char operation . concat with ( package name , type name , ' / ' ) ) , dcnl / / type name , dcnl / / false , dcnl / / modules ) ; dcnl / / return null ; dcnl / / } dcnl dcnl public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , i module context module lookup context ) { dcnl if ( type name = = null ) dcnl return null ; dcnl string qualified type name = new string ( char operation . concat with ( package name , type name , ' / ' ) ) ; dcnl name environment answer answer = internal find class ( qualified type name , type name , false , module lookup context ) ; dcnl if ( this . annotations from classpath & & answer ! = null & & answer . get binary type ( ) instanceof class file reader ) { dcnl for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl classpath classpath entry = this . classpaths [ i ] ; dcnl if ( classpath entry . has annotation file for ( qualified type name ) ) { dcnl zip file zip = classpath entry instanceof classpath jar ? ( ( classpath jar ) classpath entry ) . zip file : null ; dcnl try { dcnl ( ( class file reader ) answer . get binary type ( ) ) . set external annotation provider ( classpath entry . get path ( ) , qualified type name , zip , null ) ; dcnl break ; dcnl } catch ( io exception e ) { dcnl / / ignore broken entry , keep searching dcnl } dcnl } dcnl } dcnl } dcnl return answer ; dcnl
public boolean is package ( char [ ] [ ] compound name , char [ ] package name ) { dcnl return is package ( compound name , package name , module environment . unnamed module context ) ;
public boolean is package ( char [ ] [ ] compound name , char [ ] package name , i module context module context ) {
/ / string qp2 = file . separator char = = ' / ' ? qualified package name : qualified package name . replace ( ' / ' , file . separator char ) ; dcnl / / if ( qualified package name = = qp2 ) { dcnl / / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) dcnl / / for ( i module i module : modules ) { dcnl / / if ( !this . classpaths [ i ] . serves module ( i module . name ( ) ) ) continue ; dcnl / / i module environment env = i module . get lookup environment ( ) ; dcnl / / if ( env ! = null & & env . is package ( qualified package name ) ) dcnl / / return true ; dcnl / / } dcnl / / } else { dcnl if ( module context = = module environment . unnamed module context ) { dcnl return stream . of ( this . classpaths ) . map ( p - > p . get lookup environment ( ) . package lookup ( ) ) . filter ( l - > l . is package ( qualified package name ) ) . find any ( ) . is present ( ) ;
return module context . get ( ) . map ( e - > e . package lookup ( ) ) . filter ( l - > l . is package ( qualified package name ) ) . find any ( ) . is present ( ) ;
/ / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl / / classpath p = this . classpaths [ i ] ; dcnl / / for ( i module i module : modules ) { dcnl / / if ( i module = = module environment . unnamed module ) { dcnl / / if ( p . get lookup environment ( ) . is package ( qualified package name ) ) dcnl / / return true ; dcnl / / } else { dcnl / / i module environment env = p . get lookup environment for ( i module ) ; dcnl / / if ( env ! = null & & env . is package ( qualified package name ) ) dcnl / / return true ; dcnl / / } dcnl / / } dcnl / / } dcnl / / } dcnl / / return false ; dcnl / / return stream . of ( modules ) . map ( m - > m . get lookup environment ( ) . package lookup ( ) ) dcnl / / . any match ( lookup - > lookup . is package ( qualified package name ) ) ;
return stream . of ( this . classpaths ) . map ( cp - > cp . get module ( name ) ) . filter ( m - > m ! = null ) . find any ( ) . or else ( null ) ; dcnl dcnl } dcnl private name environment answer internal find class ( string qualified type name , char [ ] type name , boolean as binary only , i module context module context ) { dcnl if ( this . known file names . contains ( qualified type name ) ) return null ; / / looking for a file which we know was provided at the beginning of the compilation dcnl dcnl string qualified binary file name = qualified type name + suffix string class ; dcnl string qualified package name = dcnl qualified type name . length ( ) = = type name . length dcnl ? util . empty string dcnl : qualified binary file name . substring ( 0 , qualified type name . length ( ) - type name . length - 1 ) ; dcnl dcnl if ( module environment . unnamed module context = = module context ) { dcnl return stream . of ( this . classpaths ) . map ( p - > { dcnl return p . get lookup environment ( ) . type lookup ( ) ; dcnl } ) dcnl . reduce ( type lookup : : chain ) . map ( t - > t . find class ( type name , qualified package name , qualified binary file name ) ) . or else ( null ) ; dcnl / / type lookup t = null ; dcnl / / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl / / classpath p = this . classpaths [ i ] ; dcnl / / if ( t = = null ) { dcnl / / t = p : : find class ; dcnl / / } else { dcnl / / t = t . chain ( p : : find class ) ; dcnl / / } dcnl / / } dcnl / / return t . find class ( type name , qualified package name , qualified binary file name ) ;
import org . eclipse . jdt . internal . compiler . env . i module location ;
import org . eclipse . jdt . internal . compiler . batch . file system . classpath ;
import org . eclipse . jdt . internal . compiler . classfmt . module info ;
if ( module path ! = null ) {
i module module = null ; dcnl if ( file . is directory ( ) ) { dcnl string [ ] list = file . list ( new filename filter ( ) { dcnl @ override dcnl public boolean accept ( file dir , string name ) { dcnl if ( dir = = file & & ( name . equals ignore case ( i module location . module info class ) dcnl | | name . equals ignore case ( i module location . module info java ) ) ) { dcnl return true ; dcnl } dcnl return false ; dcnl } dcnl } ) ; dcnl if ( list . length > 0 ) { dcnl string file name = list [ 0 ] ; dcnl switch ( file name ) { dcnl case i module location . module info class : dcnl module = module finder . extract module from class ( new file ( file , file name ) , module path ) ; dcnl break ; dcnl case i module location . module info java : dcnl module = module finder . extract module from source ( new file ( file , file name ) , parser , module path ) ; dcnl break ; dcnl } dcnl } dcnl } else if ( is jar ( file ) ) { dcnl module = extract module from jar ( file , module path ) ; dcnl } dcnl if ( module ! = null ) dcnl module path . accept module ( module ) ; dcnl } dcnl / / file system . classpath module path = file system . get classpath ( dcnl / / file . get absolute path ( ) , dcnl / / null , dcnl / / source only , dcnl / / null , dcnl / / destination path = = null ? null : ( destination path + file . separator + file . get name ( ) ) , dcnl / / options ) ; dcnl / / if ( module path ! = null ) dcnl / / collector . add ( module path ) ; dcnl / / if ( module ! = null ) dcnl / / module path . accept module ( module ) ;
private static i module extract module from jar ( file file , classpath path entry ) {
i module module = get module ( reader ) ; dcnl if ( module instanceof module info ) { dcnl ( ( module info ) module ) . entry = path entry ; dcnl } dcnl return module ;
private static i module extract module from class ( file classfile path , classpath path entry ) {
i module module = get module ( reader ) ; dcnl if ( module ! = null ) { dcnl ( ( module info ) module ) . entry = path entry ; dcnl } dcnl return module ;
private static i module extract module from source ( file file , parser parser , classpath path entry ) {
import java . util . collection ; dcnl import java . util . optional ;
return read from modules ( jrt , filename , optional . empty ( ) ) ;
public static class file reader read from modules ( dcnl file jrt , dcnl string filename , dcnl optional < collection < char [ ] > > module names )
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module path entry ;
public i module path entry entry ; / / the entry that contributes this module to the module path
import java . util . stream . stream ;
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public i module environment module enviroment ;
this . module enviroment = module . get lookup environment ( ) ;
if ( other = = this | | this = = this . environment . un named module )
import org . eclipse . jdt . internal . compiler . env . i module context ;
/ / a special context to represent the unnamed module context . subclasses should perform a whole dcnl / / world lookup when they see this context dcnl public static final i module context unnamed module context = ( ) - > { dcnl return null ; dcnl } ;
@ deprecated
@ deprecated
@ deprecated
@ deprecated
@ deprecated
@ deprecated dcnl public name environment answer find type ( char [ ] [ ] compound type name , i module [ ] modules ) { dcnl return null ; dcnl }
/ / todo : this should be abstract dcnl public name environment answer find type ( char [ ] [ ] compound type name , i module context module context ) { dcnl return null ; dcnl } dcnl @ deprecated dcnl public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , i module [ ] modules ) { dcnl return null ; dcnl }
@ deprecated dcnl public boolean is package ( char [ ] [ ] parent package name , char [ ] package name , i module [ ] module ) { dcnl return false ; dcnl }
import java . util . collection ;
import java . util . iterator ;
import java . util . optional ;
import org . eclipse . jdt . core . compiler . char operation ;
public static class file reader get classfile ( file jrt , string file name , optional < collection < char [ ] > > modules ) throws io exception , class format exception { dcnl return get jrt system ( jrt ) . get classfile ( file name , modules ) ; dcnl } dcnl public static boolean is package ( file jrt , string q name , optional < char [ ] > module ) { dcnl return get jrt system ( jrt ) . is package ( q name , module ) ; dcnl }
public boolean is package ( string qualified package name , optional < char [ ] > module name ) { dcnl qualified package name = qualified package name . replace ( ' . ' , ' / ' ) ; dcnl string module = this . package to module . get ( qualified package name ) ; dcnl if ( !module name . is present ( ) ) dcnl return module ! = null ; dcnl if ( module ! = null ) { dcnl if ( module = = jrt util . multiple ) { dcnl list < string > list = this . package to modules . get ( qualified package name ) ; dcnl return list . contains ( new string ( module name . get ( ) ) ) ; dcnl } else { dcnl return char operation . equals ( module . to char array ( ) , module name . get ( ) ) ; dcnl } dcnl } dcnl return false ; dcnl }
import org . eclipse . jdt . internal . core . module info ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . ltk . core . refactoring . refactoring status ;
" requires java . sql ; \ n" +
return find class ( qualified type name , type name , as binary only , module environment . unnamed module context ) ; dcnl } dcnl private name environment answer find class ( string qualified type name , char [ ] type name , boolean as binary only , i module context module context ) { dcnl name environment answer answer = internal find class ( qualified type name , type name , as binary only , module context ) ;
public name environment answer find type ( char [ ] [ ] compound name , i module context module context ) { dcnl if ( compound name ! = null ) dcnl return find class ( dcnl new string ( char operation . concat with ( compound name , ' / ' ) ) , dcnl compound name [ compound name . length - 1 ] , dcnl false , module context ) ; dcnl return null ; dcnl }
return module context . get environment ( ) . map ( e - > e . package lookup ( ) ) . filter ( l - > l . is package ( qualified package name ) ) . find any ( ) . is present ( ) ;
i module src = get module ( source . to char array ( ) ) ; dcnl if ( src ! = null ) { dcnl src . add reads ( target . to char array ( ) ) ;
exports . entry set ( ) . for each ( ( entry ) - > { dcnl i module src = get module ( entry . get key ( ) . to char array ( ) ) ; dcnl if ( src ! = null ) { dcnl src . add exports ( entry . get value ( ) ) ;
} ) ;
exports . put ( mod name , updated ) ;
import java . util . array list ;
import java . util . collection ; dcnl import java . util . function . predicate ; dcnl import java . util . stream . stream ;
import java . util . array list ;
import java . util . collection ; dcnl import java . util . function . predicate ; dcnl import java . util . stream . stream ;
public void add reads ( char [ ] mod name ) { dcnl predicate < char [ ] > should add = m - > { dcnl return stream . of ( this . requires ) . map ( ref - > ref . name ( ) ) . none match ( n - > char operation . equals ( mod name , n ) ) ; dcnl } ; dcnl if ( should add . test ( mod name ) ) { dcnl int len = this . requires . length ; dcnl this . requires = arrays . copy of ( this . requires , len ) ; dcnl module reference info info = this . requires [ len ] = new module reference info ( ) ; dcnl info . ref name = mod name ; dcnl } dcnl } dcnl public void add exports ( i package export [ ] to add ) { dcnl predicate < char [ ] > should add = m - > { dcnl return stream . of ( this . exports ) . map ( ref - > ref . package name ) . none match ( n - > char operation . equals ( m , n ) ) ; dcnl } ; dcnl collection < package export info > merged = stream . concat ( stream . of ( this . exports ) , stream . of ( to add ) dcnl . filter ( e - > should add . test ( e . name ( ) ) ) dcnl . map ( e - > { dcnl package export info exp = new package export info ( ) ; dcnl exp . package name = e . name ( ) ; dcnl exp . exported to = e . exported to ( ) ; dcnl return exp ; dcnl } ) ) dcnl . collect ( dcnl array list : : new , dcnl array list : : add , dcnl array list : : add all ) ; dcnl this . exports = merged . to array ( new package export info [ merged . size ( ) ] ) ; dcnl }
module . requires count = count ; dcnl module . requires = new module reference info [ count ] ; dcnl module offset + = 2 ; dcnl for ( int i = 0 ; i < count ; i + + ) { dcnl utf8 offset = module . constant pool offsets [ module . u2 at ( module offset ) ] ; dcnl char [ ] requires names = module . utf8 at ( utf8 offset + 3 , module . u2 at ( utf8 offset + 1 ) ) ; dcnl module . requires [ i ] = module . new module reference info ( ) ; dcnl module . requires [ i ] . ref name = requires names ; dcnl module offset + = 2 ; dcnl int pub = module . u2 at ( module offset ) ; dcnl module . requires [ i ] . is public = ( class file constants . acc public = = pub ) ; / / access modifier
module offset + = 2 ; dcnl module . exports count = count ; dcnl module . exports = new package export info [ count ] ; dcnl for ( int i = 0 ; i < count ; i + + ) { dcnl utf8 offset = module . constant pool offsets [ module . u2 at ( module offset ) ] ; dcnl char [ ] exported = module . utf8 at ( utf8 offset + 3 , module . u2 at ( utf8 offset + 1 ) ) ; dcnl char operation . replace ( exported , ' / ' , ' . ' ) ; dcnl package export info pack = module . new package export info ( ) ; dcnl module . exports [ i ] = pack ; dcnl pack . package name = exported ; dcnl module offset + = 2 ; dcnl int exportedto count = module . u2 at ( module offset ) ;
module . module binding = this . environment ( ) . get module ( module ( ) ) ;
return this . un named module ;
name environment answer answer = null ; dcnl if ( this . name environment instanceof i module aware name environment ) { dcnl module binding module = get module ( mod ) ; dcnl answer = ( ( i module aware name environment ) this . name environment ) . find type ( compound name , module . get dependency lookup context ( ) ) ; dcnl } else { dcnl answer = this . name environment . find type ( compound name , mod ) ; dcnl }
name environment answer answer = null ; dcnl if ( this . name environment instanceof i module aware name environment ) { dcnl module binding module = get module ( mod ) ; dcnl answer = ( ( i module aware name environment ) this . name environment ) . find type ( name , package binding . compound name , module . get dependency lookup context ( ) ) ; dcnl } else { dcnl answer = this . name environment . find type ( name , package binding . compound name , mod ) ; dcnl }
if ( is package ( null , name , mod ) ) { dcnl / / if ( this . name environment . is package ( null , name , mod ) ) {
import java . util . collections ;
import java . util . function . predicate ; dcnl import java . util . function . supplier ;
import org . eclipse . jdt . internal . compiler . env . i module context ;
module binding ( lookup environment env ) {
this . environment = env ;
private stream < module binding > get required modules ( boolean implicit only ) { dcnl return stream . of ( this . requires ) . filter ( ref - > implicit only ? ref . is public ( ) : true ) dcnl . map ( ref - > this . environment . get module ( ref . name ( ) ) ) dcnl . filter ( mod - > mod ! = null ) ; dcnl } dcnl public supplier < collection < module binding > > dependency collector ( ) { dcnl return ( ) - > get required modules ( false ) dcnl . collect ( hash set : : new , dcnl ( set , mod ) - > { dcnl set . add ( mod ) ; dcnl set . add all ( mod . implicit dependency collector ( ) . get ( ) ) ; dcnl } , dcnl hash set : : add all ) ; dcnl } dcnl public supplier < collection < module binding > > implicit dependency collector ( ) { dcnl return ( ) - > get required modules ( true ) dcnl . collect ( hash set : : new , dcnl ( set , mod ) - > { dcnl if ( set . add ( mod ) ) dcnl set . add all ( mod . implicit dependency collector ( ) . get ( ) ) ; dcnl } , dcnl hash set : : add all ) ;
if ( this = = this . environment . un named module ) dcnl return collections . empty list ( ) ; dcnl return implicit dependency collector ( ) . get ( ) ;
* get all the modules required by this module
if ( this = = this . environment . un named module )
dcnl collection < module binding > all requires = dependency collector ( ) . get ( ) ; dcnl module binding java base = this . environment . get module ( jrt util . java base char ) ; dcnl if ( ! char operation . equals ( this . module name , type constants . java base ) & & java base ! = null ) { dcnl all requires . add ( java base ) ;
predicate < i package export > is exported = e - > char operation . equals ( e . name ( ) , pkg name ) ; dcnl return stream . of ( this . exported packages ) . any match ( is exported ) ;
* check if the specified package is exported to the client module by this module . true if the package appears dcnl * in the list of exported packages and when the export is targeted , the module appears in the targets of the dcnl * exports statement
* @ return true if the package is visible to the client module , false otherwise
public boolean is package exported to ( package binding pkg , module binding client ) { dcnl predicate < i package export > is exported = e - > char operation . equals ( e . name ( ) , pkg . readable name ( ) ) ; dcnl / / . and ( e - > e . exported to = = null ) ; dcnl predicate < i package export > is targeted = e - > e . exported to ( ) ! = null ; dcnl predicate < i package export > is exported to = e - > dcnl stream . of ( e . exported to ( ) ) . map ( ref - > this . environment . get module ( ref ) ) . filter ( m - > m ! = null ) . any match ( client : : equals ) ; dcnl return stream . of ( this . exported packages ) . any match ( is exported . and ( is targeted . negate ( ) . or ( is exported to ) ) ) ; dcnl } dcnl / * * dcnl * check if the given package is visible to this module . true when the package is exported by some dcnl * required module to this module . see { @ link #is package exported to ( package binding , module binding ) } dcnl * @ param pkg dcnl * @ return true , if the package is visible to this module , false otherwise dcnl * / dcnl public boolean can see ( package binding pkg ) { dcnl if ( this = = this . environment . un named module ) { dcnl / / todo - if the package is part of a named module , then we should check if the module exports the package
return stream . of ( get all required modules ( ) ) . filter ( dep - > dep . is package exported to ( pkg , this ) ) . find first ( ) . is present ( ) ;
dcnl public boolean depends on ( module binding other ) { dcnl if ( other = = this )
return stream . of ( get all required modules ( ) ) . any match ( other : : equals ) ;
public i module context get module lookup context ( ) { dcnl return this = = this . environment . un named module ? module environment . unnamed module context : ( ) - > stream . of ( this . module enviroment ) ;
public i module context get dependency lookup context ( ) {
return this = = this . environment . un named module ? module environment . unnamed module context : ( ) - > stream . concat ( get module lookup context ( ) . get environment ( ) , stream . of ( deps ) . flat map ( m - > m . get dependency lookup context ( ) . get environment ( ) ) ) . filter ( e - > e ! = null ) ; dcnl / / return get module lookup context ( ) . chain ( stream . of ( deps ) . map ( m - > m . module enviroment . type lookup ( ) )
import org . eclipse . jdt . internal . compiler . env . i module aware name environment ;
public abstract class module environment implements i module aware name environment {
import org . eclipse . jdt . internal . compiler . lookup . problem package binding ;
this . left . check npe ( current scope , flow context , flow info ) ;
cursor = this . references table [ 0 ] ; dcnl flow info = cursor . left . analyse code ( current scope , flow context , flow info ) . dcnl unconditional inits ( ) ; dcnl if ( cursor . resolved type . id ! = type ids . t java lang string ) {
cursor = this . references table [ i ] ; dcnl flow info = cursor . right . dcnl analyse code ( current scope , flow context , flow info ) . dcnl unconditional inits ( ) ; dcnl if ( cursor . resolved type . id ! = type ids . t java lang string ) {
flow info = this . right . analyse code ( current scope , flow context , flow info ) . unconditional inits ( ) ;
flow info = this . expression .
public class in memory name environment implements i name environment {
public name environment answer find type ( char [ ] [ ] compound type name ) {
char operation . subarray ( compound type name , 0 , compound type name . length - 1 ) ) ;
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) {
return find type from class libs ( type name , package name ) ;
return find type from class libs ( type name , package name ) ;
private name environment answer find type from class libs ( char [ ] type name , char [ ] [ ] package name ) {
name environment answer answer = this . class libs [ i ] . find type ( type name , package name ) ;
public boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) {
is package from class libs ( parent package name , package name ) ;
public boolean is package from class libs ( char [ ] [ ] parent package name , char [ ] package name ) {
* this test checks if { @ link i name environment#find type ( char [ ] , char [ ] [ ] ) } is executed .
public name environment answer find type ( char [ ] [ ] compound type name ) {
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) {
public boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) {
public name environment answer find type ( char [ ] [ ] compound type name ) {
public boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) {
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , boolean search with secondary types ) {
default name environment answer find type ( char [ ] [ ] compound type name ) { dcnl return find type ( compound type name , null ) ; dcnl } dcnl default name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) { dcnl return find type ( type name , package name , null ) ; dcnl } dcnl default boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) { dcnl return is package ( parent package name , package name , null ) ; dcnl } dcnl default name environment answer find type ( char [ ] type name , char [ ] [ ] package name , boolean search with secondary types ) { dcnl return find type ( type name , package name , search with secondary types , null ) ; dcnl }
name environment answer find type ( char [ ] type name , char [ ] [ ] package name , boolean search with secondary types , i module context module context ) ;
/ * * dcnl * find a type with the given compound name . dcnl * answer the binary form of the type if it is known to be consistent . dcnl * otherwise , answer the compilation unit which defines the type dcnl * or null if the type does not exist . dcnl * types in the default package are specified as { { type name } } . dcnl * dcnl * it is unknown whether the package containing the type actually exists . dcnl * dcnl * note : this method can be used to find a member type using its dcnl * internal name a$b , but the source file for a is answered if the binary dcnl * file is inconsistent . dcnl * /
name environment answer find type ( char [ ] [ ] compound type name ) ; dcnl / * * dcnl * find a type named < type name > in the package < package name > . dcnl * answer the binary form of the type if it is known to be consistent . dcnl * otherwise , answer the compilation unit which defines the type dcnl * or null if the type does not exist . dcnl * the default package is indicated by char [ 0 ] [ ] . dcnl * dcnl * it is known that the package containing the type exists . dcnl * dcnl * note : this method can be used to find a member type using its dcnl * internal name a$b , but the source file for a is answered if the binary dcnl * file is inconsistent . dcnl * /
name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) ; dcnl / * * dcnl * answer whether package name is the name of a known subpackage inside dcnl * the package parent package name . a top level package is found relative to null . dcnl * the default package is always assumed to exist . dcnl * dcnl * for example : dcnl * is package ( { { java } , { awt } } , { event } ) ; dcnl * is package ( null , { java } ) ; dcnl * /
boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) ;
* refer { @ link #find type ( char [ ] , char [ ] [ ] , boolean ) } .
if ( this . name environment instanceof i module aware name environment ) { dcnl i module mod = ( ( i module aware name environment ) this . name environment ) . get module ( name ) ; dcnl if ( mod ! = null ) { dcnl this . known modules . put ( name , module = new module binding ( mod , this ) ) ; dcnl }
answer = this . name environment . find type ( compound name ) ;
answer = this . name environment . find type ( name , package binding . compound name ) ;
/ / if ( module ! = null & & ! char operation . equals ( module , jrt util . java base . to char array ( ) ) dcnl / / & & !this . name environment . is package visible ( package binding . readable name ( ) , module , mod ) ) { dcnl / / return null ; dcnl / / }
module binding client = get module ( scope . module ( ) ) ; dcnl return client . can see ( binding . f package ) ;
if ( ( ( i name environment extension ) this . name environment ) . find type ( compound name [ i ] , parent . compound name , false ) ! = null ) {
if ( this . name environment . find type ( compound name [ i ] , parent . compound name ) ! = null ) {
private name environment answer find type worker ( char [ ] type name , char [ ] [ ] package name , boolean search secondary types , i module context context ) { dcnl name environment answer answer = find type ( type name , package name , context ) ; dcnl / / char [ ] module = null ; dcnl / / if ( answer = = null | | ( module = answer . module name ( ) ) = = null | | client = = null | | dcnl / / char operation . equals ( module , jrt util . java base char ) ) { dcnl / / return answer ; dcnl / / } dcnl / / return return answer after validation ( package name , answer , client ) ;
/ / todo this should be abstract dcnl public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , boolean search with secondary types , i module context context ) { dcnl return find type worker ( type name , package name , search with secondary types , context ) ;
import java . util . stream . stream ; dcnl
import org . eclipse . jdt . internal . compiler . env . i module context ;
import org . eclipse . jdt . internal . compiler . env . type lookup ; dcnl import org . eclipse . jdt . internal . compiler . lookup . module environment ;
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , i module context context ) { dcnl return super . find type ( type name , package name , true , context ) ;
dcnl public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , boolean search secondary types , i module context context ) {
name environment answer answer = super . find type ( type name , package name , context ) ;
/ / name environment answer suggested answer = null ;
/ / for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl / / if ( ! ( this . classpaths [ i ] instanceof classpath directory ) ) continue ; dcnl / / classpath directory classpath directory = ( classpath directory ) this . classpaths [ i ] ; dcnl / / for ( i module i module : modules ) { dcnl / / if ( !classpath directory . serves module ( i module . name ( ) ) ) continue ; dcnl / / answer = classpath directory . find secondary in class ( type name , qualified package name , qualified binary file name ) ; dcnl / / if ( answer ! = null ) { dcnl / / if ( !answer . ignore if better ( ) ) { dcnl / / if ( answer . is better ( suggested answer ) ) dcnl / / return answer ; dcnl / / } else if ( answer . is better ( suggested answer ) ) dcnl / / / / remember suggestion and keep looking dcnl / / suggested answer = answer ; dcnl / / } dcnl / / } dcnl / / } dcnl if ( module environment . unnamed module context = = context ) { dcnl answer = stream . of ( this . classpaths ) . < type lookup > map ( p - > { dcnl return ( t , q package name , q binary file name , as binary only ) - > { dcnl return ( ( classpath directory ) p ) . find secondary in class ( type name , qualified package name , qualified binary file name ) ; dcnl } ; dcnl } ) dcnl . reduce ( type lookup : : chain ) . map ( t - > t . find class ( type name , qualified package name , qualified binary file name ) ) . or else ( null ) ; dcnl } else { dcnl answer = context . get environment ( ) . filter ( env - > env instanceof classpath directory ) dcnl . < type lookup > map ( p - > { dcnl return ( t , q package name , q binary file name , as binary only ) - > { dcnl return ( ( classpath directory ) p ) . find secondary in class ( type name , qualified package name , qualified binary file name ) ; dcnl } ; dcnl } ) dcnl . reduce ( type lookup : : chain ) dcnl . map ( lookup - > lookup . find class ( type name , qualified package name , qualified binary file name ) ) dcnl . or else ( null ) ;
public name environment answer find type ( char [ ] [ ] compound name ) {
return super . find type ( compound name ) ;
public boolean is package ( char [ ] [ ] compound name , char [ ] package name ) {
public class code snippet environment implements i name environment , evaluation constants {
* @ see i name environment#find type ( char [ ] [ ] )
public name environment answer find type ( char [ ] [ ] compound type name ) { dcnl name environment answer result = this . env . find type ( compound type name ) ;
* @ see i name environment#find type ( char [ ] , char [ ] [ ] )
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) { dcnl name environment answer result = this . env . find type ( type name , package name ) ;
return find type ( char operation . array concat ( package name , type name ) ) ;
* @ see i name environment#is package ( char [ ] [ ] , char [ ] )
if ( !environment . is package ( parent name , pkg name ) ) {
public name environment answer find type ( char [ ] name , char [ ] [ ] package name ) {
return super . find type ( name , package name ) ;
public name environment answer find type ( char [ ] [ ] compound type name ) {
import org . eclipse . jdt . internal . compiler . env . i name environment ;
public class searchable environment dcnl implements i name environment , i java search constants {
protected name environment answer find ( string type name , string package name ) {
this . check access restrictions ) ;
* @ see module environment#find type ( char [ ] [ ] )
public name environment answer find type ( char [ ] [ ] compound type name ) {
return find ( new string ( compound type name [ 0 ] ) , null ) ;
char operation . to string ( package name ) ) ;
* @ see module environment#find type ( char [ ] , char [ ] [ ] )
public name environment answer find type ( char [ ] name , char [ ] [ ] package name ) {
package name = = null | | package name . length = = 0 ? null : char operation . to string ( package name ) ) ;
* @ see module environment#is package ( char [ ] [ ] , char [ ] )
public boolean is package ( char [ ] [ ] parent package name , char [ ] sub package name ) {
import org . eclipse . jdt . internal . compiler . env . i name environment ;
public class java search name environment implements i name environment , suffix constants {
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) {
type name , null ) ;
public name environment answer find type ( char [ ] [ ] compound name ) {
compound name [ compound name . length - 1 ] , null ) ;
public boolean is package ( char [ ] [ ] compound name , char [ ] package name ) { dcnl return is package ( new string ( char operation . concat with ( compound name , package name , ' / ' ) ) ) ;
* copyright ( c ) 2007 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . compiler . env . i module context ;
return serves module ( module . name ( ) ) ? classpath jrt . this . type lookup for module . apply ( module . name ( ) ) : type lookup . dummy ;
import org . eclipse . jdt . internal . compiler . env . i module aware name environment ;
public class file system implements i module aware name environment , suffix constants {
return find class ( qualified type name , type name , as binary only , i module context . unnamed module context ) ;
return is package ( compound name , package name , i module context . unnamed module context ) ;
if ( module context = = i module context . unnamed module context ) {
public interface i module aware name environment extends i name environment {
return find type ( compound type name , i module context . unnamed module context ) ;
return find type ( type name , package name , i module context . unnamed module context ) ;
return is package ( parent package name , package name , i module context . unnamed module context ) ;
/ * * dcnl * a special context to represent the unnamed module context dcnl * dcnl * / dcnl i module context unnamed module context = ( ) - > { dcnl return stream . empty ( ) ; dcnl } ;
/ * * dcnl * return the look up environment for this entry . should be used when one needs to dcnl * look up types / packages in all the modules contributed by this entry dcnl * dcnl * /
final module binding un named module = new module binding . un named module ( this ) ;
answer = ( ( i module aware name environment ) this . name environment ) . find type ( compound name , module . get dependency closure context ( ) ) ;
answer = ( ( i module aware name environment ) this . name environment ) . find type ( name , package binding . compound name , module . get dependency closure context ( ) ) ;
module binding module = get module ( mod ) ;
if ( ( ( i name environment extension ) this . name environment ) . find type ( compound name [ i ] , parent . compound name , false , module . get dependency closure context ( ) ) ! = null ) {
public static class un named module extends module binding { dcnl dcnl un named module ( lookup environment env ) { dcnl super ( env ) ; dcnl } dcnl public module binding [ ] get all required modules ( ) { dcnl return no requires ; dcnl } dcnl public i module context get module lookup context ( ) { dcnl return i module context . unnamed module context ; dcnl } dcnl public i module context get dependency closure context ( ) { dcnl return i module context . unnamed module context ; dcnl } dcnl public i module context get module graph context ( ) { dcnl return i module context . unnamed module context ; dcnl } dcnl public boolean can see ( package binding pkg ) { dcnl / / todo - if the package is part of a named module , then we should check if the module exports the package dcnl return true ; dcnl } dcnl }
this . requires = no module refs ; dcnl this . exported packages = no exports ;
/ / a context representing just this module
return ( ) - > this . module enviroment = = null ? stream . empty ( ) : stream . of ( this . module enviroment ) ;
/ / a context including this module and all it's required modules dcnl public i module context get dependency closure context ( ) {
import java . util . function . function ;
return find type ( type name , package name , true , context ) ;
function < classpath directory , type lookup > secondary types lookup = d - > { dcnl return ( t , q package name , q binary file name , as binary only ) - > { dcnl return d . find secondary in class ( t , q package name , q binary file name ) ; dcnl } ; dcnl } ; dcnl if ( i module context . unnamed module context = = context ) { dcnl answer = stream . of ( this . classpaths ) dcnl . filter ( env - > env instanceof classpath directory ) dcnl . map ( p - > ( classpath directory ) p ) dcnl . map ( secondary types lookup ) dcnl . reduce ( type lookup : : chain ) dcnl . map ( t - > t . find class ( type name , qualified package name , qualified binary file name ) ) . or else ( null ) ;
import org . eclipse . jdt . internal . compiler . env . i module context ;
final module binding un named module ;
this . un named module = new module binding . un named module ( this ) ;
import org . eclipse . jdt . internal . compiler . env . i module aware name environment ;
import org . eclipse . jdt . internal . compiler . env . i name environment ;
public i name environment name environment ;
this . name environment = env . name environment ;
this . name environment = environment . name environment ;
predicate < i package export > is exported = e - > char operation . prefix equals ( pkg name , e . name ( ) ) ;
return is package exported to ( pkg . readable name ( ) , client ) ; dcnl } dcnl public boolean is package exported to ( char [ ] qualified package name , module binding client ) { dcnl predicate < i package export > is exported = e - > char operation . prefix equals ( qualified package name , e . name ( ) ) ;
dcnl public boolean declares package ( package binding p ) { dcnl return declares package ( p . readable name ( ) ) ; dcnl } dcnl public boolean declares package ( char [ ] qualified package name ) { dcnl if ( this . name environment instanceof i module aware name environment ) { dcnl return ( ( i module aware name environment ) this . name environment ) . is package ( null , qualified package name , get module lookup context ( ) ) ; dcnl } dcnl return false ; dcnl } dcnl public boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) { dcnl boolean answer = false ; dcnl if ( this . name environment instanceof i module aware name environment ) { dcnl char [ ] qualified package name = char operation . concat with ( parent package name , package name , ' . ' ) ; dcnl answer = ( ( i module aware name environment ) this . name environment ) . is package ( parent package name , package name , get dependency closure context ( ) ) ; dcnl return answer & & can see ( qualified package name ) ; dcnl } else { dcnl answer = this . name environment . is package ( parent package name , package name ) ; dcnl } dcnl return answer ; dcnl }
* check if the given package is visible to this module . true when the package is declared in dcnl * this module or exported by some required module to this module . dcnl * see { @ link #is package exported to ( package binding , module binding ) } dcnl *
*
package binding = get package ( null , name , mod ) ; dcnl if ( package binding ! = null ) {
package binding get package ( char [ ] [ ] compound name , char [ ] name , char [ ] mod ) { dcnl char [ ] [ ] parent package name = ( compound name = = null | | compound name . length = = 0 ) ? null : compound name ;
package binding binding = null ;
binding = module . get package ( parent package name , name ) ;
if ( this . name environment . is package ( parent package name , name ) ) { dcnl binding = new package binding ( name , this ) ; dcnl }
import org . eclipse . jdt . internal . compiler . util . hashtable of package ;
public i package export [ ] exports ;
dcnl hashtable of package declared packages ; dcnl hashtable of package exported packages ;
this . exports = no exports ;
this . declared packages = new hashtable of package ( 0 ) ; dcnl this . exported packages = new hashtable of package ( 0 ) ;
this . exports = module . exports ( ) ; dcnl if ( this . exports = = null ) dcnl this . exports = no exports ;
this . declared packages = new hashtable of package ( 5 ) ; dcnl this . exported packages = new hashtable of package ( 5 ) ;
return stream . of ( this . exports ) . any match ( is exported ) ;
package binding resolved = get exported package ( pkg . readable name ( ) ) ; dcnl if ( resolved = = pkg ) { dcnl predicate < i package export > is targeted = e - > e . exported to ( ) ! = null ; dcnl predicate < i package export > is exported to = e - > dcnl stream . of ( e . exported to ( ) ) . map ( ref - > this . environment . get module ( ref ) ) . filter ( m - > m ! = null ) . any match ( client : : equals ) ; dcnl dcnl return stream . of ( this . exports ) . filter ( e - > char operation . equals ( pkg . readable name ( ) , e . name ( ) ) ) dcnl . any match ( is targeted . negate ( ) . or ( is exported to ) ) ; dcnl } dcnl return false ;
public package binding get top level package ( char [ ] name ) { dcnl / / return packagebinding if there exists a package named name in this module's context and it can be seen by this module dcnl / / a package can be seen by this module if it declares the package or someone exports tha package to it dcnl package binding existing = this . environment . get package0 ( name ) ; dcnl if ( existing ! = null ) { dcnl if ( existing = = lookup environment . the not found package ) dcnl return null ; dcnl } dcnl if ( declares package ( null , name ) ) { dcnl return new package binding ( name , this . environment ) ; dcnl } else { dcnl return stream . of ( get all required modules ( ) ) . sorted ( ( m1 , m2 ) - > m1 . requires . length - m2 . requires . length ) dcnl . map ( m - > { dcnl package binding binding = m . get exported package ( name ) ; dcnl if ( binding ! = null & & m . is package exported to ( binding , this ) ) { dcnl return m . declared packages . get ( name ) ; dcnl } dcnl return null ; dcnl } ) dcnl . filter ( p - > p ! = null ) . find first ( ) . or else ( null ) ; dcnl } dcnl } dcnl private package binding get declared package ( package binding parent , char [ ] name ) { dcnl package binding pkg = parent . get package0 ( name ) ; dcnl if ( pkg ! = null & & pkg ! = lookup environment . the not found package ) dcnl return pkg ; dcnl if ( declares package ( parent . compound name , name ) ) { dcnl char [ ] [ ] sub pkg compound name = char operation . array concat ( parent . compound name , name ) ; dcnl package binding binding = new package binding ( sub pkg compound name , parent , this . environment ) ; dcnl parent . add package ( binding ) ; dcnl this . declared packages . put ( binding . readable name ( ) , binding ) ; dcnl return binding ; dcnl } dcnl / / parent . add not found package ( name ) ; dcnl return null ; dcnl } dcnl public package binding get declared package ( char [ ] [ ] name ) { dcnl / / return packagebinding if there exists a package named name in this module's context and it can be seen by this module dcnl / / a package can be seen by this module if it declares the package or someone exports tha package to it dcnl package binding parent = null ; dcnl package binding existing = this . environment . get package0 ( name [ 0 ] ) ; dcnl if ( existing ! = null ) { dcnl if ( existing = = lookup environment . the not found package ) dcnl return null ; dcnl parent = existing ; dcnl } dcnl if ( parent = = null ) { dcnl if ( declares package ( null , name [ 0 ] ) ) { dcnl parent = new package binding ( name [ 0 ] , this . environment ) ; dcnl this . declared packages . put ( name [ 0 ] , parent ) ; dcnl } else { dcnl this . declared packages . put ( name [ 0 ] , lookup environment . the not found package ) ; dcnl } dcnl } dcnl if ( parent ! = null ) { dcnl for ( int i = 1 ; i < name . length ; i + + ) { dcnl package binding binding = get declared package ( parent , name [ i ] ) ; dcnl if ( binding = = null ) { dcnl return null ; dcnl } dcnl parent = binding ; dcnl } dcnl } dcnl return parent ; dcnl } dcnl public package binding get exported package ( char [ ] qualified package name ) { dcnl package binding existing = this . exported packages . get ( qualified package name ) ; dcnl if ( existing ! = null & & existing ! = lookup environment . the not found package ) dcnl return existing ; dcnl return stream . of ( this . exports ) . sorted ( ( e1 , e2 ) - > e1 . name ( ) . length - e2 . name ( ) . length ) dcnl . filter ( e - > char operation . prefix equals ( qualified package name , e . name ( ) ) ) dcnl . map ( e - > { dcnl package binding binding = get declared package ( char operation . split on ( ' . ' , e . name ( ) ) ) ; dcnl if ( binding ! = null ) { dcnl this . exported packages . put ( e . name ( ) , binding ) ; dcnl return binding ; dcnl } dcnl return null ; dcnl } ) . filter ( p - > p ! = null ) . find first ( ) . or else ( null ) ;
return this . declared packages . get ( p . readable name ( ) ) = = p ;
public boolean declares package ( char [ ] [ ] parent package name , char [ ] name ) { dcnl char [ ] qualified name = char operation . concat with ( parent package name , name , ' . ' ) ; dcnl package binding declared = this . declared packages . get ( qualified name ) ; dcnl if ( declared ! = null ) { dcnl if ( declared = = lookup environment . the not found package ) dcnl return false ; dcnl else dcnl return true ; dcnl }
return ( ( i module aware name environment ) this . name environment ) . is package ( parent package name , name , get module lookup context ( ) ) ;
public package binding get package ( char [ ] [ ] parent package name , char [ ] package name ) { dcnl package binding binding = null ; dcnl if ( parent package name = = null | | parent package name . length = = 0 ) { dcnl binding = get top level package ( char operation . concat with ( parent package name , package name , ' . ' ) ) ;
binding = get declared package ( parent package name ) ; dcnl } dcnl if ( binding ! = null & & binding ! = lookup environment . the not found package ) { dcnl binding = get declared package ( binding , package name ) ; dcnl if ( binding ! = null ) dcnl return binding ;
if ( binding = = null ) { dcnl char [ ] qualified package name = char operation . concat with ( parent package name , package name , ' . ' ) ; dcnl return stream . of ( get all required modules ( ) ) . sorted ( ( m1 , m2 ) - > m1 . requires . length - m2 . requires . length ) dcnl . map ( m - > { dcnl package binding p = m . get exported package ( qualified package name ) ; dcnl if ( p ! = null & & m . is package exported to ( p , this ) ) { dcnl return p ; dcnl } dcnl return null ; dcnl } ) dcnl . filter ( p - > p ! = null ) . find first ( ) . or else ( null ) ; dcnl } dcnl return binding ;
return declares package ( pkg ) | | stream . of ( get all required modules ( ) ) . any match ( dep - > dep . is package exported to ( pkg , this ) ) ;
return get module lookup context ( ) . include all ( stream . of ( deps ) . map ( m - > m . get module lookup context ( ) ) ) ;
/ * private * / void add not found package ( char [ ] simple name ) {
module binding module = this . environment . get module ( mod ) ; dcnl package binding sub = module . get package ( this . compound name , name ) ; dcnl if ( sub = = null )
public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name , boolean as binary only ) {
compilation unit . module = this . module = = null ? null : this . module . name ( ) ;
string qualified type name = new string ( char operation . concat with ( package name , type name , ' / ' ) ) ; dcnl name environment answer answer = internal find class ( qualified type name , type name , false , module lookup context ) ; dcnl if ( this . annotations from classpath & & answer ! = null & & answer . get binary type ( ) instanceof class file reader ) { dcnl for ( int i = 0 , length = this . classpaths . length ; i < length ; i + + ) { dcnl classpath classpath entry = this . classpaths [ i ] ; dcnl if ( classpath entry . has annotation file for ( qualified type name ) ) { dcnl zip file zip = classpath entry instanceof classpath jar ? ( ( classpath jar ) classpath entry ) . zip file : null ; dcnl try { dcnl ( ( class file reader ) answer . get binary type ( ) ) . set external annotation provider ( classpath entry . get path ( ) , qualified type name , zip , null ) ; dcnl break ; dcnl } catch ( io exception e ) { dcnl / / ignore broken entry , keep searching
} else { dcnl return this . name environment . is package ( parent package name , name ) ;
binding = get top level package ( package name ) ;
if ( binding ! = null & & binding ! = lookup environment . the not found package ) { dcnl binding = get declared package ( binding , package name ) ; dcnl if ( binding ! = null ) dcnl return binding ; dcnl }
return stream . of ( get all required modules ( ) )
import org . eclipse . jdt . internal . compiler . env . i module ; dcnl import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module path entry ;
class jar package fragment root info extends package fragment root info implements i module path entry {
import java . util . optional ;
import org . eclipse . jdt . internal . compiler . env . i multi module package lookup ;
public class jrt package fragment root extends jar package fragment root implements i multi module package lookup {
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module path entry ;
public i module path entry entry ;
import org . eclipse . jdt . internal . compiler . env . i module path entry ;
private map < string , i module path entry > known modules = new hash map < string , i module path entry > ( 11 ) ;
private i module path entry get module root0 ( string name ) {
public i module path entry get module root ( string name ) { dcnl i module path entry root = get module root0 ( name ) ;
this . known modules . put ( char operation . char to string ( name ) , new project entry ( ( java project ) project ) ) ;
i module path entry root = get module root0 ( char operation . char to string ( name ) ) ;
/ / try {
/ / } catch ( java model exception e1 ) { dcnl / / / / dcnl / / return null ; dcnl / / }
for ( i module path entry val : this . known modules . values ( ) ) { dcnl / / try {
import org . eclipse . jdt . internal . compiler . env . i module aware name environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module context ;
implements i module aware name environment , i java search constants {
protected name environment answer find ( string type name , string package name , i module context context ) {
public name environment answer find type ( char [ ] [ ] compound type name , i module context context ) {
return find ( new string ( compound type name [ 0 ] ) , null , context ) ;
char operation . to string ( package name ) , context ) ;
public name environment answer find type ( char [ ] name , char [ ] [ ] package name , i module context context ) {
package name = = null | | package name . length = = 0 ? null : char operation . to string ( package name ) , context ) ;
public boolean is package ( char [ ] [ ] parent package name , char [ ] sub package name , i module context module context ) {
import org . eclipse . jdt . internal . compiler . classfmt . module info ;
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module location ;
import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class classpath directory extends classpath location implements i module environment {
if ( name . equals ignore case ( i module location . module info class ) ) {
if ( name . equals ignore case ( i module location . module info class ) ) {
if ( this . module instanceof module info ) { dcnl ( ( module info ) this . module ) . entry = this ; dcnl }
public name environment answer find class ( string binary file name , string qualified package name , string qualified binary file name , boolean as binary only ) {
/ / @ override
public i module get module ( ) {
import org . eclipse . jdt . internal . compiler . classfmt . module info ;
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module location ;
import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class classpath jar extends classpath location implements i module environment {
if ( class name . equals ignore case ( i module location . module info class ) ) {
if ( this . module instanceof module info ) { dcnl ( ( module info ) this . module ) . entry = this ; dcnl }
public name environment answer find class ( string binary file name , string qualified package name , string qualified binary file name , boolean as binary only ) {
public i module get module ( ) { dcnl / / dcnl return this . module ;
public i module environment get lookup environment ( ) { dcnl / / dcnl return this ; dcnl } dcnl dcnl @ override dcnl public type lookup type lookup ( ) {
import java . util . collection ;
import java . util . optional ;
import java . util . function . function ;
import org . eclipse . jdt . internal . compiler . classfmt . module info ;
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module location ; dcnl import org . eclipse . jdt . internal . compiler . env . i multi module entry ; dcnl import org . eclipse . jdt . internal . compiler . env . i multi module package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . i multi module type lookup ;
import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class classpath jrt extends classpath location implements i multi module entry , i module environment {
/ / private hash map < string , simple set > packages in module = null ;
dcnl protected function < char [ ] , type lookup > type lookup for module = mod name - > dcnl ( type name , qualified package name , qualified binary file name , as binary only ) - > { dcnl return type lookup ( ) . find class ( type name , qualified package name , qualified binary file name , as binary only , mod name ) ; dcnl } ; dcnl dcnl protected function < char [ ] , package lookup > pkg lookup for module = mod name - > dcnl qualified package name - > { dcnl return package lookup ( ) . is package ( qualified package name , mod name ) ; dcnl } ; dcnl
jrt . accept module ( jrt util . get classfile content ( image file , i module location . module info class , name ) ) ;
jrt . accept module ( jrt util . get classfile content ( image file , i module location . module info class , mod . to string ( ) ) ) ;
reader = new class file reader ( content , i module location . module info class . to char array ( ) , null ) ;
if ( module decl instanceof module info ) { dcnl ( ( module info ) module decl ) . entry = this ; dcnl }
private name environment answer find class ( string binary file name , string qualified package name , string qualified binary file name , boolean as binary only , optional < collection < char [ ] > > module names ) {
class file reader reader = class file reader . read from modules ( new file ( this . zip filename ) , qualified binary file name , module names ) ;
@ override
/ / dcnl return is package ( qualified package name , optional . empty ( ) ) ; dcnl } dcnl public boolean is package ( string qualified package name , optional < char [ ] > module name ) { dcnl / / try { dcnl / / synchronized ( this ) { dcnl / / if ( this . packages in module = = null ) { dcnl / / this . packages in module = find packages in modules ( this ) ; dcnl / / } dcnl / / } dcnl / / } catch ( exception e ) { dcnl / / / / todo beta java9 dcnl / / } dcnl / / if ( module name . is present ( ) ) { dcnl / / simple set set = this . packages in module . get ( module name . get ( ) ) ; dcnl / / return set ! = null & & set . includes ( qualified package name ) ; dcnl / / } dcnl / / set < string > key set = this . packages in module . key set ( ) ; dcnl / / for ( string string : key set ) { dcnl / / simple set set = this . packages in module . get ( string ) ; dcnl / / if ( set . includes ( qualified package name ) ) return true ; dcnl / / } dcnl / / dcnl / / return false ; dcnl return jrt util . is package ( new file ( this . zip filename ) , qualified package name , module name ) ;
public name environment answer find class ( char [ ] type name , string qualified package name , string qualified binary file name , boolean as binary only , optional < collection < char [ ] > > module names ) { dcnl string file name = new string ( type name ) ; dcnl return find class ( file name , qualified package name , qualified binary file name , as binary only , optional . empty ( ) ) ;
import org . eclipse . jdt . internal . compiler . env . i module path entry ;
import org . eclipse . jdt . internal . compiler . env . name environment answer ;
public abstract class classpath location implements i module path entry {
import org . eclipse . jdt . internal . compiler . util . util ;
import java . util . stream . stream ;
private name environment answer find class ( string qualified type name , char [ ] type name , i module context module context ) {
string q package name = ( qualified type name . length ( ) = = type name . length ) ? util . empty string : dcnl q binary file name . substring ( 0 , q binary file name . length ( ) - type name . length - 7 ) ;
/ / name environment answer suggested answer = null ; dcnl / / for ( int i = 0 , l = this . binary locations . length ; i < l ; i + + ) { dcnl / / name environment answer answer = null ; dcnl / / for ( i module i module : modules ) { dcnl / / if ( !this . binary locations [ i ] . serves module ( i module ) ) continue ; dcnl / / answer = this . binary locations [ i ] . find class ( binary file name , q package name , q binary file name , i module ) ; dcnl / / if ( answer ! = null ) { dcnl / / if ( !answer . ignore if better ( ) ) { dcnl / / if ( answer . is better ( suggested answer ) ) dcnl / / return answer ; dcnl / / } else if ( answer . is better ( suggested answer ) ) dcnl / / / / remember suggestion and keep looking dcnl / / suggested answer = answer ; dcnl / / } dcnl / / } dcnl / / } dcnl / / if ( suggested answer ! = null ) dcnl / / / / no better answer was found dcnl / / return suggested answer ; dcnl / / return null ; dcnl if ( i module context . unnamed module context = = module context ) { dcnl return stream . of ( this . binary locations ) dcnl . map ( p - > p . get lookup environment ( ) . type lookup ( ) ) dcnl . reduce ( type lookup : : chain ) dcnl . map ( t - > t . find class ( type name , q package name , q binary file name ) ) . or else ( null ) ;
return module context . get environment ( ) . map ( env - > env . type lookup ( ) ) dcnl . reduce ( type lookup : : chain ) dcnl . map ( lookup - > lookup . find class ( type name , q package name , q binary file name ) ) dcnl . or else ( null ) ;
public name environment answer find type ( char [ ] [ ] compound name ) {
compound name [ compound name . length - 1 ] , i module context . unnamed module context ) ;
public name environment answer find type ( char [ ] [ ] compound name , i module context context ) { dcnl if ( compound name ! = null ) dcnl return find class ( dcnl new string ( char operation . concat with ( compound name , ' / ' ) ) , dcnl compound name [ compound name . length - 1 ] , context ) ; dcnl return null ; dcnl } dcnl public name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) {
type name , i module context . unnamed module context ) ;
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , i module context context ) { dcnl if ( type name ! = null ) dcnl return find class ( dcnl new string ( char operation . concat with ( package name , type name , ' / ' ) ) , dcnl type name , context ) ; dcnl return null ; dcnl } dcnl public boolean is package ( char [ ] [ ] compound name , char [ ] package name , i module context module context ) { dcnl return is package ( new string ( char operation . concat with ( compound name , package name , ' / ' ) ) , module context ) ;
public boolean is package ( string qualified package name , i module context module context ) { dcnl / / if ( modules = = null ) { dcnl / / for ( int i = 0 , l = this . binary locations . length ; i < l ; i + + ) { dcnl / / / / todo : beta java9 should really check with the module context . dcnl / / if ( this . binary locations [ i ] . is package ( qualified package name ) ) dcnl / / return true ; dcnl / / } dcnl / / } else { dcnl / / / / note : the output folders are added at the beginning of the binary locations dcnl / / for ( int i = 0 , l = this . binary locations . length ; i < l ; i + + ) { dcnl / / for ( i module i module : modules ) { dcnl / / if ( this . binary locations [ i ] . serves module ( i module ) ) { dcnl / / / / todo : beta java9 should really check with the module context . dcnl / / if ( this . binary locations [ i ] . is package ( qualified package name ) ) dcnl / / return true ; dcnl / / } dcnl / / } dcnl / / } dcnl / / } dcnl if ( module context = = i module context . unnamed module context ) { dcnl return stream . of ( this . binary locations ) . map ( p - > p . get lookup environment ( ) . package lookup ( ) ) . filter ( l - > l . is package ( qualified package name ) ) . find any ( ) . is present ( ) ;
import org . eclipse . jdt . internal . compiler . env . i module context ;
public name environment answer find type ( char [ ] [ ] compound type name , i module context context ) { dcnl name environment answer answer = super . find type ( compound type name , context ) ;
public name environment answer find type ( char [ ] type name , char [ ] [ ] package name , i module context context ) { dcnl name environment answer answer = super . find type ( type name , package name , context ) ;
import org . eclipse . jdt . internal . compiler . env . i module environment ;
import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class classpath source directory extends classpath location implements i module environment {
public name environment answer find class ( string type name , string qualified package name , string qualified binary file name , boolean as binary only ) { dcnl return find class ( type name , qualified package name , qualified binary file name ) ;
public name environment answer find class ( string source file without extension , string qualified package name , string qualified source file without extension ) {
this . module = = null ? null : this . module . name ( ) ) , null / * no access restriction * / ) ;
public i module get module ( ) { dcnl / / dcnl return this . module ;
public i module environment get lookup environment ( ) {
q source file name ) ; / / doesn't include the file extension
/ / return package binding if there exists a package named name in this module's context and it can be seen by this module dcnl / / a package can be seen by this module if it declares the package or someone exports that package to it
/ / given parent is declared in this module , see if there is sub package named name declared in this module
/ / return package binding if there exists a package named name in this module
package binding existing = this . environment . get package0 ( name [ 0 ] ) ; dcnl if ( existing ! = null ) { / / known top level package
if ( declares package ( null , name [ 0 ] ) ) { / / unknown as yet , but declared in this module
this . declared packages . put ( name [ 0 ] , lookup environment . the not found package ) ; / / not declared in this module dcnl return null ;
} else if ( !declares package ( null , name [ 0 ] ) ) { / / already seen before , but not declared in this module dcnl return null ;
/ / check each sub package dcnl for ( int i = 1 ; i < name . length ; i + + ) { dcnl package binding binding = get declared package ( parent , name [ i ] ) ; dcnl if ( binding = = null ) { dcnl return null ;
parent = binding ;
/ / resolve exports to see if the package or a sub package is exported
. filter ( e - > char operation . prefix equals ( qualified package name , e . name ( ) ) ) / / todo : improve this
package binding pkg = this . declared packages . get ( p . readable name ( ) ) ; dcnl if ( pkg = = null ) { dcnl pkg = get declared package ( p . compound name ) ; dcnl if ( pkg = = p ) { dcnl this . declared packages . put ( p . readable name ( ) , p ) ; dcnl return true ; dcnl } dcnl } dcnl return pkg = = p ;
import org . eclipse . jdt . internal . compiler . env . i module ; dcnl import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module path entry ; dcnl import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
public class jrt package fragment root extends jar package fragment root implements i module path entry , i module environment {
import org . eclipse . jdt . internal . compiler . env . i module path entry ;
import java . util . stream . stream ;
import org . eclipse . jdt . internal . compiler . env . i module context ;
public answer find type ( string type name , string package name , boolean partial match , int accept flags , boolean check restrictions , i module context context ) {
if ( context ! = i module context . unnamed module context ) { dcnl / / for ( i module module : modules ) { dcnl suggested answer = find type ( type name , package name , partial match , accept flags ,
null , context ) ; dcnl / / if ( answer ! = null ) { dcnl / / if ( !answer . ignore if better ( ) ) { dcnl / / if ( answer . is better ( suggested answer ) ) dcnl / / return answer ; dcnl / / } else if ( answer . is better ( suggested answer ) ) dcnl / / / / remember suggestion and keep looking dcnl / / suggested answer = answer ; dcnl / / } dcnl / / } dcnl
monitor , dcnl i module context . unnamed module context ) ;
i progress monitor monitor , dcnl i module context context ) {
seek package fragments ( package name , false , element requestor , context ) ;
public void seek package fragments ( string name , boolean partial match , i java element requestor requestor , i module context context ) { dcnl context . get environment ( ) . < package fragment root > flat map ( e - > { dcnl if ( e instanceof project entry ) { dcnl java project prj = ( ( project entry ) e ) . project ; dcnl list < i package fragment root > children ; dcnl try { dcnl children = prj . get children of type ( i java element . package fragment root ) ; dcnl return children . stream ( ) . filter ( r - > { dcnl try { dcnl return r . get kind ( ) = = i package fragment root . k source ; dcnl } catch ( java model exception e1 ) { dcnl / / todo auto - generated catch block dcnl e1 . print stack trace ( ) ; dcnl } dcnl return false ; dcnl } ) . map ( r - > ( package fragment root ) r ) ; dcnl } catch ( java model exception e1 ) { dcnl / / todo auto - generated catch block dcnl e1 . print stack trace ( ) ; dcnl } dcnl return stream . empty ( ) ; dcnl } else { dcnl return stream . of ( ( jrt package fragment root ) e ) ; dcnl } dcnl } ) . for each ( r - > { dcnl i package fragment pkg = r . get package fragment ( name ) ; dcnl if ( pkg ! = null ) { dcnl requestor . accept package fragment ( pkg ) ; dcnl } dcnl } ) ; dcnl
public void seek package fragments ( string name , boolean partial match , i java element requestor requestor ) {
requestor . accept package fragment ( root . get package fragment ( pkg name ) ) ;
requestor . accept package fragment ( root . get package fragment ( pkg name ) ) ;
requestor . accept package fragment ( root . get package fragment ( pkg name ) ) ;
import org . eclipse . jdt . internal . compiler . classfmt . module info ;
/ / dcnl return type lookup . dummy ;
char [ ] binary file name = char operation . concat ( type name , suffix class ) ;
. map ( t - > t . find class ( binary file name , q package name , q binary file name ) ) . or else ( null ) ;
/ / mods : for ( i module i module : modules ) {
/ / if ( answer ! = null ) break mods ; dcnl / / }
/ / mods : for ( i module i module : modules ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 11 . 0 . qualifier
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 4 . 0 . qualifier
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 1 . 2 . 0 . qualifier
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 9 . 0 . qualifier
icon = "$nl$ / icons / view . png"
dcnl
* all rights reserved . this program and the accompanying materials
*
public static final string collapse = "collapseall . png" ; / / $non - nls - 1$ dcnl public static final string expand = "expandall . png" ; / / $non - nls - 1$ dcnl public static final string link with editor = "synced . png" ; / / $non - nls - 1$ dcnl dcnl public static final string setfocus = "setfocus . png" ; / / $non - nls - 1$ dcnl public static final string refresh = "refresh . png" ; / / $non - nls - 1$ dcnl public static final string clear = "clear . png" ; / / $non - nls - 1$ dcnl dcnl public static final string add to tray = "add . png" ; / / $non - nls - 1$
dcnl id = create ( "e" , type ) ; / / $non - nls - 1$
icon = "icons / view . png"
dcnl
public static final string properties = "properties . png" ; dcnl public static final string refresh = "refresh . png" ; dcnl public static final string set focus = "setfocus . png" ; dcnl public static final string code select = "code select . png" ; dcnl
public static final string img objs refactoring fatal = name prefix + "fatalerror obj . png" ; / / $non - nls - 1$ dcnl public static final string img objs refactoring error = name prefix + "error obj . png" ; / / $non - nls - 1$ dcnl public static final string img objs refactoring warning = name prefix + "warning obj . png" ; / / $non - nls - 1$ dcnl public static final string img objs refactoring info = name prefix + "info obj . png" ; / / $non - nls - 1$
public static final string img objs refactoring date = name prefix + "date obj . png" ; / / $non - nls - 1$
public static final string img objs refactoring time = name prefix + "time obj . png" ; / / $non - nls - 1$
public static final image descriptor desc elcl filter = create un managed ( t elcl , "filter ps . png" ) ; / / $non - nls - 1$ dcnl public static final image descriptor desc dlcl filter = create un managed ( t dlcl , "filter ps . png" ) ; / / $non - nls - 1$
public static final image descriptor desc elcl sort project = create un managed ( t elcl , "prj mode . png" ) ; / / $non - nls - 1$
public static final image descriptor desc dlcl sort project = create un managed ( t dlcl , "prj mode . png" ) ; / / $non - nls - 1$
public static final image descriptor desc elcl sort date = create un managed ( t elcl , "date mode . png" ) ; / / $non - nls - 1$
public static final image descriptor desc dlcl sort date = create un managed ( t dlcl , "date mode . png" ) ; / / $non - nls - 1$
public static final image descriptor desc objs refactoring date = create un managed ( t obj , "date obj . png" ) ; / / $non - nls - 1$
public static final image descriptor desc objs refactoring time = create un managed ( t obj , "time obj . png" ) ; / / $non - nls - 1$
public static final image descriptor desc objs refactoring = create un managed ( t obj , "refactoring obj . png" ) ; / / $non - nls - 1$
public static final image descriptor desc objs refactoring coll = create un managed ( t obj , "refactorings obj . png" ) ; / / $non - nls - 1$
public static final image descriptor desc ovr workspace = create un managed ( t ovr , "workspace ovr . png" ) ; / / $non - nls - 1$
import org . eclipse . jdt . internal . compiler . env . i module declaration ;
i module declaration module decl = reader . get module declaration ( ) ;
this . module = new binary module ( this , reader ) ;
import org . eclipse . jdt . internal . compiler . env . i module declaration . i package export ;
src . get declaration ( ) . add reads ( target . to char array ( ) ) ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ; dcnl import org . eclipse . jdt . internal . compiler . env . i module declaration . i package export ;
mod = new binary module ( null , reader ) ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ; dcnl import org . eclipse . jdt . internal . compiler . env . i module declaration . i package export ;
protected static i module declaration extract addon export ( string option ) {
static class module implements i module declaration {
i module declaration module = get module ( reader ) ; dcnl if ( module ! = null ) { dcnl return new binary module ( path entry , reader ) ;
return null ;
i module declaration module = get module ( reader ) ;
return new binary module ( path entry , reader ) ;
return null ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ;
public class source module implements i module , i module declaration { dcnl static class module reference impl implements i module declaration . i module reference {
if ( ! ( o instanceof i module declaration . i module reference ) )
i module declaration . i module reference mod = ( i module declaration . i module reference ) o ;
static class package export implements i module declaration . i package export {
static class service implements i module declaration . i service {
public i module declaration . i module reference [ ] requires ( ) {
public i module declaration . i package export [ ] exports ( ) {
public void add exports ( i module declaration . i package export [ ] to add ) {
return arrays . equals ( this . requires , mod . get declaration ( ) . requires ( ) ) ;
private i module declaration module declaration ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ;
public class module info extends class file struct implements i module declaration {
i module declaration . i service [ ] provides ;
public i module declaration . i module reference [ ] requires ( ) {
public i module declaration . i package export [ ] exports ( ) {
class module reference info implements i module declaration . i module reference {
if ( ! ( o instanceof i module declaration . i module reference ) )
i module declaration . i module reference mod = ( i module declaration . i module reference ) o ;
class package export info implements i module declaration . i package export {
class service info implements i module declaration . i service {
if ( ! ( o instanceof i module declaration ) )
public i module declaration get declaration ( ) ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ; dcnl import org . eclipse . jdt . internal . compiler . env . i module declaration . i module reference ; dcnl import org . eclipse . jdt . internal . compiler . env . i module declaration . i package export ;
i module declaration decl = module . get declaration ( ) ; dcnl this . requires = decl . requires ( ) ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ; dcnl import org . eclipse . jdt . internal . compiler . env . i module environment ;
public static final char [ ] unnamed = "" . to char array ( ) ; / / $non - nls - 1$
public string to string ( ) { dcnl return new string ( unnamed ) ;
/ /
public i module declaration get declaration ( ) { dcnl / / todo auto - generated method stub
public i module environment get lookup environment ( ) { dcnl / / todo auto - generated method stub dcnl return null ;
i module declaration . i package export [ ] exports = module . get declaration ( ) . exports ( ) ;
for ( i module declaration . i package export i package export : exports ) {
i module declaration . i module reference [ ] requires = module . get declaration ( ) . requires ( ) ;
/ / org . eclipse . jdt . internal . compiler . env . i module declaration module info = ( ( class file reader ) type info ) . get module declaration ( ) ;
import org . eclipse . jdt . internal . compiler . env . i module ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ;
public class module info extends source type element info implements i module declaration {
static class module reference impl implements i module declaration . i module reference {
static class package export implements i module declaration . i package export {
static class service implements i module declaration . i service {
import org . eclipse . jdt . internal . compiler . env . i module declaration . i module reference ;
this . known modules . put ( char operation . char to string ( name ) , ( ( module ) module ) . entry ) ;
try {
} catch ( exception e1 ) { dcnl / / dcnl return null ; dcnl }
/ /
try {
if ( context = = i module context . unnamed module context ) { dcnl seek package fragments ( name , partial match , requestor ) ; dcnl return ; dcnl } dcnl string [ ] splitted name = util . split on ( ' . ' , name , 0 , name . length ( ) ) ; dcnl int pkg index = this . package fragments . get index ( splitted name ) ; dcnl if ( pkg index = = - 1 ) dcnl return ; dcnl object value = this . package fragments . value table [ pkg index ] ; dcnl / / reuse existing string [ ] dcnl string [ ] pkg name = ( string [ ] ) this . package fragments . key table [ pkg index ] ;
i type type = unit . get type ( new string ( type constants . module info name ) ) ; dcnl module info decl = ( module info ) ( ( source type ) type ) . get element info ( ) ; dcnl if ( decl ! = null ) { dcnl java project prj = ( java project ) this . get ancestor ( i java element . java project ) ; dcnl module = new module ( new project entry ( prj ) , decl ) ; dcnl root info . set module ( module ) ; dcnl return module ; dcnl } dcnl / / info = ( compilation unit element info ) ( ( compilation unit ) unit ) dcnl / / . get element info ( ) ; dcnl / / if ( info ! = null ) dcnl / / return info . get module ( ) ;
import org . eclipse . jdt . internal . core . module ;
import org . eclipse . jdt . internal . core . module ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ;
import org . eclipse . jdt . internal . core . module ;
i module declaration module decl = reader . get module declaration ( ) ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ;
import org . eclipse . jdt . internal . core . module ;
import org . eclipse . jdt . internal . compiler . env . i module declaration ; dcnl import org . eclipse . jdt . internal . compiler . env . i module declaration . i module reference ; dcnl import org . eclipse . jdt . internal . compiler . env . i module declaration . i package export ; dcnl import org . eclipse . jdt . internal . compiler . env . i module declaration . i service ;
i module declaration module = reader . get module declaration ( ) ;
private color f foreground color ; dcnl private rgb f foreground color rgb ; dcnl
color fg color ; dcnl f foreground color rgb = ( get foreground color key ( ) ! = null ) ? registry . get rgb ( get foreground color key ( ) ) : null ; dcnl if ( f foreground color rgb = = null ) { dcnl fg color = display . get system color ( swt . color info foreground ) ; dcnl f foreground color rgb = fg color . get rgb ( ) ; dcnl } else { dcnl fg color = new color ( display , f foreground color rgb ) ; dcnl f foreground color = fg color ; dcnl } dcnl set foreground ( fg color ) ; dcnl
/ * * dcnl * the preference key for the foreground color . dcnl * dcnl * @ return the foreground color key or < code > null < / code > if none dcnl * / dcnl protected string get foreground color key ( ) { dcnl return null ; dcnl } dcnl
string property = event . get property ( ) ; dcnl if ( property . equals ( get background color key ( ) ) dcnl | | property . equals ( get foreground color key ( ) ) ) {
} dcnl
private rgb f foreground color rgb ;
f foreground color rgb = color . get rgb ( ) ; dcnl refresh ( ) ;
@ override dcnl protected string get foreground color key ( ) { dcnl return "org . eclipse . jdt . ui . javadoc view . foreground color" ; / / $non - nls - 1$ dcnl } dcnl
html printer . insert page prolog ( buffer , 0 , f foreground color rgb , f background color rgb , fg style sheet ) ;
icon = "$nl$ / icons / full / eview16 / junit . png"
icon = "$nl$ / icons / full / obj16 / julaunch . png"
icon = "$nl$ / icons / full / etool16 / new testcase . png"
icon = "$nl$ / icons / full / etool16 / new testsuite . png"
icon = "$nl$ / icons / full / obj16 / julaunch . png"
< marker resolution generator
< / command >
icon = "$nl$ / icons / full / obj16 / testfile obj . png"
private final image f exception icon = j unit plugin . create image ( "obj16 / exc catch . png" ) ; / / $non - nls - 1$
final image descriptor f suite icon descriptor = j unit plugin . get image descriptor ( "obj16 / tsuite . png" ) ; / / $non - nls - 1$ dcnl final image descriptor f suite ok icon descriptor = j unit plugin . get image descriptor ( "obj16 / tsuiteok . png" ) ; / / $non - nls - 1$ dcnl final image descriptor f suite error icon descriptor = j unit plugin . get image descriptor ( "obj16 / tsuiteerror . png" ) ; / / $non - nls - 1$ dcnl final image descriptor f suite fail icon descriptor = j unit plugin . get image descriptor ( "obj16 / tsuitefail . png" ) ; / / $non - nls - 1$ dcnl final image descriptor f suite running icon descriptor = j unit plugin . get image descriptor ( "obj16 / tsuiterun . png" ) ; / / $non - nls - 1$
j unit plugin . set local image descriptors ( action , "history list . png" ) ; / / $non - nls - 1$
j unit plugin . set local image descriptors ( this , "stop . png" ) ; / / $non - nls - 1$
j unit plugin . set local image descriptors ( this , "relaunch . png" ) ; / / $non - nls - 1$
j unit plugin . set local image descriptors ( this , "relaunchf . png" ) ; / / $non - nls - 1$
set image descriptor ( j unit plugin . get image descriptor ( "elcl16 / th horizontal . png" ) ) ; / / $non - nls - 1$
set image descriptor ( j unit plugin . get image descriptor ( "elcl16 / th vertical . png" ) ) ; / / $non - nls - 1$
set image descriptor ( j unit plugin . get image descriptor ( "elcl16 / th automatic . png" ) ) ; / / $non - nls - 1$
set image descriptor ( j unit plugin . get image descriptor ( "obj16 / failures . png" ) ) ; / / $non - nls - 1$
set image descriptor ( j unit plugin . get image descriptor ( "obj16 / testignored . png" ) ) ; / / $non - nls - 1$
set image descriptor ( j unit plugin . get image descriptor ( "elcl16 / hierarchical layout . png" ) ) ; / / $non - nls - 1$
/ / set image descriptor ( j unit plugin . get image descriptor ( "obj16 / failures . png" ) ) ; / / $non - nls - 1$
f stack view icon = create managed image ( "eview16 / stackframe . png" ) ; / / $non - nls - 1$ dcnl f test run ok icon = create managed image ( "eview16 / junitsucc . png" ) ; / / $non - nls - 1$ dcnl f test run fail icon = create managed image ( "eview16 / juniterr . png" ) ; / / $non - nls - 1$ dcnl f test run ok dirty icon = create managed image ( "eview16 / junitsuccq . png" ) ; / / $non - nls - 1$ dcnl f test run fail dirty icon = create managed image ( "eview16 / juniterrq . png" ) ; / / $non - nls - 1$
f test icon = create managed image ( "obj16 / test . png" ) ; / / $non - nls - 1$ dcnl f test ok icon = create managed image ( "obj16 / testok . png" ) ; / / $non - nls - 1$ dcnl f test error icon = create managed image ( "obj16 / testerr . png" ) ; / / $non - nls - 1$ dcnl f test fail icon = create managed image ( "obj16 / testfail . png" ) ; / / $non - nls - 1$ dcnl f test running icon = create managed image ( "obj16 / testrun . png" ) ; / / $non - nls - 1$ dcnl f test ignored icon = create managed image ( "obj16 / testignored . png" ) ; / / $non - nls - 1$ dcnl f test assumption failure icon = create managed image ( "obj16 / testassumptionfailed . png" ) ; / / $non - nls - 1$
private final image f test icon = create image ( "obj16 / test . png" ) ; / / $non - nls - 1$
if ( pos ! = - 1 )
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . package lookup ; dcnl import org . eclipse . jdt . internal . compiler . env . type lookup ;
implements i java project , i project nature , i module environment , suffix constants {
/ / no direct way to lookup , use the java model ap is instead
import org . eclipse . jdt . core . i java element ; dcnl import org . eclipse . jdt . core . i type ; dcnl import org . eclipse . jdt . core . java model exception ; dcnl import org . eclipse . jdt . core . compiler . char operation ; dcnl import org . eclipse . jdt . internal . compiler . classfmt . class file reader ;
public class file binary decl ; dcnl public i module declaration declaration = null ; dcnl public boolean is binary = false ; dcnl public source type source decl ;
public module ( source type source decl ) { dcnl this . source decl = source decl ; dcnl } dcnl public module ( class file binary decl ) { dcnl this . binary decl = binary decl ; dcnl this . is binary = true ;
i module declaration decl = get declaration ( ) ; dcnl return decl = = null ? char operation . no char : decl . name ( ) ;
if ( this . declaration = = null ) { dcnl try { dcnl if ( this . is binary ) { dcnl i type type = this . binary decl . get type ( ) ; dcnl this . declaration = ( ( class file reader ) ( ( ( binary type ) type ) . get element info ( ) ) ) . get module declaration ( ) ; dcnl } else { dcnl this . declaration = ( module info ) this . source decl . get element info ( ) ; dcnl } dcnl } catch ( java model exception e ) { dcnl / / do nothing dcnl } dcnl }
/ / todo : this should refer to the module source path manager to map this module to dcnl / / an i moduele path entry dcnl if ( this . is binary ) { dcnl package fragment root root = ( package fragment root ) this . binary decl dcnl . get ancestor ( i java element . package fragment root ) ; dcnl if ( root instanceof jrt package fragment root ) dcnl return ( jrt package fragment root ) root ; dcnl } else { dcnl return ( java project ) this . source decl . get ancestor ( i java element . java project ) ;
public void add entry ( i module module , java project project ) throws java model exception { dcnl string module name = new string ( module . name ( ) ) ; dcnl i module path entry entry = get module root0 ( module name ) ; dcnl if ( entry ! = null ) { dcnl / / todo : should we signal error via java model exception dcnl return ; dcnl } dcnl this . known modules . put ( module name , new project entry ( project ) ) ; dcnl }
context . get environment ( ) . for each ( r - > {
object to compare = value ; dcnl if ( r instanceof java project ) { dcnl to compare = ( ( package fragment root ) value ) . get java project ( ) ; dcnl } dcnl if ( value . equals ( to compare ) ) {
if ( type ! = null ) { dcnl root info . set module ( module = new module ( ( source type ) type ) ) ;
root info . set module ( module = new module ( ( class file ) class file ) ) ;
/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * dcnl * copyright ( c ) 2016 ibm corporation . dcnl * all rights reserved . this program and the accompanying materials dcnl * are made available under the terms of the eclipse public license v1 . 0 dcnl * which accompanies this distribution , and is available at dcnl * http : / / www . eclipse . org / legal / epl - v10 . html dcnl * dcnl * this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl * dcnl * contributors : dcnl * ibm corporation - initial api and implementation dcnl * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /
import java . nio . file . files ; dcnl import java . nio . file . paths ;
import java . util . optional ; dcnl import java . util . stream . stream ;
private static final string release file = "release" ; / / $non - nls - 1$ dcnl private static final string java version = "java version" ; / / $non - nls - 1$
string version = read release version ( java home ) ; dcnl if ( java core . compare java versions ( version , java core . version 1 8 ) > 0 ) { dcnl info = new library info ( version , new string [ 0 ] , new string [ 0 ] , new string [ 0 ] ) ;
info = generate library info ( java home , java executable ) ; dcnl if ( info = = null ) { dcnl info = get default library info ( java home ) ; dcnl fg failed install path . put ( install path , info ) ; dcnl } else { dcnl / / only persist if we were able to generate information - see bug 70011 dcnl launching plugin . set library info ( install path , info ) ; dcnl }
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 1 . 3 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 1 . 8 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 1 . 3 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 9 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 10 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 13 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 13 . 0 . qualifier
* copyright ( c ) 2000 , 2016 ibm corporation and others .
list < i adaptable > to rename = new array list < > ( arrays . as list ( java element util . get package and subpackages ( this package ) ) ) ;
list < i adaptable > to rename = new array list < > ( arrays . as list ( java element util . get package and subpackages ( this package ) ) ) ;
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 13 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 13 . 0 . qualifier
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2008 , 2016 mateusz matela and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 8 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 8 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 9 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
org . eclipse . jdt . core . compiler . codegen . target platform = 1 . 8
org . eclipse . jdt . core . compiler . compliance = 1 . 8
bundle - version : 3 . 9 . 0 . qualifier
copyright ( c ) 2012 , 2016 eclipse foundation and others .
label = " % javadoc background color . label"
id = "org . eclipse . jdt . ui . javadoc . background color" >
% javadoc background color . description
label = " % javadoc foreground color . label"
id = "org . eclipse . jdt . ui . javadoc . foreground color" >
return "org . eclipse . jdt . ui . javadoc . background color" ; / / $non - nls - 1$
import org . eclipse . swt . graphics . rgb ;
import org . eclipse . jface . resource . color registry ;
* copyright ( c ) 2006 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
public void test008 ( ) {
public void test009 ( ) {
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
public void test1 ( ) {
tables9 = initialize tables ( "unicode8" ) ; / / $non - nls - 1$
import org . eclipse . jdt . ui . tests . wizardapi . importer test ;
if ( type binding . equals equals ( alpha , bound t . left ) ) { dcnl type binding t = bound t . right ; dcnl return constraint type formula . create ( s , t , bound t . relation , bound t . is soft | | bound s . is soft ) ; dcnl } dcnl if ( type binding . equals equals ( alpha , bound t . right ) ) { dcnl type binding t = bound t . left ; dcnl return constraint type formula . create ( t , s , bound t . relation , bound t . is soft | | bound s . is soft ) ; dcnl }
copyright ( c ) 2012 , 2016 eclipse foundation and others .
< version > 4 . 6 . 2 - snapshot < / version >
< version > 4 . 6 . 2 - snapshot < / version >
< version > 4 . 6 . 2 - snapshot < / version >
< version > 4 . 6 . 2 - snapshot < / version >
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
< version > 4 . 6 . 2 - snapshot < / version >
copyright ( c ) 2013 , 2016 eclipse foundation and others .
< version > 4 . 6 . 2 - snapshot < / version >
< version > 4 . 6 . 2 - snapshot < / version >
import org . eclipse . core . runtime . preferences . instance scope ; dcnl
import org . eclipse . ui . preferences . scoped preference store ; dcnl dcnl import org . eclipse . jdt . core . java core ;
private static final string preference store key = "preference store" ; dcnl dcnl private i preference store f java core preferences ;
f java core preferences = new scoped preference store ( instance scope . instance , java core . plugin id ) ;
private button add check box ( composite parent , string label , i preference store preference store , string key ) { dcnl if ( preference store = = null ) { dcnl preference store = get preference store ( ) ; dcnl }
button . set data ( preference store key , preference store ) ;
button . set selection ( preference store . get boolean ( key ) ) ;
null ,
null ,
add check box ( group , preferences messages . java base preference page search small menu , null , preference constants . search use reduced menu ) ; dcnl add check box ( group , preferences messages . java base preference page disable new java index , f java core preferences , "disable new java index" ) ; / / $non - nls - 1$
i preference store button preference store = ( i preference store ) button . get data ( preference store key ) ; dcnl button . set selection ( button preference store . get default boolean ( key ) ) ;
i preference store store = get preference store ( ) ;
i preference store button preference store = ( i preference store ) button . get data ( preference store key ) ; dcnl button preference store . set value ( key , button . get selection ( ) ) ;
boolean is local class = next type . get declaring type ( ) ! = null ;
type . set declaring type ( create type id from binary name ( binary type . get enclosing type name ( ) ) ) ;
private pdom type signature parse class type signature ( pdom complex type signature parent type or null ,
boolean is raw type with nested class = generic signature [ wrapper . start ] = = ' . ' ;
if ( annotation list . length ! = 0 | | has generic arguments | | parent type or null ! = null | | is raw type with nested class ) {
type signature . set generic declaring type ( parent type or null ) ;
static final int current version = pdom . version ( 1 , 9 ) ;
static final int min supported version = pdom . version ( 1 , 9 ) ;
public static final field many to one < pdom complex type signature > declaring type ; dcnl public static final field one to many < pdom complex type signature > declared types ;
declaring type = field many to one . create ( type , null ) ; dcnl declared types = field one to many . create ( type , declaring type ) ;
import java . util . list ; dcnl
public static final field many to one < pdom type id > declaring type ;
declaring type = field many to one . create ( type , pdom type id . declared types ) ;
public static final field one to many < pdom type > declared types ;
if ( java index . is enabled ( ) ) {
java index index = java index . get index ( ) ;
boolean is local class = next type . get type id ( ) . get declaring type ( ) ! = null ;
pdom type signature enclosing type = type . get type id ( ) . get declaring type ( ) ;
import org . eclipse . jdt . core . compiler . char operation ; dcnl import org . eclipse . jdt . internal . compiler . classfmt . type annotation walker ;
import org . eclipse . jdt . internal . compiler . env . i binary type annotation ; dcnl import org . eclipse . jdt . internal . compiler . env . i type annotation walker ;
import org . eclipse . jdt . internal . compiler . lookup . signature wrapper ;
import org . eclipse . jdt . internal . core . pdom . db . index exception ;
import org . eclipse . jdt . internal . core . pdom . java . pdom complex type signature ;
import org . eclipse . jdt . internal . core . pdom . java . pdom type argument ; dcnl import org . eclipse . jdt . internal . core . pdom . java . pdom type bound ;
import org . eclipse . jdt . internal . core . pdom . java . pdom type parameter ;
import java . util . objects ; dcnl
private static final char [ ] [ ] empty char array array = new char [ 0 ] [ ] ; dcnl private static final char [ ] empty char array = new char [ 0 ] ;
public pdom type add type ( i binary type binary type , i progress monitor monitor ) throws core exception {
i type annotation walker type annotations = get type annotation walker ( binary type . get type annotations ( ) ) ; dcnl i type annotation walker supertype annotations = type annotations . to supertype ( ( short ) - 1 , binary type . get superclass name ( ) ) ; dcnl
dcnl char [ ] [ ] interfaces = binary type . get interface names ( ) ; dcnl if ( interfaces = = null ) { dcnl interfaces = empty char array array ; dcnl } dcnl / / create the default generic signature if the . class file didn't supply one dcnl char [ ] generic signature = binary type . get generic signature ( ) ; dcnl if ( generic signature = = null ) { dcnl int start index = binary type . get superclass name ( ) ! = null ? 3 : 0 ; dcnl char [ ] [ ] to catenate = new char [ start index + ( interfaces . length * 3 ) ] [ ] ; dcnl char [ ] prefix = new char [ ] { 'l' } ; dcnl char [ ] suffix = new char [ ] { ' ; ' } ; dcnl dcnl if ( binary type . get superclass name ( ) ! = null ) { dcnl to catenate [ 0 ] = prefix ; dcnl to catenate [ 1 ] = binary type . get superclass name ( ) ; dcnl to catenate [ 2 ] = suffix ; dcnl } dcnl dcnl for ( int idx = 0 ; idx < interfaces . length ; idx + + ) { dcnl int cat index = start index + idx * 3 ; dcnl to catenate [ cat index ] = prefix ; dcnl to catenate [ cat index + 1 ] = interfaces [ idx ] ; dcnl to catenate [ cat index + 2 ] = suffix ; dcnl } dcnl dcnl generic signature = char util . concat ( to catenate ) ; dcnl } dcnl
dcnl char [ ] enclosing type name = binary type . get enclosing type name ( ) ; dcnl / / todo ( sxenos ) : there are some classes for which enclosing type name is null but which have classnames that dcnl / / resemble inner classes ( ie : the classnames contain a '$' ) . figure out what this means . dcnl / / assert that ( ( enclosing type name = = null ) = = ( name . get declaring type ( ) = = null ) , dcnl / / " declaring type should be null if and only if there is no enclosing type" ) ; / / $non - nls - 1$ dcnl if ( enclosing type name ! = null ) { dcnl string real enclosing field descriptor = java names . binary name to field descriptor ( new string ( enclosing type name ) ) ; dcnl string indexed field descriptor = name . get declaring type ( ) . get raw type ( ) . get field descriptor ( ) . get string ( ) ; dcnl assert that ( objects . equals ( real enclosing field descriptor , indexed field descriptor ) , dcnl " incorrect field descriptor for declaring type" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl signature wrapper signature wrapper = new signature wrapper ( generic signature ) ; dcnl read type parameters ( type , type annotations , signature wrapper ) ; dcnl type . set superclass ( create type signature ( supertype annotations , signature wrapper ) ) ; dcnl dcnl short interface idx = 0 ; dcnl while ( signature wrapper . start < signature wrapper . signature . length ) { dcnl / / note that there may be more interfaces listed in the generic signature than in the interfaces list . dcnl / / although the vm spec doesn't discuss this case specifically , there are . class files in the wild with dcnl / / this characteristic . in such cases , we take what's in the generic signature and discard what's in the dcnl / / interfaces list . dcnl char [ ] interface spec = interface idx < interfaces . length ? interfaces [ interface idx ] : empty char array ; dcnl new pdom type interface ( get pdom ( ) , type , create type signature ( dcnl type annotations . to supertype ( interface idx , interface spec ) , dcnl signature wrapper ) ) ; dcnl interface idx + + ; dcnl }
return type ; dcnl }
/ * * dcnl * reads and attaches any generic type parameters at the current start position in the given wrapper . dcnl * sets wrapper . start to the character following the type parameters . dcnl * @ throws core exception dcnl * / dcnl private void read type parameters ( pdom type type , i type annotation walker annotation walker , signature wrapper wrapper ) dcnl throws core exception { dcnl char [ ] generic signature = wrapper . signature ; dcnl if ( generic signature . length = = 0 | | generic signature [ wrapper . start ] ! = ' < ' ) { dcnl return ; dcnl } dcnl dcnl int parameter index = 0 ; dcnl int bound index = 0 ; dcnl int index of closing bracket = wrapper . skip angle contents ( wrapper . start ) - 1 ; dcnl wrapper . start + + ; dcnl pdom type parameter parameter = null ; dcnl while ( wrapper . start < index of closing bracket ) { dcnl int colon pos = char operation . index of ( ' : ' , generic signature , wrapper . start , index of closing bracket ) ; dcnl dcnl if ( colon pos > wrapper . start ) { dcnl string identifier = new string ( char operation . subarray ( generic signature , wrapper . start , colon pos ) ) ; dcnl parameter = new pdom type parameter ( type , identifier ) ; dcnl wrapper . start = colon pos + 1 ; dcnl parameter index + + ; dcnl bound index = 0 ; dcnl } dcnl dcnl / / class files insert an empty bound if there is an interface bound but no class bound . we just omit dcnl / / the bound entirely . dcnl while ( generic signature [ wrapper . start ] = = ' : ' ) { dcnl wrapper . start + + ;
dcnl pdom type signature bound signature = create type signature ( dcnl annotation walker . to type parameter ( true , parameter index ) . to type bound ( ( short ) bound index ) , dcnl wrapper ) ; dcnl dcnl new pdom type bound ( parameter , bound signature ) ; dcnl bound index + + ;
if ( generic signature [ wrapper . start ] = = ' > ' ) { dcnl wrapper . start + + ; dcnl } dcnl } dcnl dcnl / * * dcnl * reads a type signature from the given { @ link signature wrapper } , starting at the character pointed to by dcnl * wrapper . start . on return , wrapper . start will point to the first character following the type signature . dcnl * dcnl * @ param supertype annotations dcnl * @ param superclass name dcnl * @ param generic signature dcnl * @ return dcnl * @ throws core exception dcnl * / dcnl private pdom type signature create type signature ( i type annotation walker annotations , signature wrapper wrapper ) throws core exception { dcnl char [ ] generic signature = wrapper . signature ; dcnl dcnl if ( generic signature = = null | | generic signature . length = = 0 ) { dcnl return null ; dcnl } dcnl dcnl char first char = generic signature [ wrapper . start ] ; dcnl switch ( first char ) { dcnl case 't' : { dcnl / / skip the 't' prefix dcnl wrapper . start + + ; dcnl pdom complex type signature type signature = new pdom complex type signature ( get pdom ( ) ) ; dcnl type signature . set variable identifier ( new string ( wrapper . next word ( ) ) ) ; dcnl attach annotations ( type signature , annotations ) ; dcnl / / skip the trailing semicolon dcnl wrapper . start + + ; dcnl return type signature ; dcnl } dcnl case ' [ ' : { dcnl / / skip the ' [ ' prefix dcnl wrapper . start + + ; dcnl / / we encode arrays as though they were a one - argument generic type called ' [ ' whose element dcnl / / type is the generic argument . dcnl pdom complex type signature type signature = new pdom complex type signature ( get pdom ( ) ) ; dcnl type signature . set raw type ( create type id from field descriptor ( new char [ ] { ' [ ' } ) ) ; dcnl pdom type argument type argument = new pdom type argument ( get pdom ( ) , type signature ) ; dcnl pdom type signature element type = create type signature ( annotations . to next array dimension ( ) , wrapper ) ; dcnl type argument . set type ( element type ) ; dcnl attach annotations ( type signature , annotations ) ; dcnl return type signature ; dcnl } dcnl case 'b' : dcnl case 'c' : dcnl case 'd' : dcnl case 'f' : dcnl case 'i' : dcnl case 'j' : dcnl case 's' : dcnl case 'z' : dcnl wrapper . start + + ; dcnl return create type id from field descriptor ( new char [ ] { first char } ) ; dcnl case 'l' : dcnl return parse class type signature ( null , annotations , wrapper ) ; dcnl case ' + ' : dcnl case ' - ' : dcnl case ' * ' : dcnl throw new core exception ( package . create status ( " unexpected wildcard in top - level of generic signature : " / / $non - nls - 1$ dcnl + generic signature . to string ( ) ) ) ; dcnl default : dcnl throw new core exception ( package . create status ( " generic signature starts with unknow character : " / / $non - nls - 1$ dcnl + generic signature . to string ( ) ) ) ; dcnl } dcnl } dcnl dcnl / * * dcnl * parses a class type signature ( as described in section 4 . 7 . 9 . 1 of the java vm specification java se 8 edition ) . dcnl * the read pointer should be located just after the identifier . the caller is expected to have already read dcnl * the field descriptor for the type . dcnl * dcnl * @ param annotations dcnl * @ param wrapper dcnl * @ param generic signature dcnl * @ param field descriptor dcnl * @ return dcnl * @ throws core exception dcnl * / dcnl private pdom type signature parse class type signature ( pdom type signature parent type or null , dcnl i type annotation walker annotations , signature wrapper wrapper ) throws core exception { dcnl char [ ] identifier = wrapper . next name ( ) ; dcnl char [ ] field descriptor ; dcnl dcnl if ( parent type or null ! = null ) { dcnl field descriptor = char util . concat ( parent type or null . get raw type ( ) . get field descriptor ( ) . get chars ( ) , dcnl new char [ ] { '$' } , dcnl identifier ) ; dcnl } else { dcnl field descriptor = identifier ; dcnl } dcnl dcnl char [ ] generic signature = wrapper . signature ; dcnl boolean has generic arguments = ( generic signature . length > wrapper . start ) & & generic signature [ wrapper . start ] = = ' < ' ; dcnl pdom type id raw type = create type id from field descriptor ( field descriptor ) ; dcnl pdom type signature result = raw type ; dcnl dcnl / / special optimization for signatures with no type annotations , no arrays , and no generic arguments that dcnl / / are not an inner type of a class that can't use this optimization . basically , if there would be no attributes dcnl / / set on a pdom complex type signature besides what it picks up from its raw type , we just use the raw type . dcnl i binary annotation [ ] annotation list = annotations . get annotations at cursor ( 0 ) ; dcnl if ( annotation list . length ! = 0 | | has generic arguments dcnl | | ! objects . equals ( parent type or null , raw type . get declaring type ( ) ) ) { dcnl pdom complex type signature type signature = new pdom complex type signature ( get pdom ( ) ) ; dcnl type signature . set raw type ( raw type ) ; dcnl attach annotations ( type signature , annotations ) ; dcnl dcnl if ( has generic arguments ) { dcnl wrapper . start + + ; dcnl short argument index = 0 ; dcnl while ( wrapper . start < generic signature . length & & ( generic signature [ wrapper . start ] ! = ' > ' ) ) { dcnl pdom type argument type argument = new pdom type argument ( get pdom ( ) , type signature ) ; dcnl dcnl switch ( generic signature [ wrapper . start ] ) { dcnl case ' + ' : { dcnl type argument . set wildcard ( pdom type argument . wildcard super ) ; dcnl wrapper . start + + ; dcnl break ; dcnl } dcnl case ' - ' : { dcnl type argument . set wildcard ( pdom type argument . wildcard extends ) ; dcnl wrapper . start + + ; dcnl break ; dcnl } dcnl case ' * ' : { dcnl type argument . set wildcard ( pdom type argument . wildcard question ) ; dcnl wrapper . start + + ; dcnl argument index + + ; dcnl continue ; dcnl } dcnl } dcnl dcnl pdom type signature next signature = create type signature ( annotations . to type argument ( argument index ) , wrapper ) ; dcnl type argument . set type ( next signature ) ; dcnl argument index + + ; dcnl } dcnl dcnl / / skip over the trailing ' > ' dcnl wrapper . start + + ; dcnl } dcnl result = type signature ; dcnl dcnl if ( parent type or null ! = null ) { dcnl result . set declaring type ( parent type or null ) ; dcnl } dcnl } dcnl dcnl if ( wrapper . start > = generic signature . length ) { dcnl throw new index exception ( " read beyond end of the type signature!" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl switch ( generic signature [ wrapper . start ] ) { dcnl case ' ; ' : dcnl wrapper . start + + ; dcnl break ; dcnl case ' . ' : dcnl pdom type signature nested type = parse class type signature ( result , annotations . to next nested type ( ) , wrapper ) ; dcnl dcnl pdom type signature detected nested type = nested type . get declaring type ( ) ; dcnl dcnl / / perform a sanity - test dcnl assert that ( objects . equals ( detected nested type , result ) , dcnl " incorrect declaring type for nested type" ) ; dcnl assert that ( objects . equals ( nested type . get declaring type ( ) . get raw type ( ) , result . get raw type ( ) ) , dcnl " incorrect declaring type for nested raw type" ) ; dcnl dcnl result = nested type ; dcnl break ; dcnl } dcnl dcnl return result ; dcnl } dcnl dcnl / * * dcnl * @ param equals dcnl * @ param string dcnl * / dcnl private void assert that ( boolean to test , string error message ) { dcnl if ( !to test ) { dcnl throw new index exception ( error message ) ; dcnl } dcnl } dcnl dcnl / * * dcnl * @ param type signature dcnl * @ param annotations dcnl * / dcnl private void attach annotations ( pdom complex type signature type signature , i type annotation walker annotations ) { dcnl i binary annotation [ ] annotation list = annotations . get annotations at cursor ( 0 ) ; dcnl dcnl for ( i binary annotation next : annotation list ) { dcnl pdom annotation annotation = create annotation ( next ) ; dcnl dcnl annotation . set parent ( type signature ) ; dcnl } dcnl } dcnl dcnl private i type annotation walker get type annotation walker ( i binary type annotation [ ] type annotations ) { dcnl if ( type annotations = = null ) { dcnl return i type annotation walker . empty annotation walker ; dcnl } dcnl return new type annotation walker ( type annotations ) ; dcnl } dcnl dcnl private pdom type id create type id from field descriptor ( string type name ) { dcnl if ( type name = = null ) { dcnl return null ; dcnl } dcnl return this . index . create type id ( type name ) ;
import java . io . file ;
import org . eclipse . core . runtime . i path ; dcnl import org . eclipse . jdt . core . java core ;
import org . eclipse . jdt . internal . core . pdom . pdom node ; dcnl import org . eclipse . jdt . internal . core . pdom . pdom node type registry ; dcnl import org . eclipse . jdt . internal . core . pdom . db . chunk cache ;
/ / version constants dcnl static final int current version = pdom . version ( 1 , 8 ) ; dcnl static final int max supported version = pdom . version ( 1 , short . max value ) ; dcnl static final int min supported version = pdom . version ( 1 , 8 ) ; dcnl dcnl / / fields for the search header
private static pdom global pdom ; dcnl private static final string index filename = "index . db" ; / / $non - nls - 1$ dcnl private final static object pdom mutex = new object ( ) ;
public pdom type id create type id ( char [ ] field descriptor ) {
int position of separator = field descriptor . last index of ( '$' ) ; dcnl dcnl pdom type id result = new pdom type id ( this . pdom , field descriptor ) ; dcnl dcnl if ( position of separator ! = - 1 ) { dcnl result . set declaring type ( create type id ( field descriptor . substring ( 0 , position of separator ) ) ) ; dcnl } dcnl dcnl return result ;
* type variable , this object represents it . dcnl * < p > dcnl * arrays are encoded in a special way . the raw type points to a sentinel type called ' [ ' dcnl * and the first type argument holds the array type . dcnl * dcnl * @ since 3 . 12
public void set variable identifier ( string variable identifier ) { dcnl variable identifier . put ( get pdom ( ) , this . address , variable identifier ) ; dcnl } dcnl
/ / public static final field many to one < pdom type id > declaring type ;
public static final field one to many < pdom type parameter > type parameters ;
/ / declaring type = field many to one . create ( type , pdom type id . declared types ) ;
/ * * dcnl * @ since 3 . 12 dcnl * /
import org . eclipse . jdt . internal . core . pdom . field . field many to one ;
import java . util . array list ; dcnl import java . util . list ; dcnl
public static final field one to many < pdom type bound > used as type bound ; dcnl public static final field many to one < pdom type signature > declaring type ; dcnl public static final field one to many < pdom type signature > declared types ;
used as type bound = field one to many . create ( type , pdom type bound . type ) ; dcnl declaring type = field many to one . create ( type , null ) ; dcnl declared types = field one to many . create ( type , declaring type ) ;
pdom . acquire read lock ( ) ;
try { dcnl pdom type id found type = index . find type ( field definition ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
this . pdom . process deletions ( ) ;
private long array pending deletions = new long array ( ) ;
public void schedule deletion ( long address of node to delete ) { dcnl this . pending deletions . add last ( address of node to delete ) ; dcnl } dcnl dcnl / * * dcnl * synchronously processes all pending deletions dcnl * / dcnl public void process deletions ( ) { dcnl while ( !this . pending deletions . is empty ( ) ) { dcnl long next = this . pending deletions . remove last ( ) ; dcnl dcnl delete ( next ) ; dcnl } dcnl } dcnl
process deletions ( ) ;
* @ since 3 . 12
/ / or it's been a long time since the file was last scanned . being too eager about removing old files
import java . util . list ; dcnl
import org . eclipse . jdt . internal . core . pdom . db . i string ;
hierarchy binary type result = new hierarchy binary type ( type . get modifiers ( ) , type id . get binary name ( ) ,
result . record superclass ( super class . get raw type ( ) . get binary name ( ) ) ;
private final field string key ;
*
public void put ( pdom pdom , long record , char [ ] new string ) {
if ( name . compare ( new string , true ) ! = 0 ) {
if ( new string ! = null & & new string . length > 0 ) {
public static final char [ ] empty char array = new char [ 0 ] ; dcnl
*
import org . eclipse . jdt . internal . compiler . env . i binary method ;
import org . eclipse . jdt . internal . core . pdom . java . pdom binding ;
import org . eclipse . jdt . internal . core . pdom . java . pdom method ; dcnl import org . eclipse . jdt . internal . core . pdom . java . pdom method exception ;
import org . eclipse . jdt . internal . core . pdom . java . pdom method parameter ;
private static final boolean enable logging = false ;
*
*
signature wrapper signature wrapper = generic signatures . get generic signature ( binary type ) ;
attach annotations ( type , annotations ) ;
add field ( type , next field ) ; dcnl } dcnl }
i binary method [ ] methods = binary type . get methods ( ) ;
if ( methods ! = null ) { dcnl for ( i binary method next : methods ) { dcnl add method ( type , next , binary name ) ;
private void attach annotations ( pdom binding type , i binary annotation [ ] annotations ) { dcnl if ( annotations ! = null ) { dcnl for ( i binary annotation next : annotations ) { dcnl create annotation ( next ) . set parent ( type ) ; dcnl } dcnl } dcnl } dcnl
* adds the given method to the given type dcnl * @ throws core exception
private void add method ( pdom type type , i binary method next , char [ ] binary type name ) throws core exception { dcnl pdom method method = new pdom method ( type ) ; dcnl dcnl attach annotations ( method , next . get annotations ( ) ) ; dcnl dcnl i type annotation walker type annotations = get type annotation walker ( next . get type annotations ( ) ) ; dcnl signature wrapper signature = generic signatures . get generic signature ( next ) ; dcnl read type parameters ( method , type annotations , signature ) ; dcnl dcnl if ( signature . char at start ( ) = = ' ( ' ) { dcnl signature . start + + ;
dcnl char [ ] [ ] parameter names = next . get argument names ( ) ; dcnl short parameter idx = 0 ; dcnl while ( !signature . at end ( ) ) { dcnl if ( signature . char at start ( ) = = ' ) ' ) { dcnl signature . start + + ; dcnl break ;
pdom method parameter parameter = new pdom method parameter ( method , dcnl create type signature ( type annotations . to method parameter ( parameter idx ) , dcnl signature ) ) ;
if ( parameter names ! = null & & parameter names . length > parameter idx ) { dcnl parameter . set name ( parameter names [ parameter idx ] ) ;
parameter idx + + ; dcnl }
method . set return type ( create type signature ( type annotations . to method return ( ) , signature ) ) ; dcnl dcnl int throws idx = 0 ; dcnl while ( !signature . at end ( ) & & signature . char at start ( ) = = ' ^ ' ) { dcnl signature . start + + ; dcnl new pdom method exception ( method , dcnl create type signature ( type annotations . to throws ( throws idx ) , signature ) ) ; dcnl throws idx + + ;
object default value = next . get default value ( ) ; dcnl if ( default value ! = null ) { dcnl method . set default value ( create from mixed type ( default value ) ) ; dcnl } dcnl dcnl method . set method id ( dcnl create method id ( binary type name , next . get selector ( ) , next . get method descriptor ( ) ) ) ; dcnl dcnl method . set modifiers ( next . get modifiers ( ) ) ;
* adds the given field to the given type
private void add field ( pdom type type , i binary field next field ) throws core exception { dcnl pdom variable variable = new pdom variable ( type ) ; dcnl dcnl variable . set name ( new string ( next field . get name ( ) ) ) ; dcnl dcnl i binary annotation [ ] binary annotations = next field . get annotations ( ) ; dcnl if ( binary annotations ! = null ) { dcnl for ( i binary annotation next annotation : binary annotations ) { dcnl create annotation ( next annotation ) . set parent ( variable ) ; dcnl }
dcnl variable . set constant ( pdom constant . create ( get pdom ( ) , next field . get constant ( ) ) ) ; dcnl variable . set modifiers ( next field . get modifiers ( ) ) ; dcnl signature wrapper next type signature = generic signatures . get generic signature for ( next field ) ; dcnl dcnl i type annotation walker annotation walker = get type annotation walker ( next field . get type annotations ( ) ) ; dcnl variable . set type ( create type signature ( annotation walker , next type signature ) ) ;
* @ throws core exception
private void read type parameters ( pdom binding type , i type annotation walker annotation walker , signature wrapper wrapper )
if ( generic signature . length = = 0 | | wrapper . char at start ( ) ! = ' < ' ) {
* returns null if given an empty signature or the signature for the void type . dcnl *
* @ throws core exception
case 'v' : return null ;
*
* creates a method id given a method selector , method descriptor , and binary type name dcnl * / dcnl private pdom method id create method id ( char [ ] binary type name , char [ ] method selector , char [ ] method descriptor ) { dcnl if ( method selector = = null | | binary type name = = null | | method descriptor = = null ) { dcnl return null ; dcnl } dcnl dcnl char [ ] method id = java names . get method id ( binary type name , method selector , method descriptor ) ; dcnl return this . index . create method id ( method id ) ; dcnl } dcnl dcnl / * * dcnl * creates a method id given a method name ( which is a method selector followed by a method descriptor .
char [ ] method id = java names . get method id ( binary type name , method name ) ;
static final int current version = pdom . version ( 1 , 12 ) ; dcnl static final int max supported version = pdom . version ( 1 , 12 ) ; dcnl static final int min supported version = pdom . version ( 1 , 12 ) ;
public pdom method id find method id ( char [ ] method id ) {
public pdom method id create method id ( char [ ] method id ) {
import org . eclipse . jdt . internal . core . pdom . indexer . char util ;
private static final char [ ] field descriptor prefix = new char [ ] { 'l' } ; dcnl private static final char [ ] method id separator = new char [ ] { '#' } ; dcnl
string binary name = new string ( type . get type id ( ) . get binary name ( ) ) ;
* dcnl * @ param parent type binary name a field descriptor of the sort returned by the other * to field descriptor methods .
public static char [ ] get method id ( char [ ] parent type binary name , char [ ] method selector and descriptor ) { dcnl return char util . concat ( field descriptor prefix , parent type binary name , method id separator , method selector and descriptor ) ; dcnl } dcnl dcnl public static char [ ] get method id ( char [ ] parent type binary name , char [ ] method selector , char [ ] method descriptor ) { dcnl return char util . concat ( field descriptor prefix , parent type binary name , method id separator , method selector , method descriptor ) ;
* if the field descriptor points to any other type , this returns the empty string . dcnl *
public static char [ ] field descriptor to binary name ( char [ ] field descriptor ) { dcnl if ( char util . starts with ( field descriptor , 'l' ) ) { dcnl return char util . substring ( field descriptor , 1 ) ;
public static final field one to many < pdom type parameter > type parameters ;
public static final field one to one < pdom method > parent method ;
import org . eclipse . jdt . internal . core . pdom . field . field one to many ; dcnl import org . eclipse . jdt . internal . core . pdom . field . field one to one ;
public static final field many to one < pdom type > parent ;
public static final field one to many < pdom method parameter > parameters ; dcnl public static final field one to one < pdom constant > default value ; dcnl public static final field one to many < pdom method exception > exceptions ; dcnl public static final field many to one < pdom type signature > return type ; dcnl
parent = field many to one . create ( type , pdom type . methods ) ; dcnl parameters = field one to many . create ( type , pdom method parameter . parent ) ;
default value = field one to one . create ( type , pdom constant . class , pdom constant . parent method ) ; dcnl exceptions = field one to many . create ( type , pdom method exception . parent ) ; dcnl return type = field many to one . create ( type , pdom type signature . used as return type ) ;
public pdom method ( pdom type parent ) { dcnl super ( parent . get pdom ( ) , parent . get file ( ) ) ; dcnl } dcnl
*
* followed by method descriptor . for example , " lorg / eclipse / my class#foo ( ) ljava / lang / object ; v"
public pdom method id ( pdom pdom , char [ ] method identifier ) {
public static final field one to many < pdom method > methods ;
public static final field many to one < pdom binding > parent ;
import java . util . array list ; dcnl import java . util . list ; dcnl
*
public static final field one to many < pdom method parameter > used as method argument ; dcnl public static final field one to many < pdom method exception > used as exception ; dcnl public static final field one to many < pdom method > used as return type ;
used as method argument = field one to many . create ( type , pdom method parameter . argument type ) ; dcnl used as exception = field one to many . create ( type , pdom method exception . exception type ) ; dcnl used as return type = field one to many . create ( type , pdom method . return type ) ;
import org . eclipse . jdt . internal . core . pdom . field . struct def . deletion semantics ; dcnl
public boolean is ready for deletion ( pdom dom , long address ) {
import org . eclipse . jdt . internal . core . pdom . field . struct def . deletion semantics ; dcnl
void destruct ( pdom dom , long address ) ;
* returns true if this object is orphaned . if the object is refcounted , this means the refcount is 0 . if dcnl * the object is deleted via an owner pointer , this means the owner pointer is null .
boolean is ready for deletion ( pdom dom , long address ) ;
* returns the deletion semantics used for this object .
import org . eclipse . core . runtime . i progress monitor ; dcnl import org . eclipse . core . runtime . operation canceled exception ; dcnl import org . eclipse . jdt . internal . core . pdom . db . chunk cache ; dcnl import org . eclipse . jdt . internal . core . pdom . db . database ; dcnl import org . eclipse . jdt . internal . core . pdom . db . index exception ; dcnl
private hash map < long , throwable > pending deletions = new hash map < > ( ) ;
/ / sometimes an object can be scheduled for deletion twice , if it is created and then discarded shortly dcnl / / afterward during indexing . this may indicate an inefficiency in the indexer but is not necessarily dcnl / / a bug . dcnl if ( this . pending deletions . contains key ( address of node to delete ) ) {
package . log ( " earlier deletion stack was this : " , pending deletions . get ( address of node to delete ) ) ;
this . pending deletions . put ( address of node to delete , new runtime exception ( ) ) ;
long next = this . pending deletions . key set ( ) . iterator ( ) . next ( ) ;
delete if unreferenced ( next ) ;
this . pending deletions . remove ( next ) ;
public class field many to one < t extends pdom node > implements i destructable field , i field , i ref counted field {
builder . add owner field ( result ) ;
public t get ( pdom pdom , long address ) { dcnl return pdom node . load ( pdom , get address ( pdom , address ) , this . target type ) ;
public long get address ( pdom pdom , long address ) { dcnl return pdom . get db ( ) . get rec ptr ( address + this . offset ) ;
public void put ( pdom pdom , long address , t value ) {
put ( pdom , address , value . address ) ;
put ( pdom , address , 0 ) ;
short target type id = pdom node . node type . get ( pdom , old target address ) ;
i type factory < t > type factory = pdom . get type factory ( target type id ) ;
if ( type factory . get deletion semantics ( ) = = struct def . deletion semantics . refcounted dcnl & & type factory . is ready for deletion ( pdom , old target address ) ) {
} else { dcnl if ( this . points to owner ) { dcnl pdom . schedule deletion ( address ) ; dcnl }
void adjust index ( pdom pdom , long address , int index ) { dcnl backpointer index . put ( pdom , address + this . offset , index ) ;
public void destruct ( pdom pdom , long address ) { dcnl put ( pdom , address , 0 ) ;
void cleared by back pointer ( pdom pdom , long address ) { dcnl long field start = this . offset + address ;
public class field one to one < t extends pdom node > implements i field , i destructable field , i ref counted field {
builder . add owner field ( result ) ;
if ( target = = null & & this . points to owner ) { dcnl pdom . schedule deletion ( address ) ; dcnl }
db . put rec ptr ( ptr + this . back pointer . offset , 0 ) ;
import java . util . collections ;
* defines a data structure that will appear in the database . dcnl * < p > dcnl * there are three mechanisms for deleting a struct from the database : dcnl * < ul > dcnl * < li > explicit deletion . this happens synchronously via manual calls to pdom . delete . structs intended for manual dcnl * deletion have ref counted = false and an empty owner fields . dcnl * < li > owner pointers . such structs have one or more outbound pointers to an "owner" object . they are deleted dcnl * asynchronously when the last owner pointer is deleted . the structs have ref counted = false and a nonempty dcnl * owner fields . dcnl * < li > refcounting . such structs are deleted asynchronously when all elements are removed from all of their many to one dcnl * relationships which are not marked as incoming owner pointers . owner relationships need to be excluded from dcnl * refcounting since they would always create cycles . these structs have ref counted = true . dcnl * < / ul > dcnl * < p > dcnl * structs deleted by refcounting and owner pointers are not intended to inherit from one another , but anything may dcnl * inherit from a struct that uses manual deletion and anything may inherit from a struct that uses the same deletion dcnl * mechanism . dcnl *
private list < i ref counted field > owner fields = new array list < > ( ) ;
private deletion semantics deletion semantics ; dcnl dcnl public static enum deletion semantics { dcnl explicit , owned , refcounted dcnl }
@ override dcnl public boolean is ready for deletion ( pdom dom , long address ) { dcnl return struct def . this . is ready for deletion ( dom , address ) ;
dcnl @ override dcnl public deletion semantics get deletion semantics ( ) { dcnl return struct def . this . get deletion semantics ( ) ;
protected boolean is ready for deletion ( pdom dom , long record ) { dcnl list < i ref counted field > to iterate = collections . empty list ; dcnl switch ( this . deletion semantics ) { dcnl case explicit : return false ; dcnl case owned : to iterate = this . owner fields ; break ; dcnl case refcounted : to iterate = this . ref counted fields ; break ; dcnl } dcnl dcnl for ( i ref counted field next : to iterate ) {
return false ;
final struct def < ? super t > local super class = struct def . this . super class ; dcnl if ( local super class ! = null & & local super class . deletion semantics ! = deletion semantics . explicit ) { dcnl return local super class . is ready for deletion ( dom , record ) ;
return true ;
public deletion semantics get deletion semantics ( ) { dcnl return this . deletion semantics ; dcnl } dcnl
public void add owner field ( i ref counted field result ) { dcnl check mutable ( ) ; dcnl dcnl this . owner fields . add ( result ) ; dcnl } dcnl
/ * * dcnl * invoked on all struct def after both { @ link #done ( ) } has been called on the struct and dcnl * { @ link #compute offsets ( ) } has been called on their base class . dcnl * /
if ( this . ref counted ) { dcnl this . deletion semantics = deletion semantics . refcounted ; dcnl } else { dcnl if ( !this . owner fields . is empty ( ) ) { dcnl this . deletion semantics = deletion semantics . owned ; dcnl } else if ( this . super class ! = null ) { dcnl this . deletion semantics = this . super class . deletion semantics ; dcnl } else { dcnl this . deletion semantics = deletion semantics . explicit ; dcnl } dcnl } dcnl / / now verify that the deletion semantics of this struct are compatible with the deletion dcnl / / semantics of its superclass dcnl if ( this . super class ! = null & & this . deletion semantics ! = this . super class . deletion semantics ) { dcnl if ( this . super class . deletion semantics ! = deletion semantics . explicit ) { dcnl throw new illegal state exception ( "a class ( " + this . clazz . get name ( ) + " ) that uses " / / $non - nls - 1$ / / $non - nls - 2$ dcnl + this . deletion semantics . to string ( ) + " deletion semantics may not inherit from a class " / / $non - nls - 1$ dcnl + "that uses " + this . super class . deletion semantics . to string ( ) + " semantics" ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl } dcnl } dcnl
throw new core exception ( package . create status ( " unable to parse jar file" , e ) ) ; / / $non - nls - 1$
log info ( "adding binary type " + new string ( binary name ) ) ; / / $non - nls - 1$
signature wrapper signature wrapper = get generic signature ( binary type ) ;
signature wrapper next type signature = get generic signature for ( next field ) ;
i type annotation walker annotation walker = get type annotation walker ( next field . get type annotations ( ) ) ; dcnl variable . set type ( create type signature ( annotation walker , next type signature ) ) ;
import java . util . iterator ;
private hash set < long > pending deletions = new hash set < > ( ) ;
if ( this . pending deletions . contains ( address of node to delete ) ) { dcnl / / todo ( sxenos ) : sometimes the same node gets scheduled for deletion more than once , which is why dcnl / / pending deletions is a hash set rather than a queue . we need to understand the circumstances in which dcnl / / this can happen . if it can be prevented , we should prevent it and change this back to a queue . dcnl package . log ( "pdom object queued for deletion twice" , new runtime exception ( ) ) ; / / $non - nls - 1$ dcnl return ; dcnl } dcnl this . pending deletions . add ( address of node to delete ) ;
iterator < long > iter = this . pending deletions . iterator ( ) ; dcnl long next = iter . next ( ) ;
+ wrapper . to string ( ) ) ) ;
throw new core exception ( package . create status ( " generic signature starts with unknown character : " / / $non - nls - 1$ dcnl + wrapper . to string ( ) ) ) ;
boolean check for semicolon = true ;
/ / don't check for a semicolon if we hit this branch since the recursive call to parse class type signature dcnl / / will do this dcnl check for semicolon = false ;
* holds the n side of a n . . 1 relationship . declares a pdom field which is a pointer of a pdom node of the specified dcnl * type . { @ link field many to one } forms a one - to - many relationship with { @ link field one to many } . whenever a dcnl * { @ link field many to one } points to an object , the inverse pointer is automatically inserted into the matching back dcnl * pointer list .
@ suppress warnings ( "rawtypes" )
public search criteria to btree visitor adapter ( search criteria search criteria , nd pdom ) {
@ suppress warnings ( "unchecked" )
protected void accept result ( long result address ) { dcnl long rank = rank function . get rank ( pdom , result address ) ;
result [ 0 ] = result address ;
@ suppress warnings ( "unchecked" )
public void destruct fields ( nd dom , long address ) { }
/ /
/ /
/ / public int compare ( long address ) throws index exception {
/ / i string nm1 = pdom named node . get db name ( db , address ) ; dcnl / / int cmp = nm1 . compare compatible with ignore case ( this . f name ) ;
/ / long t1 = pdom binding . get local to file rec ( db , address ) ;
/ /
/ / public boolean visit ( long address ) throws index exception { dcnl / / final pdom named node nnode = ( pdom named node ) pdom node . load ( pdom , address ) ;
/ /
/ / } else if ( record1 > record2 ) {
/ /
* @ param address
public nd linked list ( nd pdom , long address , i type factory < t > element factory , int records in first block ,
this ( pdom , address , element factory , records in first block , records in subsequent blocks , 0 ) ;
public nd linked list ( nd pdom , long address , i type factory < t > element factory , int records in first block ,
this . raw list = new nd raw linked list ( pdom , address , element factory . get record size ( ) , records in first block ,
*
* @ throws index exception
long address = this . raw list . add member ( metadata bits ) ;
return this . element factory . create ( this . raw list . get pdom ( ) , address ) ;
public void visit ( long address , short metadata bits , int index ) throws index exception {
address ) , metadata bits , index ) ;
public nd linked list < t > create ( nd dom , long address ) { dcnl return new nd linked list < t > ( dom , address , element factory , records in first block , records in subsequent blocks , metadata bits per element ) ;
public void destruct fields ( nd dom , long address ) { dcnl create ( dom , address ) . destruct ( ) ;
public void destruct ( nd dom , long address ) { dcnl destruct fields ( dom , address ) ;
*
public abstract class nd node implements i destructable {
public static final struct def < nd node > type ;
* load a node from the specified address in the given database . return null if a node cannot
* @ param address the address of the node in the given pdom .
throw new index exception ( " found wrong data type at address " + address + " . expected a subclass of " + / / $non - nls - 1$ / / $non - nls - 2$
public final long get address ( ) {
import org . eclipse . jdt . internal . core . pdom . db . index exception ; dcnl
public r create node ( nd pdom , long address , short node type ) throws index exception {
*
* record size if the block is full , this holds the last
*
private final long address ;
private final int element record size ;
/ / derived data . holds the address for the last block we know about
public void visit ( long address , short metadata bits , int index ) throws index exception ;
* @ param address pointer to the start of the linked list
public nd raw linked list ( nd pdom , long address , int element record size , int first block record count , int records per block ,
this . address = address ;
this . last known block = address ;
/ / this . address = dom . get db ( ) . malloc ( database . ptr size + this . element record size * records per block ) ; dcnl / / this . last known block = this . address ;
* returns the record size for a linked list with the given element record size and number of
public long get address ( ) { dcnl return this . address ;
*
long current = this . address ;
long current = this . address ;
* @ throws index exception
private final long address ;
dcnl public pointer ( nd pdom , long address , i type factory < t > target factory ) {
this . address = address ;
long ptr = this . pdom . get db ( ) . get rec ptr ( this . address ) ;
public long create ( nd dom , long address ) { dcnl return dom . get db ( ) . get rec ptr ( address ) ;
public short create ( nd dom , long address ) { dcnl return dom . get db ( ) . get short ( address ) ;
public t get ( nd pdom , long address ) { dcnl return this . factory . create ( pdom , address + this . offset ) ;
public byte get ( nd pdom , long address ) {
return db . get byte ( address + this . offset ) ;
public char get ( nd pdom , long address ) {
return db . get char ( address + this . offset ) ;
public double get ( nd pdom , long address ) {
return db . get double ( address + this . offset ) ;
public float get ( nd pdom , long address ) {
return db . get float ( address + this . offset ) ;
public int get ( nd pdom , long address ) {
return db . get int ( address + this . offset ) ;
public long get ( nd pdom , long address ) {
return db . get long ( address + this . offset ) ;
public boolean has references ( nd pdom , long address ) {
public long get ( nd pdom , long address ) {
return db . get rec ptr ( address + this . offset ) ;
public int compare ( long address ) throws index exception { dcnl i string key = field search index . this . search key . get ( this . pdom , address ) ;
public boolean visit ( long address ) throws index exception {
short node type = nd node . node type . get ( this . pdom , address ) ;
/ / long parent = pdom named node . parent . get address ( this . pdom , address ) ;
i string key = field search index . this . search key . get ( this . pdom , address ) ;
accept result ( address ) ;
protected abstract void accept result ( long address ) ;
public b tree get ( nd pdom , long address ) { dcnl return this . btree factory . create ( pdom , address + this . offset ) ;
public void destruct ( nd pdom , long address ) { dcnl this . btree factory . destruct ( pdom , address ) ;
protected void accept result ( long address ) { dcnl long rank = rank function . get rank ( pdom , address ) ;
result [ 0 ] = address ;
public short get ( nd pdom , long address ) {
return db . get short ( address + this . offset ) ;
public i string get ( nd pdom , long address ) {
long namerec = db . get rec ptr ( address + this . offset ) ;
public void put ( nd pdom , long address , char [ ] new string ) {
i string name = get ( pdom , address ) ;
db . put rec ptr ( address + this . offset , db . new string ( new string ) . get record ( ) ) ;
db . put rec ptr ( address + this . offset , 0 ) ;
public void put ( nd pdom , long address , string new string ) { dcnl put ( pdom , address , new string . to char array ( ) ) ;
public void destruct ( nd pdom , long address ) {
i destructable destructable = ( i destructable ) create ( pdom , address ) ;
destruct fields ( pdom , address ) ;
protected boolean is ready for deletion ( nd dom , long address ) {
if ( next . has references ( dom , address ) ) {
public nd binding ( nd pdom , long address ) { dcnl super ( pdom , address ) ;
/ / pdom tag index . set tags ( get pdom ( ) , pdom binding . address , collections . < i tag > empty list ( ) ) ;
/ / * @ param address
/ / public static boolean is orphaned ( pdom pdom , long address ) throws index exception {
/ / return db . get rec ptr ( address + first decl offset ) = = 0 dcnl / / & & db . get rec ptr ( address + first def offset ) = = 0 dcnl / / & & db . get rec ptr ( address + first ref offset ) = = 0 dcnl / / & & db . get rec ptr ( address + first extref offset ) = = 0 ;
/ / if ( db . get rec ptr ( address + first decl offset ) ! = 0 dcnl / / | | db . get rec ptr ( address + first def offset ) ! = 0 ) {
/ / new pdom external references list ( get pdom ( ) , address + first extref offset ) . add ( name ) ;
/ / long namerec = get db ( ) . get rec ptr ( address + first decl offset ) ;
/ / get db ( ) . put rec ptr ( address + first decl offset , namerec ) ;
/ / long namerec = get db ( ) . get rec ptr ( address + first def offset ) ;
/ / get db ( ) . put rec ptr ( address + first def offset , namerec ) ;
/ / long namerec = get db ( ) . get rec ptr ( address + first ref offset ) ;
/ / return new pdom external references list ( get pdom ( ) , address + first extref offset ) . get iterator ( ) ;
/ / new pdom external references list ( get pdom ( ) , address + first extref offset ) . set first reference ( linkage , name ) ;
/ / new pdom external references list ( get pdom ( ) , address + first extref offset ) . add ( name ) ;
/ / get db ( ) . put rec ptr ( address + first ref offset , namerec ) ;
/ / final long filerec = get local to file rec ( get db ( ) , address ) ;
/ / return get local to file rec ( get db ( ) , address ) ;
/ / public static long get local to file rec ( database db , long address ) throws index exception { dcnl / / return db . get rec ptr ( address + local to file ) ;
/ / get db ( ) . put rec ptr ( address + local to file , rec ) ;
/ / return get db ( ) . get rec ptr ( address + local to file ) ! = 0 ;
* @ param address
char [ ] field definition = java names . fully qualified name to field descriptor ( type . get fully qualified name ( ) . to char array ( ) ) ;
variable . set name ( next field . get name ( ) ) ;
char [ ] identifier = char operation . subarray ( generic signature , wrapper . start , colon pos ) ;
type signature . set variable identifier ( wrapper . next word ( ) ) ;
pdom annotation value pair next pair = new pdom annotation value pair ( result , element . get name ( ) ) ;
return this . index . create type id ( java names . binary name to field descriptor ( binary name ) ) ;
public pdom type id find type ( char [ ] field descriptor ) {
import org . eclipse . jdt . core . compiler . char operation ;
import org . eclipse . jdt . internal . core . util . char array buffer ;
private static final char [ ] class file suffix = " . class" . to char array ( ) ; / / $non - nls - 1$
private static final char [ ] jar file entry separator = i java search scope . jar file entry separator . to char array ( ) ;
public static char [ ] binary name to simple name ( char [ ] binary name ) { dcnl int skip index = math . max ( dcnl math . max ( char operation . last index of ( '$' , binary name ) , char operation . last index of ( ' . ' , binary name ) ) , dcnl char operation . last index of ( ' / ' , binary name ) ) + 1 ;
return char util . substring ( binary name , skip index ) ;
public static char [ ] binary name to resource relative path ( char [ ] binary name ) { dcnl char [ ] relative path = binary name ; dcnl int index of separator = char operation . index of ( '$' , relative path ) ;
relative path = char operation . subarray ( relative path , 0 , index of separator ) ;
return char operation . concat ( relative path , class file suffix ) ;
public static char [ ] fully qualified name to binary name ( char [ ] fully qualified name ) { dcnl return char operation . replace on copy ( fully qualified name , ' . ' , ' / ' ) ;
public static char [ ] fully qualified name to field descriptor ( char [ ] fully qualified name ) { dcnl char [ ] result = char util . concat ( field descriptor prefix , fully qualified name ) ; dcnl char operation . replace ( result , ' . ' , ' / ' ) ; dcnl return result ;
public static char [ ] get index path for ( pdom type type ) {
char [ ] filename = resource file . get filename ( ) . get chars ( ) ; dcnl char [ ] binary name = type . get type id ( ) . get binary name ( ) ;
return char util . concat ( filename , jar file entry separator , binary name to resource relative path ( binary name ) ) ;
public static char [ ] binary name to field descriptor ( char [ ] binary name ) { dcnl return char util . concat ( field descriptor prefix , binary name ) ;
public static char [ ] field descriptor to java name ( char [ ] field descriptor , boolean fully qualified ) {
char array buffer result = new char array buffer ( ) ; dcnl for ( int scan position = 0 ; scan position < field descriptor . length ; scan position + + ) { dcnl char next char = field descriptor [ scan position ] ;
char [ ] binary name = char util . substring ( field descriptor , scan position + 1 ) ;
/ / modify the binary name string in - place to change it into a fully qualified name dcnl char operation . replace ( binary name , ' / ' , ' . ' ) ; dcnl result . append ( binary name ) ; break ;
return result . get contents ( ) ;
* type variable , this object represents it .
*
public void set variable identifier ( char [ ] variable identifier ) {
public pdom type id ( pdom pdom , char [ ] field descriptor ) {
public class pdom variable extends pdom binding {
method . set default value ( create constant from mixed type ( default value ) ) ;
next pair . set value ( create constant from mixed type ( element . get value ( ) ) ) ;
public pdom constant create constant from mixed type ( object value ) {
import org . eclipse . jdt . internal . core . util . char array buffer ;
private static final char [ ] comma = new char [ ] { ' , ' } ;
private static final char [ ] path separator = new char [ ] { ' / ' } ;
import java . util . list ; dcnl
import org . eclipse . jdt . internal . core . nd . field . field string ;
public static final field string missing type names ;
missing type names = type . add string ( ) ;
import org . eclipse . jdt . internal . core . nd . field . struct def ;
* compares the given file with the receiver . if the fingerprint matches ( ie : the file
throw new core exception ( package . create status ( " an error occurred computing a hash code" , e ) ) ; / / $non - nls - 1$
@ suppress warnings ( "hiding" ) dcnl public static final struct def < nd tree node > type ;
public < t extends nd tree node > t get ancestor of type ( class < t > ancestor type ) { dcnl long target type = get pdom ( ) . get node type ( ancestor type ) ;
if ( ancestor type . is instance ( result ) ) {
@ suppress warnings ( "hiding" )
*
@ suppress warnings ( "hiding" )
/ / public static final field short variable flags ;
/ / public static final int flg variable field = 0x01 ; dcnl / / public static final int flg variable enum constant = 0x02 ; dcnl / / public static final int flg variable parameter = 0x04 ; dcnl / / public static final int flg variable effectively final = 0x08 ;
/ / variable flags = type . add short ( ) ;
public void destruct ( nd pdom , long address , tag tree reader reader ) { dcnl / / nothing to do by default dcnl }
protected void destruct ( nd pdom , long address ) { dcnl / / nothing to do by default dcnl } dcnl
@ suppress warnings ( "unchecked" )
@ suppress warnings ( "rawtypes" )
handler . write ( pdom , address , this , to write , bytes written ) ;
@ suppress warnings ( "unchecked" )
@ suppress warnings ( "rawtypes" )
* provides functionality similar to a map , with the feature that char arrays
*
* can be directly used as map keys . this avoids the need to create many string
*
*
*
* @ param < v >
*
final char [ ] buffer ; dcnl final int start ; dcnl final int length ;
dcnl @ override
if ( this = = x )
if ( ! ( x instanceof key ) )
if ( this . length ! = k . length )
dcnl for ( int i = this . start , j = k . start ; i < this . length ; i + + , j + + ) { dcnl if ( this . buffer [ i ] ! = k . buffer [ j ] ) {
dcnl @ override
for ( int i = this . start ; i < this . start + this . length ; i + + ) { dcnl result = 37 * result + this . buffer [ i ] ;
@ override
string slice = new string ( this . buffer , this . start , this . length ) ; dcnl return "'" + slice + "' @ ( " + this . start + " , " + this . length + " ) " ;
dcnl
char [ ] b1 = this . buffer , b2 = other . buffer ; dcnl dcnl for ( int i = this . start , j = other . start ; i < b1 . length & & j < b2 . length ; i + + , j + + ) {
* used to enforce preconditions .
*
dcnl
this . map = new hash map < key , v > ( ) ;
dcnl
*
dcnl
dcnl
this . map = new hash map < key , v > ( initial capacity ) ;
this . map . put ( new key ( chars , start , length ) , value ) ;
this . map . put ( new key ( chars ) , value ) ;
* returns the value to which the specified array slice is mapped in this map , dcnl * or null if the map contains no mapping for this key .
return this . map . get ( new key ( chars , start , length ) ) ;
* returns the value to which the specified array is mapped in this map , dcnl * or null if the map contains no mapping for this key .
return this . map . get ( new key ( chars ) ) ;
return this . map . remove ( new key ( chars , start , length ) ) ;
return this . map . remove ( new key ( chars ) ) ;
return this . map . contains key ( new key ( chars , start , length ) ) ;
return this . map . contains key ( new key ( chars ) ) ;
return this . map . contains value ( value ) ;
/ * *
return this . map . values ( ) ;
set < key > keys = this . map . key set ( ) ;
this . map . clear ( ) ;
return this . map . size ( ) ;
return this . map . is empty ( ) ;
dcnl
@ override
return this . map . to string ( ) ;
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
i type annotation walker supertype annotations = type annotations . to supertype ( ( short ) - 1 , dcnl binary type . get superclass name ( ) ) ;
new nd type interface ( get pdom ( ) , type , dcnl create type signature ( type annotations . to supertype ( interface idx , interface spec ) , signature wrapper ) ) ;
*
create type signature ( type annotations . to method parameter ( parameter idx ) , signature ) ) ;
new nd method exception ( method , create type signature ( type annotations . to throws ( throws idx ) , signature ) ) ;
method . set method id ( create method id ( binary type name , next . get selector ( ) , next . get method descriptor ( ) ) ) ;
* reads and attaches any generic type parameters at the current start position in the given wrapper . sets dcnl * wrapper . start to the character following the type parameters . dcnl *
annotation walker . to type parameter ( true , parameter index ) . to type bound ( ( short ) bound index ) , wrapper ) ;
* wrapper . start . on return , wrapper . start will point to the first character following the type signature . returns dcnl * null if given an empty signature or the signature for the void type .
* @ param annotations dcnl * the type annotations for this type dcnl * @ param wrapper dcnl * the generic signature to parse
private nd type signature create type signature ( i type annotation walker annotations , signature wrapper wrapper ) dcnl throws core exception {
type signature . set raw type ( create type id from field descriptor ( new char [ ] { ' [ ' } ) ) ;
case 'v' : dcnl return null ;
return create type id from field descriptor ( new char [ ] { first char } ) ;
* parses a class type signature ( as described in section 4 . 7 . 9 . 1 of the java vm specification java se 8 edition ) . the dcnl * read pointer should be located just after the identifier . the caller is expected to have already read the field dcnl * descriptor for the type .
field descriptor = char array utils . concat ( parent type or null . get raw type ( ) . get field descriptor ( ) . get chars ( ) , dcnl new char [ ] { '$' } , identifier ) ;
boolean has generic arguments = ( generic signature . length > wrapper . start ) dcnl & & generic signature [ wrapper . start ] = = ' < ' ;
switch ( generic signature [ wrapper . start ] ) {
nd type signature next signature = create type signature ( annotations . to type argument ( argument index ) , dcnl wrapper ) ;
for ( i binary annotation next : annotation list ) {
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
*
*
*
*
*
*
*
*
import org . eclipse . jdt . internal . core . nd . java . file fingerprint . fingerprint test result ;
private job rescan job = job . create ( messages . indexer updating index job name , new i core runnable ( ) {
package . log info ( " indexer running rescan" ) ; / / $non - nls - 1$
double average fingerprint time ms = all roots . size ( ) = = 0 ? 0 : ( double ) fingerprint time ms / ( double ) all roots . size ( ) ;
" indexing done . \ n" / / $non - nls - 1$ dcnl + " located " + total roots + " roots in " + locate roots time ms + "ms \ n" / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ dcnl + " tested " + all roots . size ( ) + " fingerprints in " + fingerprint time ms + "ms , average time = " + average fingerprint time ms + "ms \ n" / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ / / $non - nls - 4$ dcnl + " indexed " + classes indexed + " classes in " + indexing time ms + "ms , average time = " + average index time ms + "ms \ n" ) ; / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ / / $non - nls - 4$
package . log ( "the file " + path string + " does not exist" , null ) ; / / $non - nls - 1$ / / $non - nls - 2$
package . log info ( "rescanning " + the path . to string ( ) ) ; / / $non - nls - 1$
*
*
set < i resource > resources to scan = new hash set < > ( ) ;
if ( objects . equals ( extension , "class" ) ) { / / $non - nls - 1$ dcnl i java element element = java core . create ( file ) ;
}
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
return char array utils . substring ( binary name , skip index ) ;
char [ ] result = char array utils . concat ( field descriptor prefix , fully qualified name ) ;
return char array utils . concat ( filename , jar file entry separator , binary name to resource relative path ( binary name ) ) ;
return char array utils . concat ( field descriptor prefix , binary name ) ;
char [ ] binary name = char array utils . substring ( field descriptor , scan position + 1 ) ;
return char array utils . concat ( field descriptor prefix , parent type binary name , method id separator , dcnl method selector and descriptor ) ;
return char array utils . concat ( field descriptor prefix , parent type binary name , method id separator , method selector , dcnl method descriptor ) ;
if ( char array utils . starts with ( field descriptor , 'l' ) ) { dcnl return char array utils . substring ( field descriptor , 1 ) ;
public static final char [ ] concat ( char [ ] first , char [ ] second , char [ ] third ) { dcnl if ( first = = null ) dcnl return concat ( second , third ) ; dcnl if ( second = = null ) dcnl return concat ( first , third ) ; dcnl if ( third = = null ) dcnl return concat ( first , second ) ; dcnl dcnl int length1 = first . length ; dcnl int length2 = second . length ; dcnl int length3 = third . length ; dcnl char [ ] result = new char [ length1 + length2 + length3 ] ; dcnl system . arraycopy ( first , 0 , result , 0 , length1 ) ; dcnl system . arraycopy ( second , 0 , result , length1 , length2 ) ; dcnl system . arraycopy ( third , 0 , result , length1 + length2 , length3 ) ; dcnl return result ; dcnl } dcnl dcnl public static final char [ ] concat ( char [ ] first , char [ ] second , char [ ] third , char [ ] fourth ) { dcnl if ( first = = null ) dcnl return concat ( second , third , fourth ) ; dcnl if ( second = = null ) dcnl return concat ( first , third , fourth ) ; dcnl if ( third = = null ) dcnl return concat ( first , second , fourth ) ; dcnl if ( fourth = = null ) dcnl return concat ( first , second , third ) ; dcnl dcnl int length1 = first . length ; dcnl int length2 = second . length ; dcnl int length3 = third . length ; dcnl int length4 = fourth . length ; dcnl char [ ] result = new char [ length1 + length2 + length3 + length4 ] ; dcnl system . arraycopy ( first , 0 , result , 0 , length1 ) ; dcnl system . arraycopy ( second , 0 , result , length1 , length2 ) ; dcnl system . arraycopy ( third , 0 , result , length1 + length2 , length3 ) ; dcnl system . arraycopy ( third , 0 , result , length1 + length2 + length3 , length4 ) ; dcnl return result ; dcnl } dcnl dcnl / * * dcnl * answers a new array which is the concatenation of all the given arrays . dcnl * dcnl * @ param to catenate dcnl * @ since 3 . 12 dcnl * / dcnl public static char [ ] concat ( char [ ] . . . to catenate ) { dcnl int total size = 0 ; dcnl for ( char [ ] next : to catenate ) { dcnl total size + = next . length ; dcnl } dcnl dcnl char [ ] result = new char [ total size ] ; dcnl int write index = 0 ; dcnl for ( char [ ] next : to catenate ) { dcnl if ( next = = null ) { dcnl continue ; dcnl } dcnl system . arraycopy ( next , 0 , result , write index , next . length ) ; dcnl write index + = next . length ; dcnl } dcnl return result ; dcnl } dcnl
/ / nothing to do
public void destruct fields ( nd dom , long address ) { dcnl / / no nested fields by default dcnl }
* * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /
return this . full path ;
return this . uri ;
return this . uri . equals ( ( ( i index file location ) obj ) . get uri ( ) ) ;
return this . uri . hash code ( ) ;
if ( this . full path = = null ) { dcnl return this . uri . to string ( ) ;
/ / public static final int linkages = database . data area ;
/ / private void set cleared ( ) { dcnl / / this . f cleared = true ; dcnl / / this . f reloaded = false ; dcnl / / this . f new files = false ; dcnl / / dcnl / / this . f cleared files . clear ( ) ; dcnl / / this . f files written . clear ( ) ; dcnl / / }
return this . f cleared ;
this . f reloaded = true ;
return this . f reloaded ;
this . f new files = true ;
return this . f new files ;
return !this . f cleared & & !this . f reloaded & & !this . f new files & & this . f cleared files . is empty ( ) & & dcnl this . f files written . is empty ( ) ;
package . log ( " earlier deletion stack was this : " , this . pending deletions . get ( address of node to delete ) ) ; / / $non - nls - 1$
this . f path = db path ; dcnl final boolean lock db = this . db = = null | | this . lock count ! = 0 ;
this . db = new database ( this . f path , cache , get default version ( ) , is permanently read only ( ) ) ;
this . db . set locked ( lock db ) ;
package . log ( " index database is uses an unsupported version " + this . db . get version ( ) / / $non - nls - 1$ dcnl + " deleting and recreating . " , null ) ; / / $non - nls - 1$ dcnl this . db . close ( ) ; dcnl this . f path . delete ( ) ; dcnl this . db = new database ( this . f path , cache , get default version ( ) , is permanently read only ( ) ) ; dcnl this . db . set locked ( lock db ) ;
this . db . set locked ( this . lock count ! = 0 ) ;
return this . db ;
synchronized ( this . mutex ) { dcnl + + this . waiting readers ;
while ( this . lock count < 0 ) dcnl this . mutex . wait ( ) ;
- - this . waiting readers ;
+ + this . lock count ; dcnl this . db . set locked ( true ) ;
inc read lock ( this . f lock debugging ) ;
synchronized ( this . mutex ) { dcnl assert this . lock count > 0 : " no lock to release" ; / / $non - nls - 1$
dec read lock ( this . f lock debugging ) ;
this . last read access = system . current time millis ( ) ; dcnl if ( this . lock count > 0 ) dcnl - - this . lock count ; dcnl this . mutex . notify all ( ) ; dcnl this . db . set locked ( this . lock count ! = 0 ) ;
* @ throws operation canceled exception
synchronized ( this . mutex ) {
assert this . lock count > = giveup read locks : " not enough locks to release" ; / / $non - nls - 1$ dcnl if ( this . lock count < giveup read locks ) { dcnl giveup read locks = this . lock count ;
while ( this . lock count > giveup read locks | | this . waiting readers > 0 ) { dcnl this . mutex . wait ( cancellation check interval ) ;
this . lock count = - 1 ;
this . time write lock acquired = system . current time millis ( ) ; dcnl this . db . set exclusive lock ( ) ;
assert this . lock count = = - 1 ; dcnl if ( !this . f event . is trivial ( ) ) dcnl this . last write access = system . current time millis ( ) ; dcnl / / final change event event = this . f event ; dcnl this . f event = new change event ( ) ; dcnl synchronized ( this . mutex ) {
long time held = this . last write access - this . time write lock acquired ;
if ( this . lock count < 0 ) dcnl this . lock count = establish read locks ; dcnl this . mutex . notify all ( ) ; dcnl this . db . set locked ( this . lock count ! = 0 ) ;
this . f traces . add ( thread . current thread ( ) . get stack trace ( ) ) ; dcnl return this . f traces . size ( ) ;
system . out . println ( " thread : '" + thread name + "' : " + this . f read locks + " readlocks , " + this . f write locks + " writelocks" ) ; dcnl for ( stack trace element [ ] trace : this . f traces ) {
this . f read locks + = val . f read locks ; dcnl this . f write locks + = val . f write locks ; dcnl this . f traces . add all ( val . f traces ) ;
debug lock info info = get lock info ( this . f lock debugging ) ;
output read locks ( this . f lock debugging ) ;
debug lock info info = get lock info ( this . f lock debugging ) ;
this . f lock debugging . remove ( thread . current thread ( ) ) ;
system . out . println ( " lockcount = " + this . lock count + " , giveup read locks = " + giveup read locks + " , waiting readers = " + this . waiting readers ) ; dcnl output read locks ( this . f lock debugging ) ;
debug lock info myval = this . f lock debugging . get ( th ) ;
this . f lock debugging . put ( th , myval ) ;
this . hashed offset = 0 ; dcnl this . state = 0 ; dcnl this . a = this . b = this . c = ( int ) seed ; dcnl this . c + = seed > > > 32 ;
for ( int pos = 0 ; pos < chunk . length ; pos + + , this . hashed offset + + ) {
switch ( this . state + + ) {
this . previous character = cc ;
this . a + = this . previous character | ( cc < < 16 ) ;
this . b + = this . previous character | ( cc < < 16 ) ;
this . c + = this . previous character | ( cc < < 16 ) ;
this . state = 0 ;
if ( this . state < 0 ) {
switch ( this . state ) {
this . a + = this . previous character ;
this . b + = this . previous character ;
this . c + = this . previous character ;
this . state = - 1 ; / / protect against subsequent calls .
return ( this . c & 0x ffffffffl ) | ( ( long ) this . b < < 32 ) ;
this . a - = this . c ; this . a ^ = integer . rotate left ( this . c , 4 ) ; this . c + = this . b ; dcnl this . b - = this . a ; this . b ^ = integer . rotate left ( this . a , 6 ) ; this . a + = this . c ; dcnl this . c - = this . b ; this . c ^ = integer . rotate left ( this . b , 8 ) ; this . b + = this . a ; dcnl this . a - = this . c ; this . a ^ = integer . rotate left ( this . c , 16 ) ; this . c + = this . b ; dcnl this . b - = this . a ; this . b ^ = integer . rotate left ( this . a , 19 ) ; this . a + = this . c ; dcnl this . c - = this . b ; this . c ^ = integer . rotate left ( this . b , 4 ) ; this . b + = this . a ;
return this . element factory . create ( this . raw list . get nd ( ) , address ) ;
visitor . visit ( local element factory . create ( local raw list . get nd ( ) ,
type = new nd type ( get nd ( ) , this . resource ) ;
new nd type interface ( get nd ( ) , type , make type id ( next ) ) ;
private nd get nd ( ) {
type = new nd type ( get nd ( ) , this . resource ) ;
new nd type interface ( get nd ( ) , type ,
variable . set constant ( nd constant . create ( get nd ( ) , next field . get constant ( ) ) ) ;
nd complex type signature type signature = new nd complex type signature ( get nd ( ) ) ;
nd complex type signature type signature = new nd complex type signature ( get nd ( ) ) ;
nd type argument type argument = new nd type argument ( get nd ( ) , type signature ) ;
nd complex type signature type signature = new nd complex type signature ( get nd ( ) ) ;
nd type argument type argument = new nd type argument ( get nd ( ) , type signature ) ;
nd annotation result = new nd annotation ( get nd ( ) , create type id from binary name ( next . get type name ( ) ) ) ;
return nd constant . create ( get nd ( ) , constant ) ;
return nd constant class . create ( get nd ( ) , type id ) ;
return nd constant annotation . create ( get nd ( ) , create annotation ( binary annotation ) ) ;
public nd get nd ( ) {
*
/ / pdom tag index . set tags ( get nd ( ) , pdom binding . address , collections . < i tag > empty list ( ) ) ;
/ / return new pdom taggable ( get nd ( ) , get record ( ) ) ;
/ / new pdom external references list ( get nd ( ) , address + first extref offset ) . add ( name ) ;
/ / return new pdom external references list ( get nd ( ) , address + first extref offset ) . get iterator ( ) ;
/ / new pdom external references list ( get nd ( ) , address + first extref offset ) . set first reference ( linkage , name ) ;
/ / new pdom external references list ( get nd ( ) , address + first extref offset ) . add ( name ) ;
/ / return ( variable flags . get ( get nd ( ) , this . address ) & to test ) ! = 0 ;
import org . eclipse . jdt . internal . core . nd . field . field byte ;
public static final field string source file name ; dcnl public static final field byte flags ;
source file name = type . add string ( ) ; dcnl flags = type . add byte ( ) ;
public static final byte flg type anonymous = 0x0001 ; dcnl public static final byte flg type local = 0x0002 ; dcnl public static final byte flg type member = 0x0004 ;
private static final char [ ] empty char array = new char [ 0 ] ;
char [ ] missing type string = get missing type string ( missing type names ) ; dcnl dcnl type . set missing type names ( missing type string ) ; dcnl dcnl return type ; dcnl } dcnl dcnl private static char [ ] get missing type string ( char [ ] [ ] [ ] missing type names ) { dcnl char [ ] missing type string = null ;
missing type string = builder . get contents ( ) ;
import org . eclipse . jdt . internal . core . nd . db . i string ;
private i reader f reader = new i reader ( ) { dcnl @ override dcnl public void close ( ) { dcnl release read lock ( ) ; dcnl } dcnl } ; dcnl
public i reader acquire read lock ( ) {
import java . util . list ; dcnl
import java . util . array list ; dcnl import java . util . collections ;
@ override dcnl public list < nd annotation > get annotations ( ) { dcnl return annotations . as list ( get nd ( ) , this . address ) ; dcnl } dcnl dcnl @ override dcnl public nd type signature get array dimension type ( ) { dcnl if ( is array type ( ) ) { dcnl long size = type arguments . size ( get nd ( ) , this . address ) ; dcnl dcnl if ( size ! = 1 ) { dcnl throw new index exception ( " array types should have exactly one argument" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl return type arguments . get ( get nd ( ) , this . address , 0 ) . get type ( ) ; dcnl } dcnl return null ; dcnl } dcnl
nd type signature array dimension = get array dimension type ( ) ; dcnl if ( array dimension ! = null ) {
array dimension . get signature ( result ) ;
import org . eclipse . jdt . internal . compiler . impl . constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ;
import org . eclipse . jdt . internal . compiler . impl . boolean constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . constant ;
import org . eclipse . jdt . internal . compiler . impl . byte constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . constant ;
import org . eclipse . jdt . internal . compiler . impl . char constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . double constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ;
public nd type signature get type ( ) {
import org . eclipse . jdt . internal . compiler . impl . constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . float constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . int constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . long constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . short constant ;
import org . eclipse . jdt . internal . compiler . impl . constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . string constant ;
import java . util . collections ;
@ override dcnl public list < nd annotation > get annotations ( ) { dcnl return collections . empty list ( ) ; dcnl } dcnl
/ * * dcnl * returns the set of type annotations attached to this type signature dcnl * / dcnl public abstract list < nd annotation > get annotations ( ) ; dcnl
import org . eclipse . jdt . internal . core . nd . db . empty string ;
private int offset ;
/ * * dcnl * sets the value of the key and inserts it into the index if it is not already present dcnl * /
cleanup ( pdom , address ) ;
database db = pdom . get db ( ) ; dcnl b tree btree = this . search index . get ( pdom , database . data area ) ; dcnl db . put rec ptr ( address + this . offset , db . new string ( new string ) . get record ( ) ) ;
database db = pdom . get db ( ) ; dcnl long namerec = db . get rec ptr ( address + this . offset ) ; dcnl dcnl if ( namerec = = 0 ) { dcnl return empty string . create ( ) ; dcnl } dcnl return db . get string ( namerec ) ;
cleanup ( pdom , address ) ; dcnl } dcnl dcnl private void cleanup ( nd pdom , long address ) { dcnl boolean is in index = is in index ( pdom , address ) ; dcnl dcnl if ( is in index ) { dcnl / / remove this entry from the search index dcnl this . search index . get ( pdom , database . data area ) . delete ( address ) ; dcnl dcnl get ( pdom , address ) . delete ( ) ; dcnl pdom . get db ( ) . put rec ptr ( address + this . offset , 0 ) ; dcnl } dcnl } dcnl dcnl / * * dcnl * clears this key and removes it from the search index dcnl * / dcnl public void remove from index ( nd nd , long address ) { dcnl cleanup ( nd , address ) ; dcnl } dcnl dcnl / * * dcnl * returns true iff this key is currently in the index dcnl * / dcnl public boolean is in index ( nd pdom , long address ) { dcnl long field address = address + this . offset ; dcnl database db = pdom . get db ( ) ; dcnl long namerec = db . get rec ptr ( field address ) ;
boolean is in index = namerec ! = 0 ; dcnl return is in index ;
case nd type argument . wildcard question : result . append ( ' * ' ) ; return ;
/ * * dcnl * this long is incremented every time a change is written to the database . can be used to determine if the database dcnl * has changed . dcnl * / dcnl private long f write number ; dcnl
public long get write number ( ) { dcnl return this . f write number ; dcnl } dcnl
this . f write number = this . db . get long ( database . write number offset ) ;
* offset content dcnl * dcnl * 0 | version number dcnl * int size | pointer to head of linked list of blocks of size min block deltas * block size delta dcnl * . . | . . . dcnl * int size * m ( 1 ) | pointer to head of linked list of blocks of size ( m + min block deltas ) * block size delta dcnl * write number offset | long integer which is incremented on every write dcnl * data area | undefined ( pdom stores its own house - keeping data in this area )
static final int current version = nd . version ( 1 , 20 ) ; dcnl static final int max supported version = nd . version ( 1 , 20 ) ; dcnl static final int min supported version = nd . version ( 1 , 20 ) ;
char [ ] field descriptor = java names . binary name to field descriptor ( binary name ) ; dcnl nd type id name = create type id from field descriptor ( field descriptor ) ;
type . set source name override ( binary type . get source name ( ) ) ;
return index tester . is equal ( this . annotation . get annotation ( ) , other annotation . get annotation ( ) ) ;
/ / commented this out because the "expected" values often appear to be invalid paths when the "actual" dcnl / / ones are correct . dcnl / / assert equals ( " the file name did not match" , expected . get file name ( ) , actual . get file name ( ) ) ; / / $non - nls - 1$
static < t > boolean is equal ( t o1 , t o2 ) {
if ( o1 instanceof class signature ) { dcnl if ( ! ( o2 instanceof class signature ) ) { dcnl return false ; dcnl } dcnl dcnl class signature sig1 = ( class signature ) o1 ; dcnl class signature sig2 = ( class signature ) o2 ; dcnl dcnl return arrays . equals ( sig1 . get type name ( ) , sig2 . get type name ( ) ) ; dcnl } dcnl dcnl if ( o1 instanceof i binary annotation ) { dcnl i binary annotation binary annotation = ( i binary annotation ) o1 ; dcnl i binary annotation other binary annotation = ( i binary annotation ) o2 ; dcnl i binary element value pair [ ] element value pairs = binary annotation . get element value pairs ( ) ; dcnl i binary element value pair [ ] other element value pairs = other binary annotation . get element value pairs ( ) ; dcnl dcnl if ( element value pairs . length ! = other element value pairs . length ) { dcnl return false ; dcnl } dcnl dcnl for ( int idx = 0 ; idx < element value pairs . length ; idx + + ) { dcnl i binary element value pair next = element value pairs [ idx ] ; dcnl i binary element value pair other next = other element value pairs [ idx ] ; dcnl dcnl char [ ] next name = next . get name ( ) ; dcnl char [ ] other next name = other next . get name ( ) ; dcnl dcnl if ( ! arrays . equals ( next name , other next name ) ) { dcnl return false ; dcnl } dcnl dcnl if ( !is equal ( next . get value ( ) , other next . get value ( ) ) ) { dcnl return false ; dcnl } dcnl } dcnl return true ; dcnl } dcnl dcnl if ( o1 instanceof constant ) { dcnl if ( ! ( o2 instanceof constant ) ) { dcnl return false ; dcnl } dcnl dcnl constant const1 = ( constant ) o1 ; dcnl constant const2 = ( constant ) o2 ; dcnl dcnl return const1 . has same value ( const2 ) ; dcnl } dcnl dcnl if ( o1 instanceof enum constant signature ) { dcnl if ( ! ( o2 instanceof enum constant signature ) ) { dcnl return false ; dcnl } dcnl dcnl enum constant signature enum1 = ( enum constant signature ) o1 ; dcnl enum constant signature enum2 = ( enum constant signature ) o2 ; dcnl dcnl return arrays . equals ( enum1 . get enum constant name ( ) , enum2 . get enum constant name ( ) ) dcnl & & arrays . equals ( enum1 . get type name ( ) , enum2 . get type name ( ) ) ; dcnl } dcnl
assert equals ( " the default values didn't match . " , expected method . get default value ( ) , / / $non - nls - 1$ dcnl actual method . get default value ( ) ) ;
if ( !is equal ( expected binary annotations [ idx ] , actual binary annotations [ idx ] ) ) {
/ * * dcnl * converts a binary name to a field descriptor ( without the trailing ' ; ' ) dcnl * /
/ * * dcnl * converts a field descriptor to a java name . if fully qualified is true , it returns a fully qualified class name . dcnl * if it is false , it returns a source name . dcnl * /
int end = field descriptor . length - 1 ; dcnl char [ ] binary name = char array utils . subarray ( field descriptor , scan position + 1 , end ) ;
result . append ( binary name ) ;
result . append ( binary name to simple name ( binary name ) ) ;
scan position + = binary name . length ; dcnl break ;
* given a field descriptor , if the field descriptor points to a class this returns the binary name of the class . if dcnl * the field descriptor points to any other type , this returns the empty string . the field descriptor may optionally dcnl * contain a trailing ' ; ' .
int end = field descriptor . length - 1 ; dcnl return char array utils . subarray ( field descriptor , 1 , end ) ;
result . append ( get raw type ( ) . get field descriptor without trailing semicolon ( ) ) ;
/ * * dcnl * sets the source name for this type . dcnl * / dcnl public void set source name override ( char [ ] source name ) { dcnl char [ ] old source name = get source name ( ) ; dcnl if ( ! char array utils . equals ( old source name , source name ) ) { dcnl inner class source name . put ( get nd ( ) , this . address , source name ) ; dcnl }
public i string get source name override ( ) { dcnl return inner class source name . get ( get nd ( ) , this . address ) ;
i string source name = get source name override ( ) ; dcnl if ( source name . length ( ) ! = 0 ) { dcnl return source name . get chars ( ) ;
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
/ * * dcnl * returns the field descriptor . dcnl * /
char [ ] name , long tag bits , i binary type annotation [ ] type annotations , char [ ] field descriptor ) {
import org . eclipse . jdt . internal . core . nd . java . nd type id ;
. set argument names ( get argument names ( nd method ) ) . set default value ( unpack value ( nd method . get default value ( ) ) )
private char [ ] [ ] get argument names ( nd method nd method ) { dcnl / / unlike what its java doc says , i binary type returns an empty array if no argument names are available , so dcnl / / we replicate this weird undocumented corner case here . dcnl char [ ] [ ] result = nd method . get argument names ( ) ; dcnl int last non empty = - 1 ; dcnl for ( int idx = 0 ; idx < result . length ; idx + + ) { dcnl if ( result [ idx ] ! = null & & result [ idx ] . length ! = 0 ) { dcnl last non empty = idx ; dcnl } dcnl } dcnl dcnl if ( last non empty ! = result . length - 1 ) { dcnl char [ ] [ ] new result = new char [ last non empty + 1 ] [ ] ; dcnl system . arraycopy ( result , 0 , new result , 0 , last non empty + 1 ) ; dcnl return new result ; dcnl } dcnl return result ; dcnl } dcnl
if ( constant = = null ) { dcnl constant = constant . not a constant ; dcnl }
tag bits , type annotation array , type . get raw type ( ) . get field descriptor ( ) . get chars ( ) ) ;
final char [ ] binary name = java names . field descriptor to binary name ( dcnl nd annotation . get type ( ) . get raw type ( ) . get field descriptor ( ) . get chars ( ) ) ;
dcnl if ( type parameter signatures ! = null ) { dcnl for ( char [ ] next : type parameter signatures ) { dcnl if ( next = = null ) { dcnl throw new illegal argument exception ( " parameter's type signature must not be null" ) ; / / $non - nls - 1$ dcnl } dcnl } dcnl }
import org . eclipse . jdt . internal . core . nd . indexer . indexer ; dcnl import org . eclipse . jdt . internal . core . nd . java . java index ; dcnl import org . eclipse . jdt . internal . core . nd . java . model . binary type factory ;
@ override
private static final char [ ] inner type separator = new char [ ] { '$' } ; dcnl private static final char [ ] field descriptor suffix = new char [ ] { ' ; ' } ;
inner type separator , identifier , field descriptor suffix ) ;
import java . util . objects ;
import org . eclipse . jdt . internal . compiler . env . i binary field ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary method ;
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
i binary type annotation [ ] actual type annotations = actual . get type annotations ( ) ; dcnl dcnl compare type annotations ( expected type annotations , actual type annotations ) ; dcnl dcnl i binary annotation [ ] expected binary annotations = expected . get annotations ( ) ; dcnl i binary annotation [ ] actual binary annotations = actual . get annotations ( ) ; dcnl dcnl compare annotations ( expected binary annotations , actual binary annotations ) ; dcnl dcnl if ( expected . get generic signature ( ) ! = null ) { dcnl assert equals ( " the generic signature did not match" , expected . get generic signature ( ) , / / $non - nls - 1$ dcnl actual . get generic signature ( ) ) ; dcnl }
assert equals ( " the enclosing method name did not match" , expected . get enclosing method ( ) , / / $non - nls - 1$ dcnl actual . get enclosing method ( ) ) ; dcnl assert equals ( " the enclosing method name did not match" , expected . get enclosing type name ( ) , / / $non - nls - 1$ dcnl actual . get enclosing type name ( ) ) ; dcnl dcnl i binary field [ ] expected fields = expected . get fields ( ) ; dcnl i binary field [ ] actual fields = actual . get fields ( ) ; dcnl dcnl if ( expected fields ! = actual fields ) { dcnl if ( expected fields = = null & & actual fields ! = null ) { dcnl throw new illegal state exception ( " expected fields was null - - actual fields were not" ) ; / / $non - nls - 1$ dcnl } dcnl if ( expected fields . length ! = actual fields . length ) { dcnl throw new illegal state exception ( " the expected and actual number of fields did not match" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl for ( int field idx = 0 ; field idx < actual fields . length ; field idx + + ) { dcnl compare fields ( expected fields [ field idx ] , actual fields [ field idx ] ) ; dcnl } dcnl } dcnl dcnl assert equals ( " the file name did not match" , expected . get file name ( ) , actual . get file name ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the interface names did not match" , expected . get interface names ( ) , actual . get interface names ( ) ) ; / / $non - nls - 1$ dcnl dcnl / / member types are not expected to match during indexing since the index uses discovered cross - references , dcnl / / not the member types encoded in the . class file . dcnl / / expected . get member types ( ) ! = actual . get member types ( ) dcnl dcnl i binary method [ ] expected methods = expected . get methods ( ) ; dcnl i binary method [ ] actual methods = actual . get methods ( ) ; dcnl dcnl if ( expected methods ! = actual methods ) { dcnl if ( expected methods = = null | | actual methods = = null ) { dcnl throw new illegal state exception ( " one of the method arrays was null" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl if ( expected methods . length ! = actual methods . length ) { dcnl throw new illegal state exception ( " the number of methods didn't match" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl for ( int i = 0 ; i < actual methods . length ; i + + ) { dcnl i binary method actual method = actual methods [ i ] ; dcnl i binary method expected method = expected methods [ i ] ; dcnl dcnl compare methods ( expected method , actual method ) ; dcnl } dcnl } dcnl dcnl assert equals ( " the missing type names did not match" , expected . get missing type names ( ) , / / $non - nls - 1$ dcnl actual . get missing type names ( ) ) ; dcnl assert equals ( " the modifiers don't match" , expected . get modifiers ( ) , actual . get modifiers ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the names don't match . " , expected . get name ( ) , actual . get name ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the source name doesn't match" , expected . get source name ( ) , actual . get source name ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the superclass name doesn't match" , expected . get superclass name ( ) , actual . get superclass name ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the tag bits don't match . " , expected . get tag bits ( ) , actual . get tag bits ( ) ) ; / / $non - nls - 1$ dcnl dcnl compare type annotations ( expected . get type annotations ( ) , actual . get type annotations ( ) ) ; dcnl } dcnl dcnl private static < t > void assert equals ( string message , t o1 , t o2 ) { dcnl if ( !is equal ( o1 , o2 ) ) { dcnl throw new illegal state exception ( message ) ; dcnl } dcnl } dcnl dcnl private static < t > boolean is equal ( t o1 , t o2 ) { dcnl if ( o1 = = o2 ) { dcnl return true ; dcnl } dcnl dcnl if ( o1 = = null | | o2 = = null ) { dcnl return false ; dcnl } dcnl dcnl if ( o1 instanceof char [ ] ) { dcnl char [ ] c1 = ( char [ ] ) o1 ; dcnl char [ ] c2 = ( char [ ] ) o2 ; dcnl dcnl return char array utils . equals ( c1 , c2 ) ; dcnl } dcnl dcnl if ( o1 instanceof char [ ] [ ] ) { dcnl char [ ] [ ] c1 = ( char [ ] [ ] ) o1 ; dcnl char [ ] [ ] c2 = ( char [ ] [ ] ) o2 ; dcnl dcnl return char array utils . equals ( c1 , c2 ) ; dcnl } dcnl dcnl if ( o1 instanceof char [ ] [ ] [ ] ) { dcnl char [ ] [ ] [ ] c1 = ( char [ ] [ ] [ ] ) o1 ; dcnl char [ ] [ ] [ ] c2 = ( char [ ] [ ] [ ] ) o2 ; dcnl dcnl if ( c1 . length ! = c2 . length ) { dcnl return false ; dcnl } dcnl dcnl for ( int i = 0 ; i < c1 . length ; i + + ) { dcnl if ( !is equal ( c1 [ i ] , c2 [ i ] ) ) { dcnl return false ; dcnl } dcnl } dcnl return true ; dcnl } dcnl dcnl if ( o1 instanceof i binary method [ ] ) { dcnl i binary method [ ] a1 = ( i binary method [ ] ) o1 ; dcnl i binary method [ ] a2 = ( i binary method [ ] ) o2 ; dcnl dcnl if ( a1 . length ! = a2 . length ) { dcnl return false ; dcnl } dcnl dcnl for ( int i = 0 ; i < a1 . length ; i + + ) { dcnl i binary method m1 = a1 [ i ] ; dcnl i binary method m2 = a2 [ i ] ; dcnl dcnl compare methods ( m1 , m2 ) ; dcnl } dcnl } dcnl dcnl return objects . equals ( o1 , o2 ) ; dcnl } dcnl dcnl private static void compare methods ( i binary method expected method , i binary method actual method ) { dcnl assert equals ( " the annotated parameter count didn't match" , actual method . get annotated parameters count ( ) , / / $non - nls - 1$ dcnl expected method . get annotated parameters count ( ) ) ; dcnl dcnl compare annotations ( expected method . get annotations ( ) , actual method . get annotations ( ) ) ; dcnl dcnl assert equals ( " the argument names didn't match . " , expected method . get argument names ( ) , / / $non - nls - 1$ dcnl actual method . get argument names ( ) ) ; dcnl dcnl if ( !constants equal ( expected method . get default value ( ) , actual method . get default value ( ) ) ) { dcnl throw new illegal state exception ( " the default values didn't match . " ) ; / / $non - nls - 1$ dcnl } dcnl dcnl assert equals ( " the exception type names did not match . " , expected method . get exception type names ( ) , / / $non - nls - 1$ dcnl actual method . get exception type names ( ) ) ; dcnl dcnl if ( expected method . get generic signature ( ) ! = null ) { dcnl assert equals ( " the method's generic signature did not match" , expected method . get generic signature ( ) , / / $non - nls - 1$ dcnl actual method . get generic signature ( ) ) ; dcnl } dcnl dcnl assert equals ( " the method descriptors did not match . " , expected method . get method descriptor ( ) , / / $non - nls - 1$ dcnl actual method . get method descriptor ( ) ) ; dcnl assert equals ( " the modifiers didn't match . " , expected method . get modifiers ( ) , actual method . get modifiers ( ) ) ; / / $non - nls - 1$ dcnl dcnl for ( int idx = 0 ; idx < actual method . get annotated parameters count ( ) ; idx + + ) { dcnl char [ ] class file name = "" . to char array ( ) ; / / $non - nls - 1$ dcnl compare annotations ( expected method . get parameter annotations ( idx , class file name ) , dcnl actual method . get parameter annotations ( idx , class file name ) ) ; dcnl } dcnl dcnl assert equals ( " the selectors did not match" , expected method . get selector ( ) , actual method . get selector ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the tag bits did not match" , expected method . get tag bits ( ) , actual method . get tag bits ( ) ) ; / / $non - nls - 1$ dcnl dcnl compare type annotations ( expected method . get type annotations ( ) , actual method . get type annotations ( ) ) ; dcnl } dcnl dcnl private static void compare type annotations ( i binary type annotation [ ] expected type annotations , dcnl i binary type annotation [ ] actual type annotations ) { dcnl set < type annotation wrapper > expected annotations = new hash set < > ( ) ;
private static void compare annotations ( i binary annotation [ ] expected binary annotations , dcnl i binary annotation [ ] actual binary annotations ) { dcnl if ( expected binary annotations = = null ) { dcnl if ( actual binary annotations ! = null ) { dcnl throw new illegal state exception ( " expected null for the binary annotations" ) ; / / $non - nls - 1$ dcnl } else { dcnl return ; dcnl } dcnl } dcnl if ( actual binary annotations = = null ) { dcnl throw new illegal state exception ( " actual null for the binary annotations" ) ; / / $non - nls - 1$ dcnl } dcnl if ( expected binary annotations . length ! = actual binary annotations . length ) { dcnl throw new illegal state exception ( " the expected and actual number of annotations differed" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl for ( int idx = 0 ; idx < expected binary annotations . length ; idx + + ) { dcnl if ( !annotations equal ( expected binary annotations [ idx ] , actual binary annotations [ idx ] ) ) { dcnl throw new illegal state exception ( " an annotation had an unexpected value" ) ; / / $non - nls - 1$ dcnl } dcnl } dcnl } dcnl dcnl private static void compare fields ( i binary field field1 , i binary field field2 ) { dcnl compare annotations ( field1 . get annotations ( ) , field2 . get annotations ( ) ) ; dcnl if ( !constants equal ( field1 . get constant ( ) , field2 . get constant ( ) ) ) { dcnl throw new illegal state exception ( " constants not equal" ) ; / / $non - nls - 1$ dcnl } dcnl assert equals ( " the generic signature did not match" , field1 . get generic signature ( ) , field2 . get generic signature ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the modifiers did not match" , field1 . get modifiers ( ) , field2 . get modifiers ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the tag bits did not match" , field1 . get tag bits ( ) , field2 . get tag bits ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( " the names did not match" , field1 . get name ( ) , field2 . get name ( ) ) ; / / $non - nls - 1$ dcnl dcnl compare type annotations ( field1 . get type annotations ( ) , field2 . get type annotations ( ) ) ; dcnl assert equals ( " the type names did not match" , field1 . get type name ( ) , field2 . get type name ( ) ) ; / / $non - nls - 1$ dcnl } dcnl
if ( value = = value2 ) { dcnl return true ; dcnl } dcnl if ( value = = null ) { dcnl return value2 = = null ; dcnl } dcnl
/ / flush the database to disk dcnl this . pdom . acquire write lock ( sub monitor . new child ( 5 ) ) ; dcnl try { dcnl this . pdom . get db ( ) . flush ( ) ; dcnl } finally { dcnl this . pdom . release write lock ( ) ; dcnl } dcnl
i path next path = get location for element ( next ) ;
resource file . set location ( path string ) ;
i path root path string = get location for element ( package fragment root ) ;
i path filesystem path = get location for element ( next root ) ;
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
static final int current version = nd . version ( 1 , 24 ) ; dcnl static final int max supported version = nd . version ( 1 , 25 ) ; dcnl static final int min supported version = nd . version ( 1 , 25 ) ;
private static final char [ ] field descriptor prefix = new char [ ] { 'l' } ; dcnl private static final char [ ] field descriptor suffix = new char [ ] { ' ; ' } ; dcnl private static final char [ ] method id separator = new char [ ] { '#' } ;
if ( workspace location = = null | | workspace location . length = = 0 ) { dcnl workspace location = resource file . get location ( ) . get chars ( ) ;
return char array utils . concat ( field descriptor prefix , binary name , field descriptor suffix ) ;
char [ ] binary name = char array utils . subarray ( field descriptor , scan position + 1 , dcnl field descriptor . length - 1 ) ;
char [ ] next contents = get signature for ( next ) ; dcnl result [ idx ] = next contents ; dcnl idx + + ;
/ * * dcnl * returns a workspace path to this resource if possible and the absolute filesystem location if not . dcnl * / dcnl public i path get path ( ) { dcnl i path workspace path = get first workspace location ( ) ; dcnl dcnl if ( workspace path . is empty ( ) ) { dcnl return new path ( get location ( ) . get string ( ) ) ; dcnl } dcnl dcnl return workspace path ; dcnl } dcnl
public i string get location ( ) {
public void set location ( string filename ) {
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
final char [ ] file name = type . get resource file ( ) . get location ( ) . get chars ( ) ;
return type . get file ( ) . get path ( ) . to string ( ) . to char array ( ) ;
if ( variables . is empty ( ) ) { dcnl return null ; dcnl } dcnl
if ( interfaces . is empty ( ) ) { dcnl return null ; dcnl } dcnl
dcnl int new length = result . length ; dcnl while ( new length > 0 & & result [ new length - 1 ] = = null ) { dcnl - - new length ; dcnl } dcnl dcnl if ( new length < result . length ) { dcnl if ( new length = = 0 ) { dcnl return null ; dcnl } dcnl i binary annotation [ ] [ ] new result = new i binary annotation [ new length ] [ ] ; dcnl system . arraycopy ( result , 0 , new result , 0 , new length ) ; dcnl result = new result ; dcnl } dcnl
/ / although the java doc for i binary method says that the exception list will be null if empty , dcnl / / the implementation in method info returns an empty array rather than null . we copy the dcnl / / same behavior here in case something is relying on it . uncomment the following if the "null" dcnl / / version is deemed correct . dcnl dcnl / / if ( exceptions . is empty ( ) ) { dcnl / / return null ; dcnl / / }
if ( signature = = null ) { dcnl return ; dcnl }
@ override
declaring type . compute declaring types ( result ) ;
return index tester . annotations equal ( binary annotation , other binary annotation ) ;
import java . util . concurrent . locks . reentrant read write lock ;
/ / read - write lock rules . readers don't conflict with other readers , dcnl / / writers conflict with readers , and everyone conflicts with writers . dcnl private final object lock mutex = new object ( ) ; dcnl private long last write access = 0 ; dcnl private long last read access = 0 ; dcnl private reentrant read write lock lock ; dcnl
this . lock = new reentrant read write lock ( ) ;
/ / if ( s debug locks ) { dcnl / / this . f lock debugging = new hash map < > ( ) ; dcnl / / system . out . println ( " debugging pdom locks" ) ; / / $non - nls - 1$ dcnl / / }
final boolean lock db = this . db = = null ;
this . db . set locked ( true ) ;
this . db . set locked ( true ) ;
synchronized ( this . lock mutex ) { dcnl sync locked state ( ) ; dcnl } dcnl } dcnl dcnl void sync locked state ( ) { dcnl int write locks = this . lock . get write hold count ( ) ; dcnl int read locks = this . lock . get read lock count ( ) ; dcnl dcnl this . db . set locked ( write locks ! = 0 | | read locks ! = 0 ) ;
this . lock . read lock ( ) . lock ( ) ; dcnl synchronized ( this . lock mutex ) { dcnl sync locked state ( ) ;
return this . f reader ;
synchronized ( this . lock mutex ) { dcnl this . lock . read lock ( ) . unlock ( ) ; dcnl sync locked state ( ) ; dcnl this . last read access = system . current time millis ( ) ;
this . lock . write lock ( ) . lock ( ) ; dcnl this . db . set exclusive lock ( ) ;
synchronized ( this . lock mutex ) { dcnl int write hold count = this . lock . get write hold count ( ) ; dcnl assert write hold count > = 1 ; dcnl if ( write hold count = = 1 ) { dcnl process deletions ( ) ; dcnl this . db . put long ( database . write number offset , + + this . f write number ) ; dcnl clear result cache ( ) ; dcnl this . db . give up exclusive lock ( true ) ; dcnl this . last write access = system . current time millis ( ) ;
this . lock . write lock ( ) . unlock ( ) ; dcnl sync locked state ( ) ;
import org . eclipse . jdt . internal . core . nd . java . reference util ; dcnl import org . eclipse . jdt . internal . core . nd . java . model . index binary type ;
private static final boolean enable self test = true ;
import org . eclipse . jdt . internal . core . nd . java . java names ;
@ override
@ override
return java names . is clinit ( get selector ( ) ) ;
return java names . is constructor ( get selector ( ) ) ;
type . set tag bits ( binary type . get tag bits ( ) ) ;
int annotated parameters count = next . get annotated parameters count ( ) ;
if ( parameter idx < annotated parameters count ) { dcnl i binary annotation [ ] parameter annotations = next . get parameter annotations ( parameter idx , binary type name ) ; dcnl dcnl if ( parameter annotations ! = null ) { dcnl for ( i binary annotation next annotation : parameter annotations ) { dcnl create annotation ( next annotation ) . set parent ( parameter ) ; dcnl } dcnl } dcnl }
method . set tag bits ( next . get tag bits ( ) ) ;
public static final field many to one < nd method parameter > parent method parameter ;
parent method parameter = field many to one . create owner ( type , nd method parameter . annotations ) ;
public list < nd variable > get variables ( ) { dcnl return variables . as list ( get nd ( ) , this . address ) ; dcnl } dcnl
public list < nd annotation > get annotations ( ) { dcnl return annotations . as list ( get nd ( ) , this . address ) ;
import java . util . list ; dcnl
import org . eclipse . jdt . internal . core . nd . field . field long ;
public static final field long tag bits ;
tag bits = type . add long ( ) ;
public char [ ] [ ] get argument names ( ) { dcnl list < nd method parameter > params = get method parameters ( ) ; dcnl dcnl char [ ] [ ] result = new char [ params . size ( ) ] [ ] ; dcnl for ( int idx = 0 ; idx < result . length ; idx + + ) { dcnl result [ idx ] = params . get ( idx ) . get name ( ) . get chars ( ) ; dcnl } dcnl return result ; dcnl } dcnl dcnl public list < nd method parameter > get method parameters ( ) { dcnl return parameters . as list ( get nd ( ) , this . address ) ; dcnl } dcnl
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
import java . util . list ; dcnl
import org . eclipse . jdt . internal . core . nd . db . i string ;
import org . eclipse . jdt . internal . core . nd . field . field one to many ;
public static final field one to many < nd annotation > annotations ;
annotations = field one to many . create ( type , nd annotation . parent method parameter ) ;
public nd type signature get type ( ) { dcnl return argument type . get ( get nd ( ) , this . address ) ; dcnl } dcnl
import org . eclipse . jdt . internal . core . nd . field . field string ;
public static final field string java root ;
java root = type . add string ( ) ;
import org . eclipse . jdt . internal . core . nd . field . field long ;
public static final field long tag bits ;
tag bits = type . add long ( ) ;
@ override dcnl public list < nd type parameter > get type parameters ( ) { dcnl return type parameters . as list ( get nd ( ) , this . address ) ; dcnl } dcnl dcnl public list < nd method > get methods ( ) { dcnl return methods . as list ( get nd ( ) , this . address ) ; dcnl } dcnl
public list < nd type > get declared types ( ) { dcnl return declared types . as list ( get nd ( ) , this . address ) ; dcnl } dcnl
import org . eclipse . jdt . internal . core . nd . db . i string ;
import org . eclipse . jdt . internal . core . nd . field . field long ;
public static final field long tag bits ;
tag bits = type . add long ( ) ;
public i string get name ( ) { dcnl return name . get ( get nd ( ) , this . address ) ;
private long tag bits ;
if ( signature . start < signature . signature . length & & signature . char at start ( ) = = to skip ) {
field descriptor = char array utils . concat ( dcnl parent type or null . get raw type ( ) . get field descriptor without trailing semicolon ( ) ,
skip char ( wrapper , ' > ' ) ;
/ / identifiers shouldn't start with ' . ' dcnl skip char ( wrapper , ' . ' ) ;
import org . eclipse . jdt . internal . core . nd . db . index exception ;
dcnl char [ ] superclass field descriptor ; dcnl char [ ] superclass binary name = binary type . get superclass name ( ) ; dcnl if ( superclass binary name = = null ) { dcnl superclass field descriptor = java lang object field descriptor ; dcnl } else { dcnl superclass field descriptor = java names . binary name to field descriptor ( superclass binary name ) ; dcnl } dcnl type . set superclass ( create type signature ( supertype annotations , signature wrapper , superclass field descriptor ) ) ;
create type signature ( type annotations . to supertype ( interface idx , interface spec ) , signature wrapper , dcnl java names . binary name to field descriptor ( interface spec ) ) ) ;
signature wrapper descriptor = new signature wrapper ( next . get method descriptor ( ) ) ;
skip char ( signature , ' ( ' ) ; dcnl skip char ( descriptor , ' ( ' ) ;
char [ ] next field descriptor = read next field descriptor ( descriptor ) ; dcnl nd method parameter parameter = new nd method parameter ( method , create type signature ( dcnl type annotations . to method parameter ( parameter idx ) , signature , next field descriptor ) ) ;
skip char ( descriptor , ' ) ' ) ; dcnl char [ ] next field descriptor = read next field descriptor ( descriptor ) ; dcnl method . set return type ( create type signature ( type annotations . to method return ( ) , signature , next field descriptor ) ) ;
char [ ] [ ] exception types = next . get exception type names ( ) ;
new nd method exception ( method , create type signature ( type annotations . to throws ( throws idx ) , signature , dcnl java names . binary name to field descriptor ( exception types [ throws idx ] ) ) ) ;
private void skip char ( signature wrapper signature , char to skip ) { dcnl if ( signature . char at start ( ) = = to skip ) { dcnl signature . start + + ; dcnl } dcnl } dcnl
variable . set type ( create type signature ( annotation walker , next type signature , next field . get type name ( ) ) ) ;
annotation walker . to type parameter ( true , parameter index ) . to type bound ( ( short ) bound index ) , wrapper , dcnl java lang object field descriptor ) ;
private char [ ] read next field descriptor ( signature wrapper generic signature ) { dcnl int end position = find end of field descriptor ( generic signature ) ; dcnl dcnl char [ ] result = char array utils . subarray ( generic signature . signature , generic signature . start , end position ) ; dcnl generic signature . start = end position ; dcnl return result ; dcnl } dcnl dcnl private int find end of field descriptor ( signature wrapper generic signature ) { dcnl char [ ] signature = generic signature . signature ; dcnl dcnl if ( signature = = null | | signature . length = = 0 ) { dcnl return generic signature . start ; dcnl } dcnl int current = generic signature . start ; dcnl while ( current < signature . length ) { dcnl char first char = signature [ current ] ; dcnl switch ( first char ) { dcnl case 'l' : dcnl case 't' : { dcnl return char array utils . index of ( ' ; ' , signature , current , signature . length ) + 1 ; dcnl } dcnl case ' [ ' : { dcnl current + + ; dcnl break ; dcnl } dcnl case 'v' : dcnl case 'b' : dcnl case 'c' : dcnl case 'd' : dcnl case 'f' : dcnl case 'i' : dcnl case 'j' : dcnl case 's' : dcnl case 'z' : dcnl return current + 1 ; dcnl default : dcnl throw new index exception ( package . create status ( " field descriptor starts with unknown character : " / / $non - nls - 1$ dcnl + generic signature . to string ( ) ) ) ; dcnl } dcnl } dcnl return current ; dcnl } dcnl
* @ param generic signature
private nd type signature create type signature ( i type annotation walker annotations , signature wrapper generic signature , dcnl char [ ] field descriptor if variable )
char [ ] signature = generic signature . signature ;
if ( signature = = null | | signature . length = = 0 ) {
char first char = signature [ generic signature . start ] ;
generic signature . start + + ;
type signature . set raw type ( create type id from field descriptor ( field descriptor if variable ) ) ; dcnl type signature . set variable identifier ( generic signature . next word ( ) ) ;
generic signature . start + + ;
generic signature . start + + ;
nd type signature element type = create type signature ( annotations . to next array dimension ( ) , generic signature , dcnl char array utils . substring ( field descriptor if variable , 1 ) ) ; dcnl char [ ] computed field descriptor = char array utils . concat ( array field descriptor prefix ,
nd type id raw type = create type id from field descriptor ( computed field descriptor ) ;
generic signature . start + + ;
generic signature . start + + ;
return parse class type signature ( null , annotations , generic signature ) ;
+ generic signature . to string ( ) ) ) ;
+ generic signature . to string ( ) ) ) ;
char [ ] class file name = "" . to char array ( ) ; / / $non - nls - 1$ dcnl int min annotated parameters = math . min ( expected method . get annotated parameters count ( ) , dcnl actual method . get annotated parameters count ( ) ) ; dcnl for ( int idx = 0 ; idx < min annotated parameters ; idx + + ) {
for ( int idx = min annotated parameters ; idx < expected method . get annotated parameters count ( ) ; idx + + ) { dcnl compare annotations ( expected method . get parameter annotations ( idx , class file name ) , new i binary annotation [ 0 ] ) ; dcnl } dcnl for ( int idx = min annotated parameters ; idx < actual method . get annotated parameters count ( ) ; idx + + ) { dcnl compare annotations ( new i binary annotation [ 0 ] , expected method . get parameter annotations ( idx , class file name ) ) ; dcnl }
if ( expected binary annotations = = null | | expected binary annotations . length = = 0 ) { dcnl if ( actual binary annotations ! = null & & actual binary annotations . length ! = 0 ) {
public void get signature ( char array buffer result , boolean include trailing semicolon ) {
if ( include trailing semicolon ) { dcnl result . append ( ' ; ' ) ; dcnl }
if ( parent signature ! = null ) { dcnl parent signature . get signature ( result , false ) ; dcnl result . append ( ' . ' ) ; dcnl char [ ] simple name = get raw type ( ) . get simple name ( ) . get chars ( ) ; dcnl result . append ( simple name ) ; dcnl } else { dcnl result . append ( get raw type ( ) . get field descriptor without trailing semicolon ( ) ) ; dcnl }
char [ ] simple name = java names . field descriptor to java name ( field descriptor , false ) ;
private static final char [ ] java lang object field descriptor = " ljava / lang / object ; " . to char array ( ) ; / / $non - nls - 1$
/ / char [ ] [ ] exception type names = next . get exception type names ( ) ; dcnl / / int num exceptions = exception type names = = null ? 0 : exception type names . length ; dcnl / / dcnl / / if ( throws idx ! = num exceptions ) { dcnl / / throw new illegal state exception ( dcnl / / " the number of exceptions in get exception type names ( ) didn't match the number of exceptions in the generic dcnl / / signature" ) ; / / $non - nls - 1$ dcnl / / } dcnl
dcnl / / char [ ] field descriptor = next field . get type name ( ) ; dcnl / / / / do not submit : dcnl / / i binary field bf = index binary type . create binary field ( variable ) ;
parameter . set first bound is class ( true ) ;
parameter . set first bound is class ( false ) ;
char [ ] [ ] exception type names = next . get exception type names ( ) ;
signature = next . get method descriptor ( ) ; dcnl } dcnl dcnl / / the compiler is allowed to omit thrown exceptions from the generic signature dcnl / / if the thrown exceptions don't make use of generics or type variables . however , we rely dcnl / / on them so we reinsert the missing exception declarations if they're not present . dcnl if ( exception type names ! = null & & exception type names . length > 0 ) { dcnl / / if there are no exceptions mentioned the signature but there are exceptions dcnl / / in the i binary method , the compiler has omitted them . . . so put them back . dcnl if ( char array utils . index of ( ' ^ ' , signature ) = = - 1 ) {
builder . append ( signature ) ;
compare generic signatures ( " the generic signature did not match" , expected . get generic signature ( ) , / / $non - nls - 1$
if ( o1 instanceof object [ ] ) { dcnl object [ ] a1 = ( object [ ] ) o1 ; dcnl object [ ] a2 = ( object [ ] ) o2 ; dcnl dcnl if ( a1 . length ! = a2 . length ) { dcnl return false ; dcnl } dcnl dcnl for ( int idx = 0 ; idx < a1 . length ; idx + + ) { dcnl if ( !is equal ( a1 [ idx ] , a2 [ idx ] ) ) { dcnl return false ; dcnl } dcnl } dcnl return true ; dcnl } dcnl
compare generic signatures ( " the method's generic signature did not match" , expected method . get generic signature ( ) , / / $non - nls - 1$ dcnl actual method . get generic signature ( ) ) ;
import org . eclipse . jdt . internal . core . nd . field . field byte ;
public static final field byte type parameter flags ; dcnl dcnl public static final byte flg first bound is a class = 0x01 ;
type parameter flags = type . add byte ( ) ;
public void set first bound is class ( boolean is class ) { dcnl set flag ( flg first bound is a class , is class ) ; dcnl } dcnl dcnl public boolean is first bound a class ( ) { dcnl return ( type parameter flags . get ( get nd ( ) , this . address ) & flg first bound is a class ) ! = 0 ; dcnl } dcnl dcnl private void set flag ( byte flag , boolean value ) { dcnl byte old value = type parameter flags . get ( get nd ( ) , this . address ) ; dcnl byte new value ; dcnl if ( value ) { dcnl new value = ( byte ) ( old value | flag ) ; dcnl } else { dcnl new value = ( byte ) ( old value & ~ flag ) ; dcnl } dcnl type parameter flags . put ( get nd ( ) , this . address , new value ) ; dcnl } dcnl
@ override dcnl public string to string ( ) { dcnl return this . annotation . to string ( ) ; dcnl } dcnl
import org . eclipse . jdt . internal . compiler . classfmt . binary type printer ;
import org . eclipse . jdt . internal . compiler . classfmt . binary type printer ;
import org . eclipse . jdt . internal . compiler . classfmt . binary type printer ;
private static final char [ ] array field descriptor prefix = new char [ ] { ' [ ' } ;
/ / determine the array argument type dcnl nd type signature element type = create type signature ( annotations . to next array dimension ( ) , wrapper ) ; dcnl char [ ] field descriptor = char array utils . concat ( array field descriptor prefix , dcnl element type . get raw type ( ) . get field descriptor ( ) . get chars ( ) ) ; dcnl nd type id raw type = create type id from field descriptor ( field descriptor ) ; dcnl / / we encode signatures as though they were a one - argument generic type whose element
public boolean has field descriptor ( string name ) { dcnl return this . get field descriptor ( ) . compare ( name , true ) = = 0 ; dcnl } dcnl
i path next path = java index . get location for element ( next ) ;
i path root path string = java index . get location for element ( package fragment root ) ;
import org . eclipse . core . resources . i resource ;
import org . eclipse . core . runtime . path ;
import org . eclipse . jdt . core . i java element ;
static final int current version = nd . version ( 1 , 26 ) ; dcnl static final int max supported version = nd . version ( 1 , 26 ) ; dcnl static final int min supported version = nd . version ( 1 , 26 ) ;
/ * * dcnl * returns the absolute filesystem location of the given element or null if none dcnl * / dcnl public static i path get location for element ( i java element next ) { dcnl i resource resource = next . get resource ( ) ; dcnl dcnl if ( resource ! = null ) { dcnl return resource . get location ( ) = = null ? new path ( "" ) : resource . get location ( ) ; / / $non - nls - 1$ dcnl } dcnl dcnl return next . get path ( ) ; dcnl } dcnl
registry . register ( 0x0001 , nd annotation . type . get factory ( ) ) ;
import org . eclipse . jdt . internal . core . nd . java . type ref ;
import org . eclipse . jdt . internal . core . nd . java . type ref ;
private final type ref type ref ;
public index binary type ( type ref type ) {
return null ;
return null ;
return java names . field descriptor to binary name ( this . type ref . get field descriptor ( ) ) ;
import java . util . array list ; dcnl import java . util . list ; dcnl
private static final boolean enable self test = false ;
add method ( type , next , binary type ) ;
private void add method ( nd type type , i binary method next , i binary type binary type )
list < char [ ] > parameter field descriptors = new array list < > ( ) ; dcnl while ( !descriptor . at end ( ) ) { dcnl if ( descriptor . char at start ( ) = = ' ) ' ) { dcnl skip char ( descriptor , ' ) ' ) ; dcnl break ;
parameter field descriptors . add ( read next field descriptor ( descriptor ) ) ;
int num arguments in generic signature = count method arguments ( signature ) ; dcnl int num compiler defined parameters = math . max ( 0 , dcnl parameter field descriptors . size ( ) - num arguments in generic signature ) ; dcnl
char [ ] binary type name = binary type . get name ( ) ; dcnl while ( !signature . at end ( ) ) { dcnl if ( signature . char at start ( ) = = ' ) ' ) {
char [ ] next field descriptor = parameter field descriptors . get ( descriptor parameter idx ) ;
method . set method id ( create method id ( binary type . get name ( ) , next . get selector ( ) , next . get method descriptor ( ) ) ) ;
/ / the first bound is a class as long as it doesn't start with a double - colon dcnl parameter . set first bound is class ( wrapper . char at start ( ) ! = ' : ' ) ;
skip char ( wrapper , ' : ' ) ;
skip char ( wrapper , ' > ' ) ;
/ * * dcnl * given a generic signature which is positioned at the open brace for method arguments , this returns the number of dcnl * method arguments . the start position of the given signature is not modified . dcnl * / dcnl private int count method arguments ( signature wrapper generic signature ) { dcnl signature wrapper lookahead signature = new signature wrapper ( generic signature . signature ) ; dcnl lookahead signature . start = generic signature . start ; dcnl skip char ( lookahead signature , ' ( ' ) ; dcnl int argument count = 0 ; dcnl while ( !lookahead signature . at end ( ) & & ! ( lookahead signature . char at start ( ) = = ' ) ' ) ) { dcnl switch ( lookahead signature . char at start ( ) ) { dcnl case 't' : { dcnl / / skip the 't' prefix dcnl lookahead signature . next word ( ) ; dcnl skip char ( lookahead signature , ' ; ' ) ; dcnl argument count + + ; dcnl break ; dcnl } dcnl case ' [ ' : { dcnl / / skip the ' [ ' prefix dcnl lookahead signature . start + + ; dcnl break ; dcnl } dcnl case 'v' : dcnl case 'b' : dcnl case 'c' : dcnl case 'd' : dcnl case 'f' : dcnl case 'i' : dcnl case 'j' : dcnl case 's' : dcnl case 'z' : dcnl argument count + + ; dcnl lookahead signature . start + + ; dcnl break ; dcnl case 'l' : dcnl for ( ; ; ) { dcnl lookahead signature . next word ( ) ; dcnl lookahead signature . start = lookahead signature . skip angle contents ( lookahead signature . start ) ; dcnl char next char = lookahead signature . char at start ( ) ; dcnl if ( next char = = ' ; ' ) { dcnl break ; dcnl } dcnl if ( next char ! = ' . ' ) { dcnl throw new illegal state exception ( dcnl " unknown char in generic signature " + lookahead signature . to string ( ) ) ; / / $non - nls - 1$ dcnl } dcnl } dcnl skip char ( lookahead signature , ' ; ' ) ; dcnl argument count + + ; dcnl break ; dcnl default : dcnl throw new illegal state exception ( " generic signature starts with unknown character : " / / $non - nls - 1$ dcnl + lookahead signature . to string ( ) ) ; dcnl } dcnl } dcnl return argument count ; dcnl } dcnl
* @ param field descriptor if variable dcnl * the field descriptor to use if the type is a type variable - - or null if unknown ( the field descriptor dcnl * for java . lang . object will be used )
char first char = generic signature . char at start ( ) ;
char [ ] field descriptor = field descriptor if variable ; dcnl if ( field descriptor = = null ) { dcnl field descriptor = java lang object field descriptor ; dcnl } dcnl type signature . set raw type ( create type id from field descriptor ( field descriptor ) ) ;
skip char ( generic signature , ' ; ' ) ;
char [ ] nested field descriptor = null ; dcnl if ( field descriptor if variable ! = null & & field descriptor if variable . length > 0 dcnl & & field descriptor if variable [ 0 ] = = ' [ ' ) { dcnl nested field descriptor = char array utils . substring ( field descriptor if variable , 1 ) ; dcnl }
nested field descriptor ) ;
import org . eclipse . jdt . internal . compiler . impl . double constant ; dcnl import org . eclipse . jdt . internal . compiler . impl . float constant ;
if ( o1 instanceof double constant & & o2 instanceof double constant ) { dcnl double constant d1 = ( double constant ) o1 ; dcnl double constant d2 = ( double constant ) o2 ; dcnl dcnl if ( double . is na n ( d1 . double value ( ) ) & & double . is na n ( d2 . double value ( ) ) ) { dcnl return true ; dcnl } dcnl } dcnl dcnl if ( o1 instanceof float constant & & o2 instanceof float constant ) { dcnl float constant d1 = ( float constant ) o1 ; dcnl float constant d2 = ( float constant ) o2 ; dcnl dcnl if ( float . is na n ( d1 . float value ( ) ) & & float . is na n ( d2 . float value ( ) ) ) { dcnl return true ; dcnl } dcnl } dcnl
compare annotations ( new i binary annotation [ 0 ] , expected method . get parameter annotations ( idx , class file name ) ) ;
if ( superclass ! = null ) { dcnl superclass . get signature ( buffer ) ; dcnl }
import org . eclipse . jdt . core . dom . modifier ; dcnl import org . eclipse . jdt . internal . compiler . classfmt . class file constants ;
add method ( type , next , binary type , binary name ) ;
private void add method ( nd type type , i binary method next , i binary type binary type , char [ ] binary type name ) dcnl throws core exception {
int num compiler defined parameters = 0 ; dcnl if ( next . is constructor ( ) ) { dcnl if ( ( binary type . is local ( ) | | binary type . is member ( ) ) & & ( binary type . get modifiers ( ) & modifier . static ) = = 0 ) { dcnl num compiler defined parameters = 1 ; dcnl } dcnl if ( ( binary type . get modifiers ( ) & class file constants . acc enum ) ! = 0 ) { dcnl num compiler defined parameters = 2 ; dcnl } dcnl } dcnl dcnl boolean compiler defined parameters are included in signature = ( next . get generic signature ( ) = = null ) ; dcnl
short descriptor parameter idx = 0 ; dcnl while ( !descriptor . at end ( ) ) { dcnl if ( descriptor . char at start ( ) = = ' ) ' ) { dcnl skip char ( descriptor , ' ) ' ) ; dcnl skip char ( signature , ' ) ' ) ;
/ * * dcnl * true iff this a parameter which is part of the field descriptor but not the generic signature - - that is , dcnl * it is a compiler - defined parameter . dcnl * / dcnl boolean is compiler defined = descriptor parameter idx < num compiler defined parameters ; dcnl signature wrapper next field signature = signature ; dcnl if ( is compiler defined & & !compiler defined parameters are included in signature ) { dcnl next field signature = new signature wrapper ( next field descriptor ) ; dcnl } dcnl nd method parameter parameter = new nd method parameter ( method , dcnl create type signature ( type annotations . to method parameter ( descriptor parameter idx ) , next field signature , dcnl next field descriptor ) ) ; dcnl dcnl parameter . set compiler defined ( is compiler defined ) ;
if ( descriptor parameter idx < annotated parameters count ) { dcnl i binary annotation [ ] parameter annotations = next . get parameter annotations ( descriptor parameter idx , dcnl binary type name ) ;
if ( parameter names ! = null & & parameter names . length > descriptor parameter idx ) { dcnl parameter . set name ( parameter names [ descriptor parameter idx ] ) ;
import org . eclipse . jdt . internal . core . nd . field . field byte ;
public static final field byte flags ; dcnl dcnl private static final byte flg compiler defined = 0x01 ;
flags = type . add byte ( ) ;
import org . eclipse . jdt . internal . core . nd . i reader ; dcnl import org . eclipse . jdt . internal . core . nd . nd ; dcnl import org . eclipse . jdt . internal . core . nd . db . index exception ; dcnl import org . eclipse . jdt . internal . core . nd . java . java index ; dcnl import org . eclipse . jdt . internal . core . nd . java . nd resource file ; dcnl import org . eclipse . jdt . internal . core . nd . java . type ref ; dcnl import org . eclipse . jdt . internal . core . nd . java . model . index binary type ; dcnl import org . eclipse . jdt . internal . core . nd . util . char array utils ;
/ / if the new index is enabled , check if we have this class file cached in the index already dcnl if ( java index . is enabled ( ) ) { dcnl i path location = java index . get location for element ( pkg . get parent ( ) ) ; dcnl java index index = java index . get index ( ) ; dcnl nd nd = index . get nd ( ) ; dcnl dcnl / / we don't currently cache package - info files in the index dcnl if ( location ! = null & & !this . name . equals ( "package - info" ) ) { / / $non - nls - 1$ dcnl string location string = location . to string ( ) ; dcnl / / acquire a read lock on the index dcnl try ( i reader lock = nd . acquire read lock ( ) ) { dcnl nd resource file file = index . get resource file ( location string ) ; dcnl dcnl if ( file ! = null & & file . is done indexing ( ) ) { dcnl / / if this file is in the index and its fingerprint matches the content most recently indexed dcnl / / then read our result from the index dcnl if ( file . get fingerprint ( ) . test ( location . to file ( ) , null ) . matches ( ) ) { dcnl char [ ] field descriptor = char array utils . concat ( new char [ ] { 'l' } , dcnl util . concat with ( pkg . names , this . name , ' / ' ) . to char array ( ) , dcnl new char [ ] { ' ; ' } ) ; dcnl dcnl return new index binary type ( dcnl type ref . create ( nd , location string . to char array ( ) , field descriptor ) ) ; dcnl } dcnl } dcnl } catch ( index exception e ) { dcnl / / index corrupted . rebuild it . dcnl index . rebuild index ( ) ; dcnl } dcnl } dcnl } dcnl
setup external annotation provider ( project , external annotation path , annotation zip , reader ,
/ / private long last read access = 0 ;
/ / this . last read access = system . current time millis ( ) ;
/ / clear result cache ( ) ;
private map < reference holder , i generic type > binding map = new hash map < > ( ) ; dcnl dcnl private static class reference holder { dcnl private final reference binding key ; dcnl private int hash code ; dcnl dcnl public reference holder ( reference binding key ) { dcnl this . key = key ; dcnl this . hash code = compute hash code ( ) ; dcnl } dcnl dcnl @ override dcnl public int hash code ( ) { dcnl return this . hash code ; dcnl } dcnl dcnl private int compute hash code ( ) { dcnl if ( this . key . id = = type ids . no id ) { dcnl return system . identity hash code ( this . key ) ; dcnl } dcnl return this . key . id ; dcnl } dcnl dcnl @ override dcnl public boolean equals ( object obj ) { dcnl if ( obj instanceof reference holder ) { dcnl reference holder ref holder = ( reference holder ) obj ; dcnl dcnl return type binding . equals equals ( this . key , ref holder . key ) ; dcnl } dcnl return false ; dcnl } dcnl }
i generic type type model = this . binding map . get ( new reference holder ( super binding ) ) ; dcnl if ( type model ! = null ) { dcnl return this . builder . get handle ( type model , super binding ) ;
i generic type generic type = this . binding map . get ( new reference holder ( interface binding ) ) ; dcnl if ( generic type ! = null ) { dcnl i type handle = this . builder . get handle ( generic type , interface binding ) ; dcnl if ( handle ! = null ) { dcnl superinterfaces [ index + + ] = handle ; dcnl continue next ;
this . binding map . put ( new reference holder ( type binding ) , supplied type ) ;
this . binding map . clear ( ) ;
import org . eclipse . jdt . internal . core . nd . java . nd type ;
import java . io . io exception ; dcnl import java . util . hash map ; dcnl import java . util . map ; dcnl import java . util . zip . zip entry ; dcnl import java . util . zip . zip file ; dcnl
@ override
@ deprecated
@ deprecated
@ override
@ override
@ override
jar package fragment root root = ( jar package fragment root ) pkg . get parent ( ) ;
string entry name = util . concat with ( pkg . names , get element name ( ) , ' / ' ) ; dcnl string index path = root . get handle identifier ( ) + i dependent . jar file entry separator + entry name ; dcnl
type ref . create ( nd , location string . to char array ( ) , field descriptor ) , dcnl index path . to char array ( ) ) ;
@ override
@ override
@ override
@ override
@ override
@ override
@ override
@ deprecated
@ override
@ override
@ override
@ override
@ deprecated
import org . eclipse . jdt . internal . core . nd . java . java names ;
import org . eclipse . jdt . core . i java element ;
public static i binary type create ( i java element java element , string binary name ) { dcnl i path filesystem location = java index . get location for element ( java element ) ; dcnl
filesystem location . to string ( ) . to char array ( ) ,
private boolean simple attributes initialized ;
private char [ ] file name ; dcnl private char [ ] superclass name ; dcnl private int modifiers ; dcnl private boolean is anonymous ; dcnl private boolean is local ; dcnl private boolean is member ;
private long tag bits ; dcnl dcnl public index binary type ( type ref type , char [ ] index path ) {
this . file name = index path ;
init simple attributes ( ) ; dcnl dcnl return this . modifiers ;
return this . file name ;
init simple attributes ( ) ;
init simple attributes ( ) ;
init simple attributes ( ) ; dcnl dcnl return this . superclass name ;
init simple attributes ( ) ; dcnl dcnl return this . tag bits ;
init simple attributes ( ) ; dcnl dcnl return this . is anonymous ;
init simple attributes ( ) ; dcnl dcnl return this . is local ;
init simple attributes ( ) ; dcnl dcnl return this . is member ;
private void init simple attributes ( ) { dcnl if ( !this . simple attributes initialized ) { dcnl this . simple attributes initialized = true ;
import org . eclipse . core . filesystem . efs ; dcnl import org . eclipse . core . filesystem . i file info ; dcnl import org . eclipse . core . filesystem . i file store ; dcnl import org . eclipse . core . runtime . core exception ; dcnl import org . eclipse . core . runtime . i path ; dcnl import org . eclipse . core . runtime . i progress monitor ; dcnl import org . eclipse . core . runtime . sub monitor ; dcnl import org . eclipse . jdt . internal . core . nd . stream hasher ; dcnl
public fingerprint test result test ( i path path , i progress monitor monitor ) throws core exception {
i file store store = efs . get local file system ( ) . get store ( path ) ; dcnl i file info file info = store . fetch info ( ) ; dcnl dcnl long last modified = file info . get last modified ( ) ;
long file size = file info . get length ( ) ;
* returns true iff the given resource file is up - to - date with the filesystem . returns false dcnl * if the argument is out - of - date with the file system or null . dcnl * dcnl * @ param file the index file to look up or null
import org . eclipse . jdt . internal . core . nd . java . nd resource file ;
type ref type ref = type ref . create ( nd , descriptor . location , field descriptor ) ; dcnl nd type type = type ref . get ( ) ; dcnl dcnl if ( type = = null ) { dcnl / / if we couldn't find the type in the index , determine whether the cause is dcnl / / that the type is known not to exist or whether the resource just hasn't dcnl / / been indexed yet
nd resource file resource file = index . get resource file ( descriptor . location ) ; dcnl if ( index . is up to date ( resource file ) ) {
throw new not in index exception ( ) ; dcnl } dcnl nd resource file resource file = type . get resource file ( ) ; dcnl if ( index . is up to date ( resource file ) ) {
import org . eclipse . jdt . internal . compiler . classfmt . class with external annotations ;
import org . eclipse . jdt . internal . compiler . env . i binary type ;
import org . eclipse . jdt . internal . compiler . lookup . binary type binding . external annotation status ;
i binary type reader = class file reader . read ( this . zip file , qualified binary file name ) ;
if ( this . annotation zip file = = null ) { dcnl this . annotation zip file = class with external annotations . get annotation zip file ( annotation path , null ) ; dcnl } dcnl i binary type next reader = class with external annotations . create ( reader , annotation path , qualified class name , this . annotation zip file ) ; dcnl dcnl if ( next reader . get external annotation status ( ) = = external annotation status . type is annotated ) { dcnl reader = next reader ;
import org . eclipse . jdt . internal . compiler . classfmt . class with external annotations ;
import org . eclipse . jdt . internal . compiler . env . i binary annotation ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary element value pair ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary field ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary method ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary nested type ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary type ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary type annotation ; dcnl import org . eclipse . jdt . internal . compiler . env . i type annotation walker ;
import org . eclipse . jdt . internal . compiler . lookup . binary type binding . external annotation status ;
dcnl public void set binary type ( i binary type new type ) { dcnl this . binary type = new type ; dcnl } dcnl
import org . eclipse . jdt . internal . compiler . classfmt . class with external annotations ; dcnl import org . eclipse . jdt . internal . compiler . classfmt . external annotation provider ;
i binary type result = binary type factory . read type ( descriptor , fully initialize , null ) ;
jar package fragment root root = ( jar package fragment root ) pkg . get parent ( ) ; dcnl if ( root . get kind ( ) = = i package fragment root . k binary ) { dcnl java project java project = ( java project ) get ancestor ( i java element . java project ) ; dcnl i classpath entry entry = java project . get classpath entry for ( get path ( ) ) ; dcnl if ( entry ! = null ) { dcnl string entry name = new string ( char array utils . concat ( dcnl java names . field descriptor to binary name ( descriptor . field descriptor ) , suffix constants . suffix class ) ) ; dcnl i project project = java project . get project ( ) ; dcnl i path external annotation path = classpath entry . get external annotation path ( entry , project , false ) ; / / unresolved for use in external annotation tracker dcnl if ( external annotation path ! = null ) { dcnl result = setup external annotation provider ( project , external annotation path , null , result , dcnl entry name . substring ( 0 , entry name . length ( ) - suffix constants . suffix class . length ) ) ; dcnl } else if ( entry . get entry kind ( ) = = i classpath entry . cpe source ) { dcnl result = new class with external annotations ( result , true ) ;
return result ;
private i binary type setup external annotation provider ( i project project , final i path external annotation path , dcnl zip file annotation zip , i binary type reader , final string type name )
i binary type result = reader ;
return reader ;
if ( annotation zip = = null ) { dcnl annotation zip = class with external annotations . get annotation zip file ( resolved path , new class file reader . zip file producer ( ) { dcnl @ override public zip file produce ( ) throws io exception { dcnl try { dcnl return java model manager . get java model manager ( ) . get zip file ( external annotation path ) ; / / use ( absolute , but ) unresolved path here dcnl } catch ( core exception e ) { dcnl throw new io exception ( " failed to read annotation file for " + type name + " from " + external annotation path . to string ( ) , e ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl } dcnl } } ) ; dcnl } dcnl dcnl external annotation provider annotation provider = class with external annotations dcnl . external annotation provider ( resolved path , type name , annotation zip ) ; dcnl result = new class with external annotations ( reader , annotation provider ) ;
return result ;
import org . eclipse . core . resources . i container ; dcnl import org . eclipse . core . resources . i resource ; dcnl import org . eclipse . core . runtime . core exception ; dcnl import org . eclipse . core . runtime . i path ; dcnl import org . eclipse . core . runtime . path ;
import org . eclipse . jdt . internal . compiler . classfmt . class with external annotations ;
import org . eclipse . jdt . internal . compiler . env . i binary type ;
i binary type reader = null ;
import java . io . file ; dcnl import java . io . io exception ; dcnl import java . util . date ; dcnl import java . util . enumeration ; dcnl import java . util . zip . zip entry ; dcnl import java . util . zip . zip file ;
import org . eclipse . core . resources . i file ; dcnl import org . eclipse . core . runtime . core exception ; dcnl import org . eclipse . core . runtime . i path ;
import org . eclipse . jdt . internal . compiler . classfmt . class with external annotations ;
import org . eclipse . jdt . internal . compiler . env . i binary type ;
i binary type reader = class file reader . read ( this . zip file , qualified binary file name ) ;
* = = = = = block structure ( for free / unused blocks )
* 0 | size of block ( positive indicates an unused block ) ( 2 bytes )
* . . . | unused space dcnl * dcnl * = = = = = = block structure ( for allocated blocks ) dcnl * dcnl * offset content dcnl * dcnl * 0 | size of block ( negative indicates the block is in use ) ( 2 bytes ) dcnl * 2 | content of the struct
public static final int block header size = short size ; dcnl
dcnl / / fields that are only used by free blocks dcnl private static final int block prev offset = block header size ; dcnl private static final int block next offset = block header size + int size ; dcnl private static final int free block header size = block next offset + int size ; dcnl dcnl public static final int min block deltas = ( free block header size + block size delta - 1 ) / dcnl block size delta ; / / must be enough multiples of block size delta in order to fit the free block header
private static int divide rounding up ( int num , int den ) { dcnl return ( num + den - 1 ) / den ; dcnl } dcnl
import java . util . collections ;
import java . util . weak hash map ;
public interface listener { dcnl void consume ( change event event ) ; dcnl }
public static class change event { dcnl private final set < local path > files modified ;
public change event ( set < local path > changes ) { dcnl this . files modified = changes ;
public set < local path > get files modified ( ) { dcnl return this . files modified ;
return this . files modified . is empty ( ) ;
private final hash map < object , object > f result cache = new hash map < > ( ) ; dcnl / * * dcnl * holds the set of files which have been changed since the last index event was fired dcnl * / dcnl private set < local path > changes = new hash set < > ( ) ; dcnl private object listeners mutex = new object ( ) ; dcnl / * * dcnl * listener list . copy - on - write . synchronize on "listeners mutex" before accessing . dcnl * / dcnl private set < listener > listeners = collections . new set from map ( new weak hash map < listener , boolean > ( ) ) ;
/ * * dcnl * should be called by the indexer to indicate a source file that has been dcnl * fully indexed . dcnl * / dcnl public final void mark path as modified ( local path path ) { dcnl this . db . assert locked ( ) ; dcnl this . changes . add ( path ) ; dcnl } dcnl dcnl public final void release write lock ( ) {
final change event event ; dcnl if ( this . changes . is empty ( ) ) { dcnl event = null ; dcnl } else { dcnl event = new change event ( this . changes ) ;
this . changes = new hash set < > ( ) ; dcnl }
assert locked ( ) ;
import org . eclipse . jdt . internal . core . nd . local path ;
import org . eclipse . jdt . internal . core . search . unindexed search scope ;
sub monitor sub monitor = sub monitor . convert ( progress monitor , 2 ) ;
sub monitor . split ( 1 ) ) ; dcnl legacy search all possible sub types ( type , unindexed search scope . filter entries covered by the new index ( scope ) , dcnl binaries from index matches , path requestor , waiting policy , sub monitor . split ( 1 ) ) ;
short target type id = nd node . node type . get ( nd , old target address ) ;
i type factory < t > type factory = nd . get type factory ( target type id ) ;
package org . eclipse . jdt . core . tests . nd ;
package org . eclipse . jdt . core . tests . nd ;
package org . eclipse . jdt . core . tests . nd ;
package org . eclipse . jdt . core . tests . nd ;
package org . eclipse . jdt . core . tests . nd ;
* int size * ( m + 1 ) | pointer to head of linked list of blocks of size ( m + min block deltas ) * block size delta
* data area | the database singletons are stored here and use the remainder of chunk 0
private static final int malloc table offset = version offset + int size ; dcnl public static final int write number offset = malloc table offset dcnl + ( chunk size / block size delta - min block deltas + 1 ) * int size ; dcnl public static final int data area offset = write number offset + long size ;
/ * * dcnl * @ param blocksize ( must be a multiple of block size delta ) dcnl * /
return this . f header chunk . get free rec ptr ( malloc table offset + ( blocksize / block size delta - min block deltas ) * int size ) ;
b tree btree = this . search index . get ( pdom , database . data area offset ) ;
import org . eclipse . jdt . internal . core . nd . i reader ;
try ( i reader reader = nd . acquire read lock ( ) ) {
import org . eclipse . jdt . core . i field ; dcnl import org . eclipse . jdt . core . i method ; dcnl import org . eclipse . jdt . core . signature ;
import org . eclipse . jdt . core . search . search match ; dcnl import org . eclipse . jdt . core . search . search pattern ; dcnl import org . eclipse . jdt . core . search . type reference match ;
import org . eclipse . jdt . internal . compiler . env . i binary annotation ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary element value pair ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary field ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary method ; dcnl import org . eclipse . jdt . internal . compiler . env . i binary type ; dcnl import org . eclipse . jdt . internal . compiler . lookup . binary type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . field binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . tag bits ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type constants ; dcnl import org . eclipse . jdt . internal . core . binary type ; dcnl import org . eclipse . jdt . internal . core . class file ; dcnl import org . eclipse . jdt . internal . core . java element ; dcnl import org . eclipse . jdt . internal . core . resolved binary field ; dcnl import org . eclipse . jdt . internal . core . resolved binary method ; dcnl import org . eclipse . jdt . internal . core . resolved binary type ;
i binary method [ ] methods = binary type . get methods ( ) ;
i binary method method = methods [ i ] ;
i binary field [ ] fields = binary type . get fields ( ) ;
long start time = system . nano time ( ) ; dcnl try { dcnl if ( java index . is enabled ( ) ) { dcnl return new index based java search environment ( java projects , copies ) ; dcnl } else { dcnl iterator < i java project > next = java projects . iterator ( ) ; dcnl java search name environment result = new java search name environment ( next . next ( ) , copies ) ; dcnl dcnl while ( next . has next ( ) ) { dcnl result . add project class path ( ( java project ) next . next ( ) ) ; dcnl } dcnl return result ;
public static i binary type class file reader ( i type type ) {
return ( i binary type ) manager . get info ( type ) ;
i binary type reader = class file reader ( type ) ;
import org . eclipse . jdt . core . i package fragment ; dcnl import org . eclipse . jdt . core . i type ;
import org . eclipse . jdt . internal . compiler . env . i binary type ;
import org . eclipse . jdt . internal . core . binary type ; dcnl import org . eclipse . jdt . internal . core . class file ; dcnl import org . eclipse . jdt . internal . core . compilation unit ; dcnl import org . eclipse . jdt . internal . core . openable ; dcnl import org . eclipse . jdt . internal . core . package fragment ; dcnl import org . eclipse . jdt . internal . core . source mapper ;
import java . util . collections ;
import org . eclipse . jdt . internal . codeassist . complete . completion node detector ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion node found ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on annotation of type ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on argument name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on branch statement label ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on class literal access ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on explicit constructor call ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on field name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on field type ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on import reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc allocation expression ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc field reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc message send ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc param name reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc qualified type reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc single type reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc tag ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on javadoc type param reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on keyword ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on keyword3 ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on local name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on marker annotation name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on member access ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on member value name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on message send ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on message send name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on method name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on method return type ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on package reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on parameterized qualified type reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on qualified allocation expression ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on qualified name reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on qualified type reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on reference expression name ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on single name reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on single type reference ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion on string literal ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion parser ; dcnl import org . eclipse . jdt . internal . codeassist . complete . completion scanner ; dcnl import org . eclipse . jdt . internal . codeassist . complete . invalid cursor location ;
import org . eclipse . jdt . internal . compiler . ast . ast node ; dcnl import org . eclipse . jdt . internal . compiler . ast . abstract method declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . abstract variable declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . allocation expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . annotation ; dcnl import org . eclipse . jdt . internal . compiler . ast . argument ; dcnl import org . eclipse . jdt . internal . compiler . ast . array initializer ; dcnl import org . eclipse . jdt . internal . compiler . ast . array reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . assert statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . assignment ; dcnl import org . eclipse . jdt . internal . compiler . ast . binary expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . case statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . cast expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . compilation unit declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . conditional expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . constructor declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . expression context ; dcnl import org . eclipse . jdt . internal . compiler . ast . field declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . field reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . for statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . if statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . import reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . initializer ; dcnl import org . eclipse . jdt . internal . compiler . ast . instance of expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . javadoc ; dcnl import org . eclipse . jdt . internal . compiler . ast . javadoc implicit type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . javadoc qualified type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . javadoc single type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . lambda expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . local declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . member value pair ; dcnl import org . eclipse . jdt . internal . compiler . ast . message send ; dcnl import org . eclipse . jdt . internal . compiler . ast . method declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . name reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . normal annotation ; dcnl import org . eclipse . jdt . internal . compiler . ast . operator expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . operator ids ; dcnl import org . eclipse . jdt . internal . compiler . ast . parameterized qualified type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . parameterized single type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . qualified name reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . qualified type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . reference expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . return statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . single name reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . single type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . super reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . switch statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . this reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . try statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . type declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . type parameter ; dcnl import org . eclipse . jdt . internal . compiler . ast . type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . unary expression ; dcnl import org . eclipse . jdt . internal . compiler . ast . union type reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . while statement ; dcnl import org . eclipse . jdt . internal . compiler . ast . wildcard ;
import org . eclipse . jdt . internal . compiler . env . access restriction ; dcnl import org . eclipse . jdt . internal . compiler . env . i compilation unit ; dcnl import org . eclipse . jdt . internal . compiler . env . i name environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i source type ; dcnl import org . eclipse . jdt . internal . compiler . env . name environment answer ;
import org . eclipse . jdt . internal . compiler . lookup . array binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . base type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . block scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . class scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . compilation unit scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . extra compiler modifiers ; dcnl import org . eclipse . jdt . internal . compiler . lookup . field binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . import binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . inference context18 ; dcnl import org . eclipse . jdt . internal . compiler . lookup . invocation site ; dcnl import org . eclipse . jdt . internal . compiler . lookup . local variable binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . lookup environment ; dcnl import org . eclipse . jdt . internal . compiler . lookup . method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . method scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . package binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . parameterized method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . parameterized type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reasons ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . source type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . tag bits ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type constants ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type ids ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type variable binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . variable binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . wildcard binding ; dcnl import org . eclipse . jdt . internal . compiler . parser . javadoc tag constants ;
import org . eclipse . jdt . internal . compiler . util . simple set of char array ; dcnl import org . eclipse . jdt . internal . compiler . util . suffix constants ;
import org . eclipse . jdt . internal . core . binary type converter ;
import org . eclipse . jdt . internal . core . searchable environment ;
import org . eclipse . jdt . internal . core . search . matching . index based java search environment ;
private i name environment no cache name environment ;
return accept result ( address ) ;
protected abstract boolean accept result ( long address ) ;
protected boolean accept result ( long result address ) {
return true ;
public interface visitor < t > { dcnl boolean visit ( t to visit ) ; dcnl } dcnl dcnl public boolean visit all ( final nd nd , long address , final search criteria search criteria , final visitor < t > visitor ) { dcnl return get ( nd , address ) . accept ( new search criteria to btree visitor adapter ( search criteria , nd ) { dcnl @ suppress warnings ( "unchecked" ) dcnl @ override dcnl protected boolean accept result ( long result address ) { dcnl return visitor . visit ( ( t ) nd node . load ( nd , result address ) ) ; dcnl } dcnl } ) ; dcnl } dcnl
protected boolean accept result ( long result address ) {
import java . io . file ; dcnl import java . util . list ; dcnl
import java . util . collections ; dcnl
import org . eclipse . jdt . core . i java project ;
import org . eclipse . jdt . internal . core . search . matching . index based java search environment ;
import java . util . map ;
import org . eclipse . jdt . core . i java project ; dcnl import org . eclipse . jdt . core . i package declaration ; dcnl import org . eclipse . jdt . core . i package fragment root ; dcnl import org . eclipse . jdt . core . java model exception ;
map < string , org . eclipse . jdt . core . i compilation unit > working copies ;
this . working copies = get working copy map ( copies ) ; dcnl } dcnl dcnl public static map < string , org . eclipse . jdt . core . i compilation unit > get working copy map ( dcnl org . eclipse . jdt . core . i compilation unit [ ] copies ) { dcnl int length = copies = = null ? 0 : copies . length ; dcnl hash map < string , org . eclipse . jdt . core . i compilation unit > result = new hash map < > ( length ) ;
result . put ( qualified main type name , working copy ) ;
import org . eclipse . jdt . internal . core . nd . java . java index ;
import org . eclipse . jdt . internal . core . nd . indexer . indexer ; dcnl import org . eclipse . jdt . internal . core . nd . indexer . indexer event ;
public class delta processing state implements i resource change listener , indexer . listener {
import org . eclipse . jdt . internal . core . nd . java . java index ;
if ( java index . is enabled ( ) ) { dcnl / / deltas for changes in external jars are fired after indexing , to reduce the chance of listeners trying to dcnl / / read the new state of the . jar before it can be cached in the index . dcnl close ( root ) ; dcnl this . project caches to reset . add ( java project ) ; dcnl } else { dcnl content changed ( root ) ; dcnl delta contains modified jar = true ; dcnl has delta = true ; dcnl }
notify and fire ( null ) ;
import org . eclipse . jdt . internal . core . nd . indexer . indexer ;
import java . util . collections ;
import java . util . weak hash map ;
import org . eclipse . jdt . core . i java element delta ;
import org . eclipse . jdt . internal . core . java element delta ; dcnl import org . eclipse . jdt . internal . core . java model ; dcnl import org . eclipse . jdt . internal . core . java model manager ;
private object listeners mutex = new object ( ) ; dcnl / * * dcnl * listener list . copy - on - write . synchronize on "listeners mutex" before accessing . dcnl * / dcnl private set < listener > listeners = collections . new set from map ( new weak hash map < listener , boolean > ( ) ) ; dcnl
public static interface listener { dcnl void consume ( indexer event event ) ; dcnl } dcnl
this . nd . acquire write lock ( sub monitor . split ( 4 ) ) ;
fire delta ( roots with changes , sub monitor . split ( 1 ) ) ; dcnl
private void fire delta ( set < i path > roots with changes , i progress monitor monitor ) { dcnl sub monitor sub monitor = sub monitor . convert ( monitor , 1 ) ; dcnl i project [ ] projects = this . root . get projects ( ) ; dcnl dcnl list < i project > projects to scan = new array list < > ( ) ; dcnl dcnl for ( i project next : projects ) { dcnl if ( next . is open ( ) ) { dcnl projects to scan . add ( next ) ; dcnl } dcnl } dcnl java model model = java model manager . get java model manager ( ) . get java model ( ) ; dcnl java element delta delta = new java element delta ( model ) ; dcnl sub monitor project loop monitor = sub monitor . split ( 1 ) . set work remaining ( projects to scan . size ( ) ) ; dcnl for ( i project project : projects to scan ) { dcnl project loop monitor . split ( 1 ) ; dcnl try { dcnl if ( project . is open ( ) & & project . is nature enabled ( java core . nature id ) ) { dcnl i java project java project = java core . create ( project ) ; dcnl dcnl i package fragment root [ ] roots = java project . get all package fragment roots ( ) ; dcnl dcnl for ( i package fragment root next : roots ) { dcnl if ( next . is archive ( ) ) { dcnl i path location = java index . get location for element ( next ) ; dcnl dcnl if ( roots with changes . contains ( location ) ) { dcnl delta . changed ( next , dcnl i java element delta . f content | i java element delta . f archive content changed ) ; dcnl } dcnl } dcnl } dcnl } dcnl } catch ( core exception e ) { dcnl package . log ( e ) ; dcnl } dcnl } dcnl dcnl fire change ( indexer event . create change ( delta ) ) ; dcnl } dcnl
result . put ( next , test for changes ( next , sub monitor . split ( 1 ) ) ) ;
this . nd . acquire write lock ( sub monitor . split ( 5 ) ) ;
int result = add element ( resource file , element , sub monitor . split ( 90 ) ) ;
this . nd . acquire write lock ( sub monitor . split ( 5 ) ) ;
list < i java element > bindable elements = get bindable elements ( element , sub monitor . split ( 10 ) ) ;
import java . io . io exception ; dcnl import java . util . zip . zip entry ; dcnl import java . util . zip . zip file ; dcnl
i java element root = pkg . get parent ( ) ;
string file name = new string ( binary name ) + " . class" ; / / $non - nls - 1$ dcnl i binary type binary type = new index binary type ( type ref , file name . to char array ( ) ) ;
field descriptor prefix = char array utils . concat ( java names . field descriptor prefix , package name , dcnl new char [ ] { ' / ' } ) ;
new char [ ] { ' / ' } , package name , new char [ ] { ' / ' } ) ;
/ / string fd = type id . get field descriptor ( ) . get string ( ) ;
if ( java index . is enabled ( ) ) { dcnl return new index based java search environment ( java projects , copies ) ; dcnl } else { dcnl iterator < i java project > next = java projects . iterator ( ) ; dcnl java search name environment result = new java search name environment ( next . next ( ) , copies ) ; dcnl dcnl while ( next . has next ( ) ) { dcnl result . add project class path ( ( java project ) next . next ( ) ) ;
import org . eclipse . core . runtime . i path ; dcnl import org . eclipse . core . runtime . path ; dcnl
import java . util . hash set ;
import java . util . map . entry ; dcnl import java . util . set ;
node < t > get child ( string next segment ) {
dcnl public void add all keys ( set < i path > result , i path parent ) { dcnl if ( this . exists ) { dcnl result . add ( parent ) ; dcnl } dcnl dcnl for ( entry < string , node < t > > next : this . children . entry set ( ) ) { dcnl string key = next . get key ( ) ; dcnl i path next path = build child path ( parent , key ) ; dcnl next . get value ( ) . add all keys ( result , next path ) ; dcnl } dcnl } dcnl dcnl i path build child path ( i path parent , string key ) { dcnl i path next path = parent . append ( key ) ; dcnl return next path ; dcnl } dcnl dcnl public void to string ( string builder builder , i path parent path ) { dcnl if ( this . exists ) { dcnl builder . append ( " [ " ) ; dcnl builder . append ( parent path ) ; dcnl builder . append ( " ] = " ) ; dcnl builder . append ( this . value ) ; dcnl builder . append ( " \ n" ) ; dcnl } dcnl if ( this . children ! = null ) { dcnl for ( entry < string , node < t > > next : this . children . entry set ( ) ) { dcnl string key = next . get key ( ) ; dcnl i path next path = build child path ( parent path , key ) ; dcnl next . get value ( ) . to string ( builder , next path ) ; dcnl } dcnl } dcnl }
dcnl node < t > get child ( string next segment ) { dcnl if ( next segment = = null ) { dcnl return this . no device ; dcnl } dcnl return super . get child ( next segment ) ; dcnl } dcnl dcnl @ override dcnl i path build child path ( i path parent , string key ) { dcnl i path next path = path . empty . append ( parent ) ; dcnl next path . set device ( key ) ; dcnl return next path ; dcnl } dcnl dcnl @ override dcnl public void to string ( string builder builder , i path parent path ) { dcnl this . no device . to string ( builder , parent path ) ; dcnl super . to string ( builder , parent path ) ; dcnl }
import org . eclipse . core . resources . i container ;
import org . eclipse . jdt . internal . compiler . env . access rule set ;
import org . eclipse . jdt . internal . core . java model ;
import org . eclipse . jdt . internal . core . package fragment root ; dcnl import org . eclipse . jdt . internal . core . builder . classpath location ;
import java . util . array list ; dcnl import java . util . iterator ; dcnl import java . util . list ; dcnl import java . util . map ; dcnl
private list < classpath location > unindexed entries = new array list < > ( ) ;
int idx = 0 ;
i path path = next root . get path ( ) ; dcnl if ( !next root . is archive ( ) ) { dcnl object target = java model . get target ( path , true ) ; dcnl if ( target ! = null ) { dcnl classpath location cp ; dcnl if ( next root . get kind ( ) = = i package fragment root . k source ) { dcnl package fragment root root = ( package fragment root ) next root ; dcnl cp = new classpath source directory ( ( i container ) target , root . full exclusion pattern chars ( ) , root . full inclusion pattern chars ( ) ) ; dcnl this . unindexed entries . add ( cp ) ; dcnl / / } else { dcnl / / classpath entry raw classpath entry = ( classpath entry ) next root . get raw classpath entry ( ) ; dcnl / / cp = classpath location . for binary folder ( ( i container ) target , false , raw classpath entry . get access rule set ( ) , dcnl / / classpath entry . get external annotation path ( raw classpath entry , ( ( i java project ) next root . get parent ( ) ) . get project ( ) , true ) ) ; dcnl } dcnl } dcnl } dcnl dcnl idx + + ;
name environment answer result = find class in unindexed locations ( new string ( binary name ) , compound type name [ compound type name . length - 1 ] ) ; dcnl if ( result ! = null ) {
access rule set rule set = classpath entry . get access rule set ( ) ; dcnl access restriction access restriction = rule set = = null ? null : rule set . get violated restriction ( binary name ) ;
/ * * dcnl * search unindexed locations on the classpath for the given class dcnl * / dcnl private name environment answer find class in unindexed locations ( string qualified type name , char [ ] type name ) { dcnl string dcnl binary file name = null , q binary file name = null , dcnl source file name = null , q source file name = null , dcnl q package name = null ; dcnl name environment answer suggested answer = null ; dcnl iterator < classpath location > iter = this . unindexed entries . iterator ( ) ; dcnl while ( iter . has next ( ) ) { dcnl classpath location location = iter . next ( ) ; dcnl name environment answer answer ; dcnl if ( location instanceof classpath source directory ) { dcnl if ( source file name = = null ) { dcnl q source file name = qualified type name ; / / doesn't include the file extension dcnl source file name = q source file name ; dcnl q package name = "" ; / / $non - nls - 1$ dcnl if ( qualified type name . length ( ) > type name . length ) { dcnl int type name start = q source file name . length ( ) - type name . length ; dcnl q package name = q source file name . substring ( 0 , type name start - 1 ) ; dcnl source file name = q source file name . substring ( type name start ) ; dcnl } dcnl } dcnl org . eclipse . jdt . internal . compiler . env . i compilation unit working copy = ( org . eclipse . jdt . internal . compiler . env . i compilation unit ) this . working copies . get ( qualified type name ) ; dcnl if ( working copy ! = null ) { dcnl answer = new name environment answer ( working copy , null / * no access restriction * / ) ; dcnl } else { dcnl answer = location . find class ( dcnl source file name , / / doesn't include the file extension dcnl q package name , dcnl q source file name ) ; / / doesn't include the file extension dcnl } dcnl } else { dcnl if ( binary file name = = null ) { dcnl q binary file name = qualified type name + suffix string class ; dcnl binary file name = q binary file name ; dcnl q package name = "" ; / / $non - nls - 1$ dcnl if ( qualified type name . length ( ) > type name . length ) { dcnl int type name start = q binary file name . length ( ) - type name . length - 6 ; / / size of " . class" dcnl q package name = q binary file name . substring ( 0 , type name start - 1 ) ; dcnl binary file name = q binary file name . substring ( type name start ) ; dcnl } dcnl } dcnl answer = dcnl location . find class ( dcnl binary file name , dcnl q package name , dcnl q binary file name ) ; dcnl } dcnl if ( answer ! = null ) { dcnl if ( !answer . ignore if better ( ) ) { dcnl if ( answer . is better ( suggested answer ) ) dcnl return answer ; dcnl } else if ( answer . is better ( suggested answer ) ) dcnl / / remember suggestion and keep looking dcnl suggested answer = answer ; dcnl } dcnl } dcnl if ( suggested answer ! = null ) dcnl / / no better answer was found dcnl return suggested answer ; dcnl return null ; dcnl } dcnl
final char [ ] field descriptor prefix ; dcnl dcnl if ( parent package name = = null | | parent package name . length = = 0 ) { dcnl field descriptor prefix = char array utils . concat ( java names . field descriptor prefix , binary package name ) ; dcnl } else { dcnl field descriptor prefix = char array utils . concat ( java names . field descriptor prefix , binary package name , dcnl new char [ ] { ' / ' } , package name ) ; dcnl } dcnl dcnl string prefix = new string ( field descriptor prefix ) ;
/ / if this is an exact match for the field descriptor prefix we're looking for then dcnl / / this class can't be part of the package we're searching for ( and , most likely , the dcnl / / "package" we're searching for is actually a class name - not a package ) . dcnl if ( type id . get field descriptor ( ) . length ( ) < = field descriptor prefix . length + 1 ) { dcnl return true ; dcnl }
if ( next . is member ( ) | | next . is local ( ) | | next . is anonymous ( ) ) { dcnl continue ; dcnl }
/ / terminate the search - - we've found a class belonging to the package dcnl / / we're searching for .
private static class tracing environment implements i name environment { dcnl private i name environment to wrap ; dcnl private string id ; dcnl / * * dcnl * @ param to wrap dcnl * / dcnl public tracing environment ( i name environment to wrap ) { dcnl super ( ) ; dcnl this . to wrap = to wrap ; dcnl id = "" + system . current time millis ( ) ; dcnl } dcnl dcnl string to printable ( char [ ] to print ) { dcnl return new string ( to print ) ; dcnl } dcnl dcnl string to printable ( char [ ] [ ] compound ) { dcnl return to printable ( char operation . concat with ( compound , ' / ' ) ) ; / / $non - nls - 1$ dcnl } dcnl dcnl @ override dcnl public name environment answer find type ( char [ ] [ ] compound type name ) { dcnl name environment answer result = this . to wrap . find type ( compound type name ) ; dcnl dcnl system . out . println ( "i name environment . find type ( " + to printable ( compound type name ) + " ) = " + result ) ; dcnl dcnl return result ; dcnl } dcnl dcnl @ override dcnl public name environment answer find type ( char [ ] type name , char [ ] [ ] package name ) { dcnl name environment answer result = this . to wrap . find type ( type name , package name ) ; dcnl dcnl system . out . println ( "i name environment . find type ( " + to printable ( type name ) + " , " + to printable ( package name ) dcnl + " ) = " + result ) ; dcnl dcnl return result ; dcnl } dcnl dcnl @ override dcnl public boolean is package ( char [ ] [ ] parent package name , char [ ] package name ) { dcnl boolean result = this . to wrap . is package ( parent package name , package name ) ; dcnl dcnl system . out . println ( "i name environment . is package ( " + to printable ( parent package name ) + " , " dcnl + to printable ( package name ) + " ) = " + result ) ; dcnl dcnl return result ; dcnl } dcnl dcnl @ override dcnl public void cleanup ( ) { dcnl system . out . println ( "i name environment . cleanup ( ) " ) ; dcnl } dcnl } dcnl
return new tracing environment ( new index based java search environment ( java projects , copies ) ) ;
private static final boolean enabled ; dcnl
dcnl enabled = ! system . get property ( "jdt . newindex" ) . equals ( "0" ) ; / / $non - nls - 1$ / / $non - nls - 2$
static final int max supported version = nd . version ( 1 , 30 ) ; dcnl static final int min supported version = nd . version ( 1 , 30 ) ;
public static final field long time last used ;
time last used = type . add long ( ) ;
int total indexables = unfiltered indexables . size ( ) ;
set < i path > indexables with changes = new hash set < > ( get indexables that have changed ( all indexables . key set ( ) , fingerprints ) ) ;
sub monitor loop monitor = sub monitor . split ( 80 ) . set work remaining ( indexables with changes . size ( ) ) ; dcnl for ( i path next : indexables with changes ) {
if ( !indexables with changes . contains ( next ) ) {
fire delta ( indexables with changes , sub monitor . split ( 1 ) ) ;
long locate indexables time ms = ( start garbage collection ns - start time ns ) / ms to ns ;
+ " located " + total indexables + " indexables in " + locate indexables time ms + "ms \ n" / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$
private void fire delta ( set < i path > indexables with changes , i progress monitor monitor ) {
if ( indexables with changes . contains ( location ) ) {
private map < i path , list < i java element > > remove duplicate paths ( list < i java element > all indexables ) {
for ( i java element next : all indexables ) {
private map < i path , fingerprint test result > test fingerprints ( collection < i path > all indexables ,
sub monitor sub monitor = sub monitor . convert ( monitor , all indexables . size ( ) ) ;
for ( i path next : all indexables ) {
list < i java element > all indexables = new array list < > ( ) ;
all indexables . add ( next root ) ;
collect all class files ( all indexables , next root ) ;
collect all class files ( all indexables , next root ) ;
collect all class files ( all indexables , resources to scan , sub monitor . split ( 1 ) ) ; dcnl return all indexables ;
private list < i path > get indexables that have changed ( collection < i path > indexables ,
list < i path > indexables with changes = new array list < > ( ) ; dcnl for ( i path next : indexables ) {
indexables with changes . add ( next ) ;
list < i java element > unfiltered indexables = get all indexable objects in workspace ( sub monitor . split ( 3 ) ) ;
int total roots = unfiltered indexables . size ( ) ; dcnl / / remove all duplicate indexables ( jars which are referenced by more than one project ) dcnl map < i path , list < i java element > > all indexables = remove duplicate paths ( unfiltered indexables ) ;
int gc files = clean garbage ( current time ms , all indexables . key set ( ) , sub monitor . split ( 4 ) ) ;
map < i path , fingerprint test result > fingerprints = test fingerprints ( all indexables . key set ( ) , sub monitor . split ( 7 ) ) ; dcnl set < i path > roots with changes = new hash set < > ( get roots that have changed ( all indexables . key set ( ) , fingerprints ) ) ;
classes indexed + = rescan archive ( current time ms , next , all indexables . get ( next ) , fingerprints . get ( next ) . get new fingerprint ( ) ,
for ( i path next : all indexables . key set ( ) ) {
paths to update . put ( next , all indexables . get ( next ) ) ;
double average fingerprint time ms = all indexables . size ( ) = = 0 ? 0 : ( double ) fingerprint time ms / ( double ) all indexables . size ( ) ;
+ " tested " + all indexables . size ( ) + " fingerprints in " + fingerprint time ms + "ms , average time = " + average fingerprint time ms + "ms \ n" / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ / / $non - nls - 4$
/ * * dcnl * clean up unneeded files here , but only do so if it's been a long time since the file was last referenced . being dcnl * too eager about removing old files means that operations which temporarily cause a file to become unreferenced dcnl * will run really slowly . also eagerly clean up any partially - indexed files we discover during the scan . that is , dcnl * if we discover a file with a timestamp of 0 , it indicates that the indexer or all of eclipse crashed midway dcnl * through indexing the file . such garbage should be cleaned up as soon as possible , since it will never be useful . dcnl * dcnl * @ param current time millis timestamp of the time at which the indexing operation started dcnl * @ param all indexables list of all referenced java roots dcnl * @ param monitor progress monitor dcnl * @ return the number of indexables in the index , prior to garbage collection dcnl * / dcnl private int clean garbage ( long current time millis , collection < i path > all indexables , i progress monitor monitor ) {
/ * * dcnl * amount of time ( milliseconds ) before we update the "used" timestamp on a file in the index . we don't update dcnl * the timestamps every update since doing so would be unnecessarily inefficient . . . but if any of the timestamps dcnl * is older than this update period , we refresh it . dcnl * / dcnl private static final long usage timestamp update period = garbage cleanup timeout / 4 ; dcnl
dcnl list < nd resource file > garbage = new array list < > ( ) ; dcnl list < nd resource file > needs update = new array list < > ( ) ; dcnl dcnl / / build up the list of nd resource files that either need to be garbage collected or dcnl / / have their read timestamps updated . dcnl try ( i reader reader = this . nd . acquire read lock ( ) ) {
long time last used = next . get time last used ( ) ; dcnl long time since last used = current time millis - time last used ; dcnl
if ( time since last used > usage timestamp update period ) { dcnl needs update . add ( next ) ; dcnl }
}
/ * * dcnl * amount of time ( milliseconds ) unreferenced files are allowed to sit in the index before they are discarded . dcnl * making this too short will cause some operations ( classpath modifications , closing / reopening projects , etc . ) dcnl * to become more expensive . making this too long will waste space in the database . dcnl * / dcnl private static final long garbage cleanup timeout = 1000 * 60 * 60 * 24 ; dcnl
long current time ms = system . current time millis ( ) ;
int gc files = clean garbage ( current time ms , all roots . key set ( ) , sub monitor . split ( 4 ) ) ;
classes indexed + = rescan archive ( current time ms , next , all roots . get ( next ) , fingerprints . get ( next ) . get new fingerprint ( ) ,
long garbage collection ms = ( start fingerprint test ns - start garbage collection ns ) / ms to ns ;
double average gc time ms = gc files = = 0 ? 0 : ( double ) garbage collection ms / ( double ) gc files ;
+ " collected garbage from " + gc files + " files in " + garbage collection ms + "ms , average time = " + average gc time ms + "ms \ n" / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ / / $non - nls - 4$
private int clean garbage ( long current time millis , collection < i path > all root locations , i progress monitor monitor ) {
dcnl java index index = java index . get index ( this . nd ) ; dcnl dcnl int result = 0 ; dcnl hash set < i path > paths = new hash set < > ( ) ; dcnl paths . add all ( all root locations ) ; dcnl sub monitor sub monitor = sub monitor . convert ( monitor , 3 ) ; dcnl this . nd . acquire write lock ( sub monitor . split ( 1 ) ) ; dcnl try { dcnl list < nd resource file > resource files = index . get all resource files ( ) ; dcnl list < nd resource file > garbage = new array list < > ( ) ; dcnl dcnl result = resource files . size ( ) ; dcnl sub monitor test monitor = sub monitor . split ( 1 ) . set work remaining ( resource files . size ( ) ) ; dcnl for ( nd resource file next : resource files ) { dcnl test monitor . split ( 1 ) ; dcnl if ( !next . is done indexing ( ) ) { dcnl garbage . add ( next ) ; dcnl } else { dcnl i path next path = new path ( next . get location ( ) . to string ( ) ) ; dcnl if ( paths . contains ( next path ) ) { dcnl next . set time last used ( current time millis ) ; dcnl } else { dcnl long time last used = next . get time last used ( ) ; dcnl dcnl long time since last used = current time millis - time last used ; dcnl if ( time since last used > garbage cleanup timeout ) { dcnl garbage . add ( next ) ; dcnl } dcnl } dcnl } dcnl } dcnl dcnl sub monitor delete monitor = sub monitor . split ( 1 ) . set work remaining ( garbage . size ( ) ) ; dcnl for ( nd resource file next : garbage ) { dcnl delete monitor . split ( 1 ) ; dcnl next . delete ( ) ; dcnl } dcnl } finally { dcnl this . nd . release write lock ( ) ; dcnl } dcnl dcnl return result ;
private int rescan archive ( long current time millis , i path the path , list < i java element > elements mapping onto location ,
resource file . set time last used ( current time millis ) ;
static final int current version = nd . version ( 1 , 32 ) ; dcnl static final int max supported version = nd . version ( 1 , 32 ) ; dcnl static final int min supported version = nd . version ( 1 , 32 ) ;
public list < nd resource file > find resources with path ( string the path ) {
public static final field long time last used ;
time last used = type . add long ( ) ;
import java . util . array list ;
static final int current version = nd . version ( 1 , 31 ) ; dcnl static final int max supported version = nd . version ( 1 , 31 ) ; dcnl static final int min supported version = nd . version ( 1 , 31 ) ;
static final int max supported version = nd . version ( 1 , 29 ) ; dcnl static final int min supported version = nd . version ( 1 , 29 ) ;
private static final boolean enabled ; dcnl
dcnl enabled = ! system . get property ( "jdt . newindex" ) . equals ( "0" ) ; / / $non - nls - 1$ / / $non - nls - 2$
if ( this . children = = null ) { dcnl this . children = new hash map < > ( ) ; dcnl }
if ( this . children = = null ) { dcnl return null ; dcnl }
sub monitor sub monitor = sub monitor . convert ( monitor , 2 ) ;
public long get database size ( ) { dcnl return this . f chunks used * chunk size ; dcnl } dcnl
system . out . println ( " allocated size : " + get database size ( ) + " bytes" ) ; / / $non - nls - 1$
reader = class with external annotations . create ( reader , annotation path , qualified class name , this . annotation zip file ) ;
/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * dcnl * copyright ( c ) 2016 google , inc . and others . dcnl * all rights reserved . this program and the accompanying materials dcnl * are made available under the terms of the eclipse public license v1 . 0 dcnl * which accompanies this distribution , and is available at dcnl * http : / / www . eclipse . org / legal / epl - v10 . html dcnl * dcnl * contributors : dcnl * stefan xenos < sxenos @ gmail . com > ( google ) - initial api and implementation dcnl * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /
import java . io . file not found exception ;
/ * * dcnl * a decorator for { @ link i binary type } that allows external annotations to be attached . this can be used to change the dcnl * result of { @ link #enrich with external annotations for } or { @ link #get external annotation status } . dcnl * /
/ * * auxiliary interface for { @ link #get annotation zip file ( string , zip file producer ) } . * / dcnl public interface zip file producer { zip file produce ( ) throws io exception ; } dcnl
*
*
try { dcnl return new external annotation provider ( new file input stream ( file path ) , qualified binary type name ) ; dcnl } catch ( file not found exception e ) { dcnl / / expected , no need to report an error here dcnl return null ; dcnl }
* possibly wrap the provided binary type in a class with external annotations to which a fresh provider for external dcnl * annotations is associated . this provider is constructed using the given base path , which is either a directory dcnl * holding . eea text files , or a zip file of entries of the same format . if no such provider could be constructed , dcnl * then the original binary type is returned unchanged .
* @ param to decorate dcnl * the binary type to wrap , if needed
* an existing zip file for the same base path , or null . dcnl * @ return either a fresh class with external annotations or the original binary type unchanged .
* base path is a directory < em > is < / em > expected , and simply handled by not setting up an external dcnl * annotation provider . if base path is neither a directory nor a zip file , this is unexpected , resulting dcnl * in an exception .
public static i binary type create ( i binary type to decorate , string base path ,
import java . io . io exception ; dcnl import java . util . hash map ; dcnl import java . util . map ; dcnl import java . util . zip . zip entry ; dcnl import java . util . zip . zip file ; dcnl
public static boolean debug duplicate deletions = false ;
private hash map < long , object > pending deletions = new hash map < > ( ) ;
if ( this . pending deletions . contains key ( address of node to delete ) ) { dcnl log double deletion ( address of node to delete ) ; dcnl return ; dcnl } dcnl dcnl object data = boolean . true ; dcnl if ( debug duplicate deletions ) { dcnl data = new runtime exception ( ) ; dcnl } dcnl this . pending deletions . put ( address of node to delete , data ) ; dcnl } dcnl dcnl protected void log double deletion ( long address of node to delete ) {
/ / if you're debugging issues related to duplicate deletions , set debug duplicate deletions to true dcnl package . log ( " database object queued for deletion twice" , new runtime exception ( ) ) ; / / $non - nls - 1$ dcnl object earlier data = this . pending deletions . get ( address of node to delete ) ; dcnl if ( earlier data instanceof runtime exception ) { dcnl runtime exception exception = ( runtime exception ) earlier data ; dcnl dcnl package . log ( " data associated with earlier deletion stack was : " , exception ) ; / / $non - nls - 1$
detach from old target ( nd , address , old target address ) ; dcnl dcnl target . put ( nd , field start , new target address ) ; dcnl if ( new target address ! = 0 ) { dcnl / / note that new value is the address of the backpointer list and record ( the address of the struct dcnl / / containing the forward pointer ) is the value being inserted into the list . dcnl backpointer index . put ( nd , field start , this . back pointer . add ( nd , new target address , address ) ) ; dcnl } else { dcnl if ( this . points to owner ) { dcnl nd . schedule deletion ( address ) ; dcnl } dcnl } dcnl } dcnl dcnl protected void detach from old target ( nd nd , long address , long old target address ) { dcnl long field start = address + this . offset ;
delete resource ( next , delete monitor . split ( 1 ) ) ;
/ * * dcnl * performs a non - atomic delete of the given resource file . first , it marks the file as being invalid dcnl * ( by clearing out its timestamp ) . then it deletes the children of the resource file , one child at a time . dcnl * once all the children are deleted , the resource itself is deleted . the result on the database is exactly dcnl * the same as if the caller had called to delete . delete ( ) , but doing it this way ensures that a write lock dcnl * will never be held for a nontrivial amount of time . dcnl * / dcnl protected void delete resource ( nd resource file to delete , i progress monitor monitor ) { dcnl sub monitor deletion monitor = sub monitor . convert ( monitor , 10 ) ; dcnl dcnl this . nd . acquire write lock ( deletion monitor . split ( 1 ) ) ; dcnl try { dcnl if ( to delete . is in index ( ) ) { dcnl to delete . mark as invalid ( ) ; dcnl } dcnl } finally { dcnl this . nd . release write lock ( ) ; dcnl } dcnl dcnl for ( ; ; ) { dcnl this . nd . acquire write lock ( deletion monitor . split ( 1 ) ) ; dcnl try { dcnl if ( !to delete . is in index ( ) ) { dcnl break ; dcnl } dcnl dcnl int num children = to delete . get binding count ( ) ; dcnl deletion monitor . set work remaining ( num children + 1 ) ; dcnl if ( num children = = 0 ) { dcnl break ; dcnl } dcnl dcnl to delete . get binding ( num children - 1 ) . delete ( ) ; dcnl } finally { dcnl this . nd . release write lock ( ) ; dcnl } dcnl } dcnl dcnl this . nd . acquire write lock ( deletion monitor . split ( 1 ) ) ; dcnl try { dcnl if ( to delete . is in index ( ) ) { dcnl to delete . delete ( ) ; dcnl } dcnl } finally { dcnl this . nd . release write lock ( ) ; dcnl } dcnl } dcnl
int result = add element ( resource file , element , sub monitor . split ( 50 ) ) ;
list < nd resource file > all resources with this path = collections . empty list ( ) ;
this . nd . acquire write lock ( sub monitor . split ( 1 ) ) ;
all resources with this path = java index . find resources with path ( path string ) ;
import org . eclipse . jdt . core . tests . nd . run index tests ;
public class run index tests extends junit . framework . test case { dcnl public run index tests ( string name ) {
import java . lang . reflect . invocation target exception ; dcnl import java . lang . reflect . method ;
import org . eclipse . jdt . core . tests . nd . indexer . indexer test ;
org . eclipse . jdt . internal . core . nd . indexer ,
public static nd create nd ( file database file , chunk cache chunk cache ) { dcnl return new nd ( database file , chunk cache , create type registry ( ) , dcnl min supported version , max supported version , current version ) ; dcnl } dcnl
long usage timestamp update period = get usage timestamp update period ( ) ; dcnl long garbage cleanup timeout = get garbage cleanup timeout ( ) ;
if ( time since last used > usage timestamp update period ) {
import org . eclipse . core . runtime . platform ;
/ * * dcnl * amount of time ( milliseconds ) unreferenced files are allowed to sit in the index before they are discarded . dcnl * making this too short will cause some operations ( classpath modifications , closing / reopening projects , etc . ) dcnl * to become more expensive . making this too long will waste space in the database . dcnl * < p > dcnl * the value of this is stored in the jdt core preference called "garbage cleanup timeout ms" . the default value dcnl * is 3 days . dcnl * / dcnl private static long get garbage cleanup timeout ( ) { dcnl return platform . get preferences service ( ) . get long ( java core . plugin id , "garbage cleanup timeout ms" , / / $non - nls - 1$ dcnl 1000 * 60 * 60 * 24 * 3 , dcnl null ) ; dcnl } dcnl dcnl / * * dcnl * amount of time ( milliseconds ) before we update the "used" timestamp on a file in the index . we don't update dcnl * the timestamps every update since doing so would be unnecessarily inefficient . . . but if any of the timestamps dcnl * is older than this update period , we refresh it . dcnl * / dcnl private static long get usage timestamp update period ( ) { dcnl return get garbage cleanup timeout ( ) / 4 ; dcnl } dcnl
if ( time since last used > get usage timestamp update period ( ) ) {
import org . eclipse . core . runtime . platform ;
import org . eclipse . jdt . core . java core ;
public static boolean is enabled ( ) { dcnl return platform . get preferences service ( ) . get boolean ( java core . plugin id , "use index based search environment" , false , / / $non - nls - 1$ dcnl null ) ; dcnl } dcnl
break ;
if ( contains prefix of ( path ) ) {
boolean contains prefix of ( i path path ) { dcnl return this . map paths to roots . contains prefix of ( path ) ; dcnl } dcnl
import org . eclipse . core . runtime . preferences . i preferences service ;
private binding map < i generic type > binding map = new binding map < > ( ) ;
i generic type type model = this . binding map . get ( super binding ) ;
i generic type generic type = this . binding map . get ( interface binding ) ;
private static final string project name = " indexer test" ;
create java project ( project name , new string [ ] { "src" } , new string [ ] { "jcl18 full" } , "bin" , "1 . 8" , true ) ;
private static final i binary annotation [ ] no annotations = new i binary annotation [ 0 ] ; dcnl
return no annotations ;
/ / todo ( sxenos ) : this is causing each change event for an external jar file to be fired twice . dcnl / / we need to preserve the clearing of cached information in the jar but defer the actual firing of dcnl / / the event until after the indexer has processed the jar .
public class binary type formatter {
public static string annotation to string ( i binary annotation annotation ) {
public static string annotation to string ( i binary type annotation type annotation ) {
public static string method to string ( i binary method method ) {
method to string content ( result , method ) ;
import org . eclipse . jdt . internal . compiler . classfmt . binary type formatter ;
import org . eclipse . jdt . internal . compiler . classfmt . binary type formatter ;
import org . eclipse . jdt . internal . compiler . classfmt . binary type formatter ;
public void print memory stats ( nd node type registry < ? > node registry ) {
public long get rank ( nd dom , long address1 ) {
private type annotation builder to target ( int new target ) { dcnl return new type annotation builder ( this . parent , this . kind , this . index , this . length , new target , this . target parameter , this . target parameter2 ) ;
private type annotation builder to target ( int new target , int parameter ) { dcnl return new type annotation builder ( this . parent , this . kind , this . index , this . length , new target , parameter , this . target parameter2 ) ;
public i type annotation builder to supertype ( short super type index ) { dcnl return to target ( annotation target type constants . class extends , super type index ) ;
public i type annotation builder to method parameter ( short parameter index ) { dcnl return to target ( annotation target type constants . method formal parameter , parameter index ) ;
builder . append ( " [ " ) ; / / $non - nls - 1$
builder . append ( " ] = " ) ; / / $non - nls - 1$
sub monitor wait monitor = sub monitor . set work remaining ( 10 ) . split ( 8 ) . set work remaining ( total work ) ;
if ( wait monitor . is canceled ( ) | | this . processing thread = = null )
string indexing = messages . bind ( messages . jobmanager files to index , current job . get job family ( ) , integer . to string ( awaiting jobs count ) ) ; dcnl wait monitor . sub task ( indexing ) ; dcnl / / ratio of the amount of work relative to the total work dcnl float ratio = awaiting jobs count < total work ? 1 : ( ( float ) total work ) / awaiting jobs count ; dcnl if ( last jobs count > awaiting jobs count ) { dcnl total worked + = ( last jobs count - awaiting jobs count ) * ratio ; dcnl } else { dcnl / / more jobs were added , just increment by the ratio dcnl total worked + = ratio ;
boolean has changes = false ;
has changes = true ;
char [ ] [ ] parameter names = next . get argument names ( ) ;
if ( compiler defined parameters are included in signature & & parameter names ! = null ) { dcnl num compiler defined parameters = math . max ( 0 , dcnl parameter field descriptors . size ( ) - parameter names . length ) ; dcnl } dcnl dcnl int parameter name idx = 0 ;
/ * * dcnl * enable this to index the content of output folders , in cases where that content exists and dcnl * is up - to - date . this is much faster than indexing source files directly . dcnl * / dcnl public static boolean experimental index output folders ;
if ( experimental index output folders ) { dcnl i path default output location = java project . get output location ( ) ; dcnl for ( i classpath entry next : entries ) { dcnl i path next output location = next . get output location ( ) ; dcnl dcnl if ( next output location = = null ) { dcnl next output location = default output location ; dcnl } dcnl dcnl i resource resource = this . root . find member ( next output location ) ; dcnl if ( resource ! = null ) { dcnl resources to scan . add ( resource ) ; dcnl }
import org . eclipse . jdt . internal . core . nd . indexer . indexer ;
sub monitor sub monitor = sub monitor . convert ( progress monitor , 2 ) ;
import org . eclipse . core . runtime . operation canceled exception ;
import org . eclipse . jdt . internal . core . search . processing . i job ;
import java . util . bit set ;
private final bit set reserved = new bit set ( ) ;
if ( this . types . contains key ( type id ) | | this . reserved . get ( type id ) ) {
if ( this . types . contains key ( type id ) | | this . reserved . get ( type id ) ) {
import org . eclipse . jdt . internal . core . java element delta ;
import org . eclipse . jdt . core . i classpath entry ; dcnl import org . eclipse . jdt . core . i compilation unit ; dcnl import org . eclipse . jdt . core . i java element ; dcnl import org . eclipse . jdt . core . i java project ; dcnl import org . eclipse . jdt . core . i package fragment ; dcnl import org . eclipse . jdt . core . i type ; dcnl import org . eclipse . jdt . core . java core ; dcnl import org . eclipse . jdt . core . java model exception ; dcnl import org . eclipse . jdt . core . working copy owner ;
transitioning jar ,
java model manager . throw io exceptions in get zip file = true ;
! java model manager . get java model manager ( ) . get archive validity ( transitioning i path ) . is valid ( ) ) ;
/ / cause io exceptions to be thrown on all file operations dcnl java model manager . throw io exceptions in get zip file = false ;
! java model manager . get java model manager ( ) . get archive validity ( transitioning i path ) . is valid ( ) ) ;
public static enum archive validity { dcnl bad format , unable to read , valid ; dcnl dcnl public boolean is valid ( ) { dcnl return this = = valid ; dcnl } dcnl } dcnl
private static class invalid archive info { dcnl / * * dcnl * time at which this entry will be removed from the invalid archive list . dcnl * / dcnl final long eviction timestamp ; dcnl dcnl / * * dcnl * reason the entry was added to the invalid archive list . dcnl * / dcnl final archive validity reason ; dcnl dcnl invalid archive info ( long eviction timestamp , archive validity reason ) { dcnl this . eviction timestamp = eviction timestamp ; dcnl this . reason = reason ; dcnl } dcnl } dcnl
* synchronize on invalid archives mutex before accessing .
private final map < i path , invalid archive info > invalid archives = new hash map < i path , invalid archive info > ( ) ; dcnl private final object invalid archives mutex = new object ( ) ;
public void add invalid archive ( i path path , archive validity reason ) { dcnl synchronized ( this . invalid archives mutex ) { dcnl this . invalid archives . put ( path , new invalid archive info ( system . current time millis ( ) + invalid archive ttl milliseconds , reason ) ) ;
throw exception if archive invalid ( path ) ;
/ * * dcnl * for use in the jdt unit tests only . used for testing error handling . causes an dcnl * { @ link io exception } to be thrown in { @ link #get zip file } whenever it attempts to dcnl * read a zip file . dcnl * dcnl * @ noreference this field is not intended to be referenced by clients . dcnl * / dcnl public static boolean throw io exceptions in get zip file = false ; dcnl
if ( check invalid archive cache ) { dcnl throw exception if archive invalid ( path ) ; dcnl }
if ( throw io exceptions in get zip file ) { dcnl throw new io exception ( ) ; dcnl }
archive validity reason = ( e instanceof zip exception ) ? archive validity . bad format : archive validity . unable to read ; dcnl add invalid archive ( path , reason ) ;
private void throw exception if archive invalid ( i path path ) throws core exception { dcnl archive validity validity = get archive validity ( path ) ; dcnl if ( !validity . is valid ( ) ) { dcnl io exception reason ; dcnl if ( validity = = archive validity . bad format ) { dcnl reason = new zip exception ( ) ; dcnl } else { dcnl reason = new io exception ( ) ; dcnl } dcnl throw new core exception ( new status ( i status . error , java core . plugin id , - 1 , messages . status io exception , reason ) ) ; dcnl } dcnl } dcnl
public archive validity get archive validity ( i path path ) { dcnl invalid archive info invalid archive info ; dcnl synchronized ( this . invalid archives mutex ) { dcnl invalid archive info = this . invalid archives . get ( path ) ; dcnl } dcnl if ( invalid archive info = = null ) dcnl return archive validity . valid ;
if ( now > invalid archive info . eviction timestamp ) {
/ / retry the test from the start , now that we have an up - to - date result dcnl return get archive validity ( path ) ;
return invalid archive info . reason ;
synchronized ( this . invalid archives mutex ) {
synchronized ( this . invalid archives mutex ) {
import org . eclipse . jdt . core . i java model status constants ;
int result ; dcnl try { dcnl result = add element ( resource file , element , sub monitor . split ( 50 ) ) ; dcnl } catch ( java model exception e ) { dcnl if ( debug ) { dcnl package . log ( "the file " + path string + " cannot be indexed due to a recoverable error" , null ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl } dcnl / / if this file can't be indexed due to a recoverable error , delete the nd resource file entry for it . dcnl this . nd . acquire write lock ( sub monitor . split ( 5 ) ) ; dcnl try { dcnl if ( resource file . is in index ( ) ) { dcnl resource file . delete ( ) ; dcnl } dcnl } finally { dcnl this . nd . release write lock ( ) ; dcnl } dcnl return 0 ; dcnl } catch ( runtime exception e ) { dcnl if ( debug ) { dcnl package . log ( "a runtime exception occurred while indexing " + path string , e ) ; / / $non - nls - 1$ dcnl } dcnl throw e ; dcnl }
enqueue ( result , queue , input ) ;
enqueue ( result , queue , next ) ; dcnl } dcnl return result ; dcnl }
/ * * dcnl * if to enqueue has children , they are enqueued in the given queue . if it is directly indexable , dcnl * it is added to the result . dcnl * / dcnl private void enqueue ( list < i java element > result , array deque < i java element > queue , dcnl i java element to enqueue ) throws java model exception { dcnl if ( to enqueue . get element type ( ) = = i java element . compilation unit dcnl | | to enqueue . get element type ( ) = = i java element . class file ) { dcnl result . add ( to enqueue ) ; dcnl } else if ( to enqueue instanceof i parent ) { dcnl i parent parent = ( i parent ) to enqueue ; dcnl dcnl for ( i java element child : parent . get children ( ) ) { dcnl queue . add ( child ) ; dcnl } dcnl dcnl / / we need to call is invalid archive after the call to get children , since the invalid state dcnl / / is only initialized in the call to get children . dcnl if ( ! java model manager . get java model manager ( ) . get archive validity ( to enqueue . get path ( ) ) . is valid ( ) ) { dcnl throw new java model exception ( new runtime exception ( ) , i java model status constants . io exception ) ;
import org . eclipse . jdt . internal . core . util . char array buffer ;
import org . eclipse . jdt . internal . core . util . char array buffer ;
nd type parameter . get signature ( buffer , type . get type parameters ( ) ) ;
dcnl this . nd . acquire write lock ( iteration monitor . split ( 5 ) ) ; dcnl try { dcnl if ( !resource file . is in index ( ) ) { dcnl return classes indexed ; dcnl } dcnl dcnl converter . add type ( binary type , iteration monitor . split ( 45 ) ) ; dcnl classes indexed + + ; dcnl } finally { dcnl this . nd . release write lock ( ) ; dcnl }
import org . eclipse . jdt . internal . core . nd . java . model . index binary type ;
java index local index = indexer test . index ; dcnl try ( i reader reader = local index . get nd ( ) . acquire read lock ( ) ) {
public int get flags ( ) {
public boolean exists ( ) { dcnl return this . type ref . get ( ) ! = null ; dcnl } dcnl
string context prefix = safe string ( actual . get name ( ) ) ;
compare type annotations ( context prefix , expected type annotations , actual type annotations ) ;
compare annotations ( context prefix , expected binary annotations , actual binary annotations ) ;
compare generic signatures ( context prefix + " : the generic signature did not match" , expected . get generic signature ( ) , / / $non - nls - 1$
assert equals ( context prefix + " : the enclosing method name did not match" , expected . get enclosing method ( ) , / / $non - nls - 1$
assert equals ( context prefix + " : the enclosing method name did not match" , expected . get enclosing type name ( ) , / / $non - nls - 1$
throw new illegal state exception ( context prefix + " expected fields was null - - actual fields were not" ) ; / / $non - nls - 1$
throw new illegal state exception ( context prefix + " the expected and actual number of fields did not match" ) ; / / $non - nls - 1$
compare fields ( context prefix , expected fields [ field idx ] , actual fields [ field idx ] ) ;
compare methods ( context prefix , expected method , actual method ) ;
compare type annotations ( context prefix , expected . get type annotations ( ) , actual . get type annotations ( ) ) ;
throw new illegal state exception ( message + " : expected = " + get string ( o1 ) + " , actual = " + get string ( o2 ) ) ; / / $non - nls - 1$ / / $non - nls - 2$
private static string get string ( object object ) { dcnl if ( object instanceof char [ ] ) { dcnl char [ ] char array = ( char [ ] ) object ; dcnl dcnl return new string ( char array ) ; dcnl } dcnl return object . to string ( ) ; dcnl } dcnl
private static void compare methods ( string context prefix , i binary method expected method , i binary method actual method ) { dcnl context prefix = context prefix + " . " + safe string ( expected method . get selector ( ) ) ; / / $non - nls - 1$ dcnl compare annotations ( context prefix , expected method . get annotations ( ) , actual method . get annotations ( ) ) ;
assert equals ( context prefix + " : the argument names didn't match . " , expected method . get argument names ( ) , / / $non - nls - 1$
assert equals ( context prefix + " : the default values didn't match . " , expected method . get default value ( ) , / / $non - nls - 1$
assert equals ( context prefix + " : the exception type names did not match . " , expected method . get exception type names ( ) , / / $non - nls - 1$
compare generic signatures ( context prefix + " : the method's generic signature did not match" , expected method . get generic signature ( ) , / / $non - nls - 1$
assert equals ( context prefix + " : the method descriptors did not match . " , expected method . get method descriptor ( ) , / / $non - nls - 1$
assert equals ( context prefix + " : the modifiers didn't match . " , expected method . get modifiers ( ) , actual method . get modifiers ( ) ) ; / / $non - nls - 1$
compare annotations ( context prefix , expected method . get parameter annotations ( idx , class file name ) ,
compare annotations ( context prefix , new i binary annotation [ 0 ] , dcnl expected method . get parameter annotations ( idx , class file name ) ) ;
compare annotations ( context prefix , new i binary annotation [ 0 ] , dcnl actual method . get parameter annotations ( idx , class file name ) ) ;
assert equals ( context prefix + " : the selectors did not match" , expected method . get selector ( ) , actual method . get selector ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( context prefix + " : the tag bits did not match" , expected method . get tag bits ( ) , actual method . get tag bits ( ) ) ; / / $non - nls - 1$
compare type annotations ( context prefix , expected method . get type annotations ( ) , actual method . get type annotations ( ) ) ;
private static void compare type annotations ( string context prefix , i binary type annotation [ ] expected type annotations ,
context prefix + " : the index was missing an expected type annotation : " + next expected . to string ( ) ) ; / / $non - nls - 1$
context prefix + " : the index contained an unexpected type annotation : " + next actual . to string ( ) ) ; / / $non - nls - 1$
private static void compare annotations ( string context prefix , i binary annotation [ ] expected binary annotations ,
throw new illegal state exception ( context prefix + " : expected null for the binary annotations" ) ; / / $non - nls - 1$
throw new illegal state exception ( context prefix + " : actual null for the binary annotations" ) ; / / $non - nls - 1$
throw new illegal state exception ( dcnl context prefix + " : the expected and actual number of annotations differed . expected : " / / $non - nls - 1$ dcnl + expected binary annotations . length + " , actual : " + actual binary annotations . length ) ; / / $non - nls - 1$
throw new illegal state exception ( context prefix + " : an annotation had an unexpected value" ) ; / / $non - nls - 1$
private static void compare fields ( string context prefix , i binary field field1 , i binary field field2 ) { dcnl context prefix = context prefix + " . " + safe string ( field1 . get name ( ) ) ; / / $non - nls - 1$ dcnl compare annotations ( context prefix , field1 . get annotations ( ) , field2 . get annotations ( ) ) ; dcnl assert equals ( context prefix + " : constants not equal" , field1 . get constant ( ) , field2 . get constant ( ) ) ; / / $non - nls - 1$ dcnl compare generic signatures ( context prefix + " : the generic signature did not match" , field1 . get generic signature ( ) , / / $non - nls - 1$
assert equals ( context prefix + " : the modifiers did not match" , field1 . get modifiers ( ) , field2 . get modifiers ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( context prefix + " : the tag bits did not match" , field1 . get tag bits ( ) , field2 . get tag bits ( ) ) ; / / $non - nls - 1$ dcnl assert equals ( context prefix + " : the names did not match" , field1 . get name ( ) , field2 . get name ( ) ) ; / / $non - nls - 1$ dcnl dcnl compare type annotations ( context prefix , field1 . get type annotations ( ) , field2 . get type annotations ( ) ) ; dcnl assert equals ( context prefix + " : the type names did not match" , field1 . get type name ( ) , field2 . get type name ( ) ) ; / / $non - nls - 1$ dcnl }
int flags = 0 ;
if ( next . get generic signature ( ) ! = null ) { dcnl flags | = nd method . flg generic signature present ; dcnl }
boolean has exceptions in signature = has another exception ( signature ) ;
if ( exception types = = null ) { dcnl exception types = char array utils . empty array of char arrays ; dcnl }
if ( has exceptions in signature ) { dcnl while ( has another exception ( signature ) ) { dcnl signature . start + + ; dcnl new nd method exception ( method , create type signature ( type annotations . to throws ( throws idx ) , signature , dcnl java names . binary name to field descriptor ( exception types [ throws idx ] ) ) ) ; dcnl throws idx + + ; dcnl } dcnl } else if ( exception types . length ! = 0 ) { dcnl for ( ; throws idx < exception types . length ; throws idx + + ) { dcnl char [ ] field descriptor = java names . binary name to field descriptor ( exception types [ throws idx ] ) ; dcnl signature wrapper converted wrapper = new signature wrapper ( field descriptor ) ; dcnl new nd method exception ( method , create type signature ( type annotations . to throws ( throws idx ) , converted wrapper , dcnl java names . binary name to field descriptor ( exception types [ throws idx ] ) ) ) ; dcnl }
if ( has exceptions in signature ) { dcnl flags | = nd method . flg throws signature present ; dcnl }
public static final int flg generic signature present = 0x0001 ; dcnl public static final int flg throws signature present = 0x0002 ;
if ( !method . has all flags ( nd method . flg generic signature present ) ) { dcnl return null ; dcnl }
import java . lang . reflect . modifier ;
/ / if there is no generic signature , then fall back to heuristics based on what we know about dcnl / / where the java compiler likes to create compiler - defined arguments dcnl if ( compiler defined parameters are included in signature ) { dcnl / / constructors for non - static member types get a compiler - defined first argument dcnl if ( binary type . is member ( ) dcnl & & next . is constructor ( ) dcnl & & ( ( binary type . get modifiers ( ) & modifier . static ) = = 0 ) dcnl & & parameter field descriptors . size ( ) > 0 ) { dcnl dcnl num compiler defined parameters = 1 ; dcnl } else { dcnl num compiler defined parameters = 0 ; dcnl }
char [ ] result = type . get source file name ( ) . get chars ( ) ; dcnl if ( result . length = = 0 ) { dcnl return null ; dcnl } dcnl return result ;
dcnl if ( binary type . get generic signature ( ) ! = null ) { dcnl type . set flag ( nd type . flg generic signature present , true ) ; dcnl } dcnl
compare generic signatures ( context prefix + " : the generic signature did not match" , / / $non - nls - 1$ dcnl expected . get generic signature ( ) , actual . get generic signature ( ) ) ;
throw new illegal state exception ( dcnl context prefix + " the expected and actual number of fields did not match" ) ; / / $non - nls - 1$
assert equals ( context prefix + " : the exception type names did not match . " , / / $non - nls - 1$ dcnl expected method . get exception type names ( ) , actual method . get exception type names ( ) ) ;
compare generic signatures ( context prefix + " : the method's generic signature did not match" , / / $non - nls - 1$ dcnl expected method . get generic signature ( ) , actual method . get generic signature ( ) ) ;
assert equals ( context prefix + " : the modifiers didn't match . " , expected method . get modifiers ( ) , / / $non - nls - 1$ dcnl actual method . get modifiers ( ) ) ;
assert equals ( context prefix + " : the selectors did not match" , expected method . get selector ( ) , / / $non - nls - 1$ dcnl actual method . get selector ( ) ) ; dcnl assert equals ( context prefix + " : the tag bits did not match" , expected method . get tag bits ( ) , / / $non - nls - 1$ dcnl actual method . get tag bits ( ) ) ;
throw new illegal state exception ( context prefix + " : the index was missing an expected type annotation : " / / $non - nls - 1$ dcnl + next expected . to string ( ) ) ;
throw new illegal state exception ( context prefix + " : the index contained an unexpected type annotation : " / / $non - nls - 1$ dcnl + next actual . to string ( ) ) ;
public static final byte flg generic signature present = 0x0008 ;
public void set flag ( byte flag constant , boolean value ) {
import org . eclipse . jdt . internal . core . nd . field . field byte ;
public static final field byte variable flags ;
public static final byte flg generic signature present = 0x01 ;
variable flags = type . add byte ( ) ;
if ( !type . get flag ( nd type . flg generic signature present ) ) { dcnl return null ; dcnl }
/ * * dcnl * number of milliseconds that a test case can run for before we consider it to be potentially dcnl * deadlocked and dump out a stack trace . currently set to 5 minutes . dcnl * / dcnl private static final long frozen test timeout ms = 1000 * 60 * 5 ; dcnl
import org . eclipse . jdt . internal . core . nd . util . char array utils ;
/ * * dcnl * returns method parameter names that were not defined by the compiler . dcnl * / dcnl public char [ ] [ ] get parameter names ( ) {
/ / use index to count the "real" parameters . dcnl int index = 0 ;
nd method parameter param = params . get ( idx ) ; dcnl if ( !param . is compiler defined ( ) ) { dcnl result [ index ] = param . get name ( ) . get chars ( ) ; dcnl index + + ; dcnl }
return char array utils . subarray ( result , 0 , index ) ;
i path workspace path = root . get path ( ) ;
if ( location = = null ) { dcnl return null ; dcnl } dcnl
location = location . append ( entry name ) ; dcnl index path = location . to string ( ) ; dcnl workspace path = workspace path . append ( entry name ) ;
import org . eclipse . jdt . internal . core . nd . java . model . binary type descriptor ; dcnl import org . eclipse . jdt . internal . core . nd . java . model . binary type factory ;
i binary type type info = get binary type info ( ) ;
info = get jar binary type info ( ) ;
public i binary type get binary type info ( ) throws java model exception { dcnl try { dcnl i binary type info = get jar binary type info ( ) ; dcnl if ( info = = null ) { dcnl throw new not present exception ( ) ;
return info ; dcnl } catch ( class format exception cfe ) { dcnl / / the structure remains unknown dcnl if ( java core . get plugin ( ) . is debugging ( ) ) { dcnl cfe . print stack trace ( system . err ) ; dcnl } dcnl return null ; dcnl } catch ( io exception ioe ) { dcnl throw new java model exception ( ioe , i java model status constants . io exception ) ; dcnl } catch ( core exception e ) { dcnl if ( e instanceof java model exception ) { dcnl throw ( java model exception ) e ; dcnl } else { dcnl throw new java model exception ( e ) ;
private i binary type get jar binary type info ( ) throws core exception , io exception , class format exception { dcnl binary type descriptor descriptor = binary type factory . create descriptor ( this ) ;
i binary type result = binary type factory . read type ( descriptor , null ) ;
import org . eclipse . jdt . internal . compiler . env . i dependent ; dcnl import org . eclipse . jdt . internal . core . nd . util . char array utils ; dcnl
import org . eclipse . core . resources . i file ; dcnl import org . eclipse . core . resources . resources plugin ;
private static binary type descriptor create descriptor ( package fragment pkg , class file class file ) {
public static binary type descriptor create descriptor ( i class file class file ) { dcnl class file concrete class = ( class file ) class file ; dcnl package fragment parent = ( package fragment ) class file . get parent ( ) ; dcnl dcnl return create descriptor ( parent , concrete class ) ; dcnl } dcnl
return create descriptor ( type . get class file ( ) ) ;
public static i binary type read type ( binary type descriptor descriptor ,
return raw read type ( descriptor , true ) ; dcnl } dcnl dcnl / * * dcnl * read the class file from disk , circumventing the index's cache . this should only be used by callers dcnl * that need to read information from the class file which aren't present in the index ( such as method bodies ) . dcnl * / dcnl public static class file reader raw read type ( binary type descriptor descriptor , boolean fully initialize ) throws java model exception { dcnl if ( descriptor = = null ) { dcnl return null ; dcnl } dcnl if ( descriptor . is in jar file ( ) ) { dcnl zip file zip = null ; dcnl try { dcnl zip = java model manager . get java model manager ( ) . get zip file ( new path ( new string ( descriptor . workspace path ) ) ) ; dcnl char [ ] entry name char array = char array utils . concat ( dcnl java names . field descriptor to binary name ( descriptor . field descriptor ) , suffix constants . suffix class ) ; dcnl string entry name = new string ( entry name char array ) ; dcnl zip entry ze = zip . get entry ( entry name ) ; dcnl if ( ze ! = null ) { dcnl byte contents [ ] ; dcnl try { dcnl contents = org . eclipse . jdt . internal . compiler . util . util . get zip entry byte content ( ze , zip ) ; dcnl } catch ( io exception ioe ) { dcnl throw new java model exception ( ioe , i java model status constants . io exception ) ; dcnl } dcnl class file reader reader ; dcnl try { dcnl reader = new class file reader ( contents , descriptor . index path , fully initialize ) ; dcnl } catch ( class format exception e ) { dcnl if ( java core . get plugin ( ) . is debugging ( ) ) { dcnl e . print stack trace ( system . err ) ; dcnl } dcnl return null ;
return reader ;
if ( to decorate = = null ) { dcnl throw new null pointer exception ( "to decorate" ) ; / / $non - nls - 1$ dcnl }
import org . eclipse . jdt . internal . compiler . classfmt . external annotation decorator ;
this . annotation zip file = external annotation decorator . get annotation zip file ( annotation path , null ) ;
import org . eclipse . jdt . internal . compiler . classfmt . external annotation decorator ;
zip = external annotation decorator . get annotation zip file ( classpath entry . get path ( ) , null ) ;
public class external annotation decorator implements i binary type {
public external annotation decorator ( i binary type to decorate , external annotation provider external annotation provider ) {
public external annotation decorator ( i binary type to decorate , boolean is from source ) {
import org . eclipse . jdt . internal . compiler . classfmt . external annotation decorator ;
result = new external annotation decorator ( result , true ) ;
annotation zip = external annotation decorator . get annotation zip file ( resolved path , new external annotation decorator . zip file producer ( ) {
external annotation provider annotation provider = external annotation decorator
import org . eclipse . jdt . internal . compiler . classfmt . external annotation decorator ;
this . annotation zip file = external annotation decorator
import org . eclipse . jdt . internal . compiler . classfmt . external annotation decorator ;
this . annotation zip file = external annotation decorator
import org . eclipse . jdt . internal . compiler . classfmt . class format exception ;
import org . eclipse . jdt . internal . core . nd . java . model . binary type descriptor ; dcnl import org . eclipse . jdt . internal . core . nd . java . model . binary type factory ;
public final class class file to index converter {
throws core exception , class format exception { dcnl binary type descriptor descriptor = binary type factory . create descriptor ( i class file ) ; dcnl return binary type factory . raw read type ( descriptor , true ) ;
/ * * dcnl * adds a type to the index , given an input class file and a binary name . note that the given binary name is dcnl * dcnl * @ param binary type an object used for parsing the . class file itself dcnl * @ param field descriptor the name that is used to locate the class , computed from the . class file's name and location . dcnl * in the event that the . class file has been moved , this may differ from the binary name stored in the . class file dcnl * itself , which is why this is received as an argument rather than extracted from the . class file . dcnl * @ throws core exception dcnl * / dcnl public nd type add type ( i binary type binary type , char [ ] field descriptor , i progress monitor monitor ) throws core exception { dcnl char [ ] field descriptor from class = java names . binary name to field descriptor ( binary type . get name ( ) ) ; dcnl log info ( "adding binary type " + new string ( field descriptor ) ) ; / / $non - nls - 1$
import org . eclipse . jdt . internal . compiler . classfmt . class file reader ; dcnl import org . eclipse . jdt . internal . compiler . classfmt . class format exception ;
import org . eclipse . jdt . internal . core . nd . java . model . binary type descriptor ; dcnl import org . eclipse . jdt . internal . core . nd . java . model . binary type factory ;
binary type descriptor descriptor = binary type factory . create descriptor ( next ) ; dcnl class file reader binary type = binary type factory . raw read type ( descriptor , true ) ;
converter . add type ( binary type , descriptor . field descriptor , iteration monitor . split ( 45 ) ) ;
/ * * dcnl * binary name that was recorded in the . class file if different from the binary dcnl * name that was determined by the . class's name and location . this is only set for dcnl * . class files that have been moved to the wrong folder . dcnl * / dcnl public static final field string field descriptor from class ;
field descriptor from class = type . add string ( ) ;
private char [ ] binary type name ; dcnl
init simple attributes ( ) ; dcnl dcnl return this . binary type name ;
for ( int i = 0 , length = this . deltas . length ; i < length ; i + + ) {
for ( int j = 0 ; j < children length ; j + + ) { dcnl if ( buffer . length ( ) ! = 0 & & buffer . char at ( buffer . length ( ) - 1 ) ! = ' \ n' ) { dcnl buffer . append ( ' \ n' ) ;
buffer . append ( children [ j ] ) ;
for ( int j = 0 ; j < resource deltas length ; j + + ) { dcnl if ( buffer . length ( ) ! = 0 & & buffer . char at ( buffer . length ( ) - 1 ) ! = ' \ n' ) { dcnl buffer . append ( ' \ n' ) ;
string builder buffer = new string builder ( ) ;
import org . eclipse . jdt . core . java core ;
import org . eclipse . jdt . core . compiler . categorized problem ; dcnl import org . eclipse . jdt . core . compiler . char operation ; dcnl import org . eclipse . jdt . core . compiler . i problem ; dcnl import org . eclipse . jdt . core . compiler . invalid input exception ;
import org . eclipse . jdt . internal . codeassist . impl . assist parser ; dcnl import org . eclipse . jdt . internal . codeassist . impl . engine ; dcnl import org . eclipse . jdt . internal . codeassist . select . selection javadoc parser ; dcnl import org . eclipse . jdt . internal . codeassist . select . selection node found ; dcnl import org . eclipse . jdt . internal . codeassist . select . selection on import reference ; dcnl import org . eclipse . jdt . internal . codeassist . select . selection on package reference ; dcnl import org . eclipse . jdt . internal . codeassist . select . selection on qualified type reference ; dcnl import org . eclipse . jdt . internal . codeassist . select . selection on single type reference ; dcnl import org . eclipse . jdt . internal . codeassist . select . selection parser ; dcnl import org . eclipse . jdt . internal . compiler . ast visitor ; dcnl import org . eclipse . jdt . internal . compiler . compilation result ; dcnl import org . eclipse . jdt . internal . compiler . default error handling policies ; dcnl import org . eclipse . jdt . internal . compiler . ast . ast node ; dcnl import org . eclipse . jdt . internal . compiler . ast . abstract method declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . compilation unit declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . constructor declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . field declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . import reference ; dcnl import org . eclipse . jdt . internal . compiler . ast . method declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . type declaration ; dcnl import org . eclipse . jdt . internal . compiler . ast . type parameter ;
import org . eclipse . jdt . internal . compiler . classfmt . class format exception ; dcnl import org . eclipse . jdt . internal . compiler . env . access restriction ; dcnl import org . eclipse . jdt . internal . compiler . env . i compilation unit ; dcnl import org . eclipse . jdt . internal . compiler . lookup . array binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . base type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . block scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . class scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . compilation unit scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . field binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . local type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . local variable binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . lookup environment ; dcnl import org . eclipse . jdt . internal . compiler . lookup . member type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . method scope ; dcnl import org . eclipse . jdt . internal . compiler . lookup . package binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . parameterized type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem field binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reasons ; dcnl import org . eclipse . jdt . internal . compiler . lookup . problem reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . reference binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . source type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . synthetic method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . type variable binding ; dcnl import org . eclipse . jdt . internal . compiler . parser . scanner ; dcnl import org . eclipse . jdt . internal . compiler . parser . scanner helper ; dcnl import org . eclipse . jdt . internal . compiler . parser . source type converter ; dcnl import org . eclipse . jdt . internal . compiler . parser . terminal tokens ; dcnl import org . eclipse . jdt . internal . compiler . problem . abort compilation ; dcnl import org . eclipse . jdt . internal . compiler . problem . default problem factory ; dcnl import org . eclipse . jdt . internal . compiler . problem . problem reporter ;
workspace path = class file . resource ( ) . get full path ( ) ;
* @ throws class format exception
i progress monitor monitor ) throws java model exception , class format exception {
* dcnl * @ return the newly - created class file reader or null if the given class file does not exist . dcnl * @ throws class format exception if the class file existed but was corrupt dcnl * @ throws java model exception if unable to read the class file due to a transient failure
public static class file reader raw read type ( binary type descriptor descriptor , boolean fully initialize ) throws java model exception , class format exception {
return new class file reader ( contents , descriptor . index path , fully initialize ) ;
public static boolean debug cache insertions = false ;
if ( debug cache insertions ) { dcnl system . out . println ( thread . current thread ( ) + " cache put info ( " + get element type ( element ) + " " + element . to string ( ) + " , " + info + " ) " ) ; / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ / / $non - nls - 4$ dcnl }
dcnl public static string get element type ( i java element element ) { dcnl string element type ; dcnl switch ( element . get element type ( ) ) { dcnl case i java element . java project : dcnl element type = "project" ; / / $non - nls - 1$ dcnl break ; dcnl case i java element . package fragment root : dcnl element type = "root" ; / / $non - nls - 1$ dcnl break ; dcnl case i java element . package fragment : dcnl element type = "package" ; / / $non - nls - 1$ dcnl break ; dcnl case i java element . class file : dcnl element type = "class file" ; / / $non - nls - 1$ dcnl break ; dcnl case i java element . compilation unit : dcnl element type = "compilation unit" ; / / $non - nls - 1$ dcnl break ; dcnl default : dcnl element type = "element" ; / / $non - nls - 1$ dcnl } dcnl return element type ; dcnl } dcnl
private static final string javamodelcache insertions debug = java core . plugin id + " / debug / javamodel / insertions" ; / / $non - nls - 1$
java model cache . debug cache insertions = debug & & options . get boolean option ( javamodelcache insertions debug , false ) ;
* copyright ( c ) 2015 , 2016 google , inc and others .
protected void set up ( ) throws exception { dcnl string test name = get name ( ) ; dcnl index = java index test util . create temp index ( test name ) ; dcnl super . set up ( ) ;
protected void tear down ( ) throws exception {
index . get nd ( ) . get path ( ) . delete ( ) ;
super . tear down ( ) ;
public void test subclasses of generic type can be found ( ) throws exception {
indexer indexer = new indexer ( index . get nd ( ) , root ) ;
indexer . rescan ( sub monitor . convert ( null ) ) ;
org . eclipse . jdt . core / debug / index / indexer = false
org . eclipse . jdt . core / debug / index / insertions = false
org . eclipse . jdt . core / debug / index / locks = false
org . eclipse . jdt . core / debug / index / space = false dcnl dcnl # performs self - testing during indexing by reading back every class and comparing it with the original . class file dcnl org . eclipse . jdt . core / debug / index / selftest = false
private static final string index indexer debug = java core . plugin id + " / debug / index / indexer" ; / / $non - nls - 1$ dcnl private static final string index indexer insertions = java core . plugin id + " / debug / index / insertions" ; / / $non - nls - 1$ dcnl private static final string index indexer selftest = java core . plugin id + " / debug / index / selftest" ; / / $non - nls - 1$ dcnl private static final string index locks debug = java core . plugin id + " / debug / index / locks" ; / / $non - nls - 1$ dcnl private static final string index indexer space = java core . plugin id + " / debug / index / space" ; / / $non - nls - 1$ dcnl private static final string index indexer timing = java core . plugin id + " / debug / index / timing" ; / / $non - nls - 1$
* copyright ( c ) 2015 , 2016 google , inc and others .
/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * dcnl * copyright ( c ) 2016 google , inc and others . dcnl * all rights reserved . this program and the accompanying materials dcnl * are made available under the terms of the eclipse public license v1 . 0 dcnl * which accompanies this distribution , and is available at dcnl * http : / / www . eclipse . org / legal / epl - v10 . html dcnl * dcnl * contributors : dcnl * stefan xenos ( google ) - initial implementation dcnl * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /
if ( o1 instanceof i binary type annotation ) { dcnl i binary type annotation binary annotation = ( i binary type annotation ) o1 ; dcnl i binary type annotation other binary annotation = ( i binary type annotation ) o2 ; dcnl dcnl return new type annotation wrapper ( binary annotation ) . equals ( new type annotation wrapper ( other binary annotation ) ) ; dcnl } dcnl
if ( expected type annotations = = null ) { dcnl if ( actual type annotations ! = null ) { dcnl throw new illegal state exception ( context prefix + " : expected null for the annotation list but found : " / / $non - nls - 1$ dcnl + actual type annotations . to string ( ) ) ;
return ;
assert equals ( context prefix + " : the expected and actual number of type annotations did not match" , / / $non - nls - 1$ dcnl expected type annotations . length , actual type annotations . length ) ;
/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * dcnl * copyright ( c ) 2016 google , inc and others . dcnl * all rights reserved . this program and the accompanying materials dcnl * are made available under the terms of the eclipse public license v1 . 0 dcnl * which accompanies this distribution , and is available at dcnl * http : / / www . eclipse . org / legal / epl - v10 . html dcnl * dcnl * contributors : dcnl * stefan xenos ( google ) - initial implementation dcnl * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /
import org . eclipse . jdt . internal . core . nd . java . nd type id ;
import org . eclipse . jdt . internal . core . nd . java . type ref ;
import org . eclipse . jdt . internal . core . nd . java . model . index binary type ;
public static boolean debug selftest ;
/ * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * dcnl * copyright ( c ) 2016 google , inc and others . dcnl * all rights reserved . this program and the accompanying materials dcnl * are made available under the terms of the eclipse public license v1 . 0 dcnl * which accompanies this distribution , and is available at dcnl * http : / / www . eclipse . org / legal / epl - v10 . html dcnl * dcnl * contributors : dcnl * stefan xenos ( google ) - initial implementation dcnl * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * * /
public void set up suite ( ) throws exception { dcnl super . set up suite ( ) ; dcnl index = create index ( new null progress monitor ( ) ) ; dcnl }
dcnl / * * dcnl * true iff automatic reindexing ( that is , the { @ link #rescan all ( ) } method ) is disabled dcnl * synchronize on { @ #automatic indexing mutex } while accessing . dcnl * / dcnl private boolean enable automatic indexing = true ; dcnl / * * dcnl * true iff any code tried to schedule reindexing while automatic reindexing was disabled . dcnl * synchronize on { @ #automatic indexing mutex } while accessing . dcnl * / dcnl private boolean indexer dirtied while disabled = false ; dcnl private final object automatic indexing mutex = new object ( ) ; dcnl
/ * * dcnl * enables or disables the "rescan all" method . when set to false , rescan all does nothing dcnl * and indexing will only be triggered when invoking { @ link #wait for index } . dcnl * < p > dcnl * normally the indexer runs automatically and asynchronously when resource changes occur . dcnl * however , if this variable is set to false the indexer only runs when someone invokes dcnl * { @ link #wait for index ( i progress monitor ) } . this can be used to eliminate race conditions dcnl * when running the unit tests , since indexing will not occur unless it is triggered dcnl * explicitly . dcnl * < p > dcnl * synchronize on { @ link #automatic indexing mutex } before accessing . dcnl * / dcnl public void enable automatic indexing ( boolean enabled ) { dcnl boolean run rescan = false ; dcnl synchronized ( this . automatic indexing mutex ) { dcnl if ( this . enable automatic indexing = = enabled ) { dcnl return ; dcnl } dcnl this . enable automatic indexing = enabled ; dcnl if ( enabled & & this . indexer dirtied while disabled ) { dcnl run rescan = true ; dcnl } dcnl } dcnl dcnl if ( run rescan ) { dcnl / / force a rescan when re - enabling automatic indexing since we may have missed an update dcnl this . rescan job . schedule ( ) ; dcnl } dcnl dcnl if ( !enabled ) { dcnl / / wait for any existing indexing operations to finish when disabling automatic indexing since dcnl / / we only want explicitly - triggered indexing operations to run after the method returns dcnl try { dcnl this . rescan job . join ( 0 , null ) ; dcnl } catch ( operation canceled exception | interrupted exception e ) { dcnl / / don't care dcnl } dcnl } dcnl } dcnl
synchronized ( this . automatic indexing mutex ) { dcnl this . indexer dirtied while disabled = false ; dcnl } dcnl
synchronized ( this . automatic indexing mutex ) { dcnl if ( !this . enable automatic indexing ) { dcnl if ( !this . indexer dirtied while disabled ) { dcnl this . indexer dirtied while disabled = true ; dcnl } dcnl return ; dcnl } dcnl }
public void wait for index ( i progress monitor monitor ) { dcnl try { dcnl boolean should rescan = false ; dcnl synchronized ( this . automatic indexing mutex ) { dcnl if ( !this . enable automatic indexing & & this . indexer dirtied while disabled ) { dcnl should rescan = true ; dcnl } dcnl } dcnl if ( should rescan ) { dcnl this . rescan job . schedule ( ) ; dcnl } dcnl this . rescan job . join ( 0 , monitor ) ; dcnl } catch ( interrupted exception e ) { dcnl throw new operation canceled exception ( ) ; dcnl } dcnl } dcnl
private static final string newindex indexer insertions = java core . plugin id + " / debug / newindex / insertions" ; / / $non - nls - 1$
import org . eclipse . jdt . internal . core . nd . java . nd binding ;
import org . eclipse . jdt . internal . core . nd . java . nd type ;
public static boolean debug insertions ;
if ( debug ) { dcnl package . log info ( " rescan finished" ) ; / / $non - nls - 1$ dcnl } dcnl
nd binding next deletion = to delete . get binding ( num children - 1 ) ; dcnl if ( debug insertions ) { dcnl if ( next deletion instanceof nd type ) { dcnl nd type type = ( nd type ) next deletion ; dcnl package . log info ( " deleting " + type . get type id ( ) . get field descriptor ( ) . get string ( ) + " from " / / $non - nls - 1$ / / $non - nls - 2$ dcnl + new string ( to delete . get location ( ) . get string ( ) ) + " " + to delete . address ) ; / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ dcnl } dcnl } dcnl next deletion . delete ( ) ;
package . log info ( "rescanning " + the path . to string ( ) + " , " + fingerprint ) ; / / $non - nls - 1$ / / $non - nls - 2$
import java . io . file ; dcnl import java . io . file input stream ; dcnl import java . io . file not found exception ; dcnl import java . io . io exception ; dcnl import java . io . input stream ; dcnl
public static final file fingerprint create ( i path path , i progress monitor monitor ) throws core exception { dcnl return get empty ( ) . test ( path , monitor ) . get new fingerprint ( ) ; dcnl } dcnl
* sentinel value for { @ link #time } indicating that the timestamp was not recorded as part of the fingerprint .
* worst - case accuracy of filesystem timestamps , among all supported platforms ( this is currently 1s on linux , 2s on dcnl * fat systems ) .
* synchronize on { @ link #automatic indexing mutex } while accessing .
* synchronize on { @ link #automatic indexing mutex } while accessing .
# reports changes in the java classpath and classpath resolution dcnl org . eclipse . jdt . core / debug / javamodel / classpath = false dcnl
private static final string javamodel classpath = java core . plugin id + " / debug / javamodel / classpath" ; / / $non - nls - 1$
private static final string javamodel invalid archives = java core . plugin id + " / debug / javamodel / invalid archives" ; / / $non - nls - 1$
if ( debug classpath ) { dcnl system . out . println ( " setting resolved classpath for " + this . project . get full path ( ) ) ; / / $non - nls - 1$ dcnl if ( new resolved classpath = = null ) { dcnl system . out . println ( " new classpath = null" ) ; / / $non - nls - 1$ dcnl } else { dcnl for ( i classpath entry next : new resolved classpath ) { dcnl system . out . println ( " " + next ) ; / / $non - nls - 1$ dcnl } dcnl } dcnl }
public static boolean debug classpath = false ; dcnl public static boolean debug invalid archives = false ;
if ( debug invalid archives ) { dcnl system . out . println ( " invalid jar cache : adding " + path + " , reason : " + reason ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl }
java model manager . debug classpath = debug & & options . get boolean option ( javamodel classpath , false ) ; dcnl java model manager . debug invalid archives = debug & & options . get boolean option ( javamodel invalid archives , false ) ;
if ( debug invalid archives ) { dcnl system . out . println ( " invalid jar cache : removed " + path ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl }
nd resource file resource file = null ;
resource file = java index . get resource file ( path string . to char array ( ) ) ;
/ * * dcnl * sentinel value for { @ link #time } indicating a nonexistent fingerprint . this is used for the timestamp of dcnl * nonexistent files and for the { @ link #get empty ( ) } singleton . dcnl * / dcnl public static final long never modified = 0 ; dcnl dcnl / * * dcnl * sentinel value for { @ link #time } indicating that the timestamp is was not recorded as part of the fingerprint . dcnl * this is normally used to indicate that the file's timestamp was so close to the current system time at the time dcnl * the fingerprint was computed that subsequent changes in the file might not be detected . in such cases , timestamps dcnl * are an unreliable method for determining if the file has changed and so are not included as part of the fingerprint . dcnl * / dcnl public static final long unknown = 1 ; dcnl dcnl / * * dcnl * worst - case accuracy of filesystem timestamps , among all supported platforms ( this is currently 1s on linux ) . dcnl * / dcnl private static final long worst filesystem timestamp accuracy ms = 1000 ; dcnl
private static final file fingerprint empty = new file fingerprint ( never modified , 0 , 0 ) ;
dcnl @ override dcnl public string to string ( ) { dcnl return " fingerprint test result [ matches = " + this . matches + " , needs new fingerprint = " / / $non - nls - 1$ / / $non - nls - 2$ dcnl + this . needs new fingerprint + " , new fingerprint = " + this . new fingerprint + " ] " ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl }
long current time = system . current time millis ( ) ;
if ( math . abs ( current time - last modified ) < worst filesystem timestamp accuracy ms ) { dcnl / / if the file was modified so recently that it's within our ability to measure it , don't include dcnl / / the timestamp as part of the fingerprint . if another change were to happen to the file immediately dcnl / / afterward , we might not be able to detect it using the timestamp . dcnl last modified = unknown ; dcnl }
if ( last modified ! = unknown & & last modified = = this . time & & file size = = this . size ) {
hash code = file size = = 0 ? 0 : compute hash code ( path . to file ( ) , file size , sub monitor . split ( 90 ) ) ;
file fingerprint new fingerprint = new file fingerprint ( last modified , file size , hash code ) ; dcnl return new fingerprint test result ( matches , !equals ( new fingerprint ) , new fingerprint ) ;
private static string get time string ( long timestamp ) { dcnl if ( timestamp = = unknown ) { dcnl return "unknown" ; / / $non - nls - 1$ dcnl } else if ( timestamp = = never modified ) { dcnl return "never modified" ; / / $non - nls - 1$ dcnl } dcnl return long . to string ( timestamp ) ; dcnl } dcnl
/ / used for the error - handling unit tests dcnl if ( java model manager . throw io exceptions in get zip file ) { dcnl if ( debug ) { dcnl package . log info ( " throwing simulated io exception for error handling test case" ) ; / / $non - nls - 1$ dcnl } dcnl throw new io exception ( ) ; dcnl }
file local file = get local file ( path ) ;
import java . io . io exception ;
import java . util . enumeration ;
import java . util . zip . zip entry ; dcnl import java . util . zip . zip exception ; dcnl import java . util . zip . zip file ;
import org . eclipse . jdt . internal . compiler . env . i dependent ; dcnl import org . eclipse . jdt . internal . compiler . util . suffix constants ; dcnl import org . eclipse . jdt . internal . core . jar package fragment root ;
import org . eclipse . jdt . internal . core . nd . java . java names ;
sub monitor sub monitor = sub monitor . convert ( monitor ) ;
if ( element instanceof jar package fragment root ) { dcnl jar package fragment root jar root = ( jar package fragment root ) element ;
i path workspace path = jar root . get path ( ) ; dcnl i path location = java index . get location for element ( jar root ) ;
int classes indexed = 0 ; dcnl try ( zip file zip file = new zip file ( java model manager . get local file ( jar root . get path ( ) ) ) ) { dcnl sub monitor . set work remaining ( zip file . size ( ) ) ;
for ( enumeration < ? extends zip entry > e = zip file . entries ( ) ; e . has more elements ( ) ; ) { dcnl sub monitor next entry = sub monitor . split ( 1 ) . set work remaining ( 2 ) ; dcnl zip entry member = e . next element ( ) ; dcnl if ( member . is directory ( ) ) { dcnl continue ;
next entry . split ( 1 ) ; dcnl string file name = member . get name ( ) ; dcnl dcnl boolean class file name = org . eclipse . jdt . internal . compiler . util . util . is class file name ( file name ) ; dcnl if ( class file name ) { dcnl string binary name = file name . substring ( 0 , file name . length ( ) - suffix constants . suffix string class . length ( ) ) ; dcnl char [ ] field descriptor = java names . binary name to field descriptor ( binary name . to char array ( ) ) ; dcnl string index path = jar root . get handle identifier ( ) + i dependent . jar file entry separator + binary name ; dcnl binary type descriptor descriptor = new binary type descriptor ( location . to string ( ) . to char array ( ) , field descriptor , dcnl workspace path . to string ( ) . to char array ( ) , index path . to char array ( ) ) ; dcnl try { dcnl class file reader class file reader = binary type factory . raw read type ( descriptor , true ) ; dcnl if ( class file reader ! = null & & add class to index ( resource file , descriptor . field descriptor , descriptor . index path , dcnl class file reader , next entry . split ( 1 ) ) ) { dcnl classes indexed + + ; dcnl } dcnl } catch ( core exception | class format exception exception ) { dcnl package . log ( " unable to index " + descriptor . to string ( ) , exception ) ; / / $non - nls - 1$ dcnl }
} catch ( zip exception e ) { dcnl package . log ( " the zip file " + jar root . get path ( ) + " was corrupt" , e ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl / / indicates a corrupt zip file . treat this like an empty zip file . dcnl } catch ( io exception io exception ) { dcnl throw new java model exception ( io exception , i java model status constants . io exception ) ; dcnl } catch ( core exception core exception ) { dcnl throw new java model exception ( core exception ) ; dcnl }
if ( debug & & classes indexed = = 0 ) { dcnl package . log info ( " the path " + element . get path ( ) + " contained no class files" ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl } dcnl return classes indexed ; dcnl } else if ( element instanceof i class file ) { dcnl i class file class file = ( i class file ) element ;
sub monitor iteration monitor = sub monitor . split ( 1 ) ; dcnl binary type descriptor descriptor = binary type factory . create descriptor ( class file ) ; dcnl dcnl boolean indexed = false ; dcnl try { dcnl class file reader class file reader = binary type factory . raw read type ( descriptor , true ) ; dcnl if ( class file reader ! = null ) { dcnl indexed = add class to index ( resource file , descriptor . field descriptor , descriptor . index path , dcnl class file reader , iteration monitor ) ;
package . log ( " unable to index " + class file . to string ( ) , e ) ; / / $non - nls - 1$
return indexed ? 1 : 0 ; dcnl } else { dcnl package . log info ( " unable to index elements of type " + element ) ; / / $non - nls - 1$ dcnl return 0 ;
}
import java . util . concurrent . semaphore ;
import org . eclipse . jdt . internal . core . nd . db . chunk cache ;
import org . eclipse . jdt . internal . core . nd . db . index exception ;
chunk = new chunk ( this , index ) ;
return read from index ( java index . get index ( ) , descriptor , monitor ) ;
import org . eclipse . jdt . internal . core . nd . indexer . indexer ;
indexer . get instance ( ) . wait for index ( null ) ;
indexer . get instance ( ) . wait for index ( null ) ;
indexer . get instance ( ) . wait for index ( null ) ;
import org . eclipse . jdt . internal . core . nd . indexer . indexer ;
import org . eclipse . jdt . internal . core . nd . indexer . indexer ;
indexer . get instance ( ) . enable automatic indexing ( false ) ; dcnl / / indexer . get instance ( ) . wait for index ( null ) ;
/ * * dcnl * @ deprecated uses deprecated class package admin . dcnl * /
@ suppress warnings ( "deprecation" )
this . db file = file . create temp file ( "ndtest" , "db" ) ; dcnl this . nd = database test util . create empty nd ( get name ( ) ) ; dcnl this . db = this . nd . get db ( ) ; dcnl this . db . set exclusive lock ( ) ; dcnl this . root record = database . data area offset ; dcnl this . comparator = new bt mock record comparator ( ) ; dcnl this . btree = new b tree ( this . nd , this . root record , degree , this . comparator ) ;
this . db . close ( ) ; dcnl this . db file . delete on exit ( ) ;
bt mock record value1 = new bt mock record ( this . db , 42 ) ; dcnl bt mock record value2 = new bt mock record ( this . db , 42 ) ;
long insert1 = this . btree . insert ( value1 . get record ( ) ) ; dcnl long insert2 = this . btree . insert ( value2 . get record ( ) ) ;
final sorted set < integer > expected = new tree set < > ( ) ; dcnl final list < bt mock record > history = new array list < > ( ) ;
bt mock record bt value = new bt mock record ( this . db , value . int value ( ) ) ;
this . btree . insert ( bt value . get record ( ) ) ;
bt mock record bt value = history . get ( index ) ;
this . btree . delete ( bt value . get record ( ) ) ;
assert b tree matches sorted set ( " [ iteration " + i + " ] " , this . btree , expected ) ;
assert b tree matches sorted set ( " [ trial end ] " , this . btree , expected ) ;
string error report = this . btree . get invariants error report ( ) ;
public void assert b tree matches sorted set ( final string msg , b tree actual , sorted set < integer > expected ) throws core exception { dcnl final iterator < integer > i = expected . iterator ( ) ; dcnl this . btree . accept ( new ib tree visitor ( ) {
bt mock record bt value = new bt mock record ( record , b tree tests . this . db ) ;
integer exp = i . next ( ) ; dcnl assert equals ( msg + " differ at index : " + this . k , bt value . int value ( ) , exp . int value ( ) ) ; dcnl this . k + + ;
this . record = db . malloc ( bt mock record . record size , database . pool misc ) ; dcnl db . put int ( this . record + value ptr , value ) ;
return this . db . get int ( this . record ) ;
return this . record ;
public bt mock record comparator ( ) { dcnl } dcnl
this . nd = new nd ( database test util . get temp db name ( test name ) , new chunk cache ( ) , registry ,
this . db = this . nd . get db ( ) ; dcnl this . db . set exclusive lock ( ) ;
offset = this . db . malloc ( database . max malloc size , database . pool misc ) ;
this . db . flush ( ) ;
this . db . flush ( ) ;
this . db . close ( ) ; dcnl if ( !this . db . get location ( ) . delete ( ) ) { dcnl this . db . get location ( ) . delete on exit ( ) ;
this . db = null ;
assert equals ( current version , this . db . get version ( ) ) ;
long mem = this . db . malloc ( realsize , database . pool misc ) ; dcnl assert equals ( - blocksize , this . db . get short ( mem - database . block header size ) ) ; dcnl this . db . free ( mem , database . pool misc ) ; dcnl assert equals ( blocksize , this . db . get short ( mem - database . block header size ) ) ; dcnl assert equals ( mem , this . db . get rec ptr ( ( deltas - database . min block deltas + 1 ) * database . int size ) ) ; dcnl assert equals ( mem + blocksize , this . db . get rec ptr ( ( free deltas - database . min block deltas + 1 ) * database . int size ) ) ;
dcnl long mem1 = this . db . malloc ( realsize , database . pool misc ) ; dcnl long mem2 = this . db . malloc ( realsize , database . pool misc ) ; dcnl this . db . free ( mem1 , database . pool misc ) ; dcnl this . db . free ( mem2 , database . pool misc ) ; dcnl assert equals ( mem2 , this . db . get rec ptr ( ( deltas - database . min block deltas + 1 ) * database . int size ) ) ; dcnl assert equals ( 0 , this . db . get rec ptr ( mem2 ) ) ; dcnl assert equals ( mem1 , this . db . get rec ptr ( mem2 + database . int size ) ) ; dcnl assert equals ( mem2 , this . db . get rec ptr ( mem1 ) ) ; dcnl assert equals ( 0 , this . db . get rec ptr ( mem1 + database . int size ) ) ;
long mem1 = this . db . malloc ( 42 , database . pool misc ) ; dcnl this . db . free ( mem1 , database . pool misc ) ; dcnl long mem2 = this . db . malloc ( 42 , database . pool misc ) ;
private long address ;
public int compare ( long to compare ) { dcnl return this . db . get string ( this . db . get rec ptr ( to compare + 4 ) ) . compare ( this . key , true ) ;
public boolean visit ( long to compare ) { dcnl this . address = to compare ;
return this . address ;
public int compare ( nd nd to compare , long record1 , long record2 ) { dcnl i string string1 = database test . this . db . get string ( database test . this . db . get rec ptr ( record1 + 4 ) ) ; dcnl i string string2 = database test . this . db . get string ( database test . this . db . get rec ptr ( record2 + 4 ) ) ;
b tree btree = new b tree ( this . nd , database . data area offset , comparator ) ;
long record = this . db . malloc ( 8 , database . pool misc ) ; dcnl this . db . put int ( record + 0 , i ) ; dcnl i string string = this . db . new string ( name ) ; dcnl this . db . put rec ptr ( record + 4 , string . get record ( ) ) ;
find visitor finder = new find visitor ( this . db , name ) ;
assert equals ( i , this . db . get int ( record ) ) ; dcnl i string rname = this . db . get string ( this . db . get rec ptr ( record + 4 ) ) ;
assert cmp ( "" , this . eq , "" , true ) ; dcnl assert cmp ( "" , this . eq , "" , false ) ;
assert cmp ( "a" , this . lt , "b" , true ) ; dcnl assert cmp ( "aa" , this . lt , "ab" , true ) ; dcnl assert cmp ( "a" , this . eq , "a" , true ) ;
assert cmp ( "a" , this . gt , "a" , true ) ; dcnl assert cmp ( "aa" , this . gt , "a a" , true ) ; dcnl assert cmp ( "a" , this . gt , "b" , true ) ;
assert cmp ( "a" , this . eq , "a" , false ) ; dcnl assert cmp ( "a" , this . eq , "a" , false ) ;
/ / long start = system . current time millis ( ) ;
for ( file file ; ( file = this . files to delete on tear down . poll last ( ) ) ! = null ; ) {
this . files to delete on tear down . add ( file ) ;
this . files to delete on tear down . add ( file ) ;
this . files to delete on tear down . add ( file ) ;
public static test suite suite ( class < ? extends base test case > clazz ) {
protected static test suite suite ( class < ? extends base test case > clazz , string failing test prefix ) {
private static test get failing tests ( class < ? extends base test case > clazz , string prefix ) {
hash set < string > names = new hash set < > ( ) ; dcnl class < ? > super class = clazz ;
private static void add failing method ( test suite suite , method m , set < string > names , dcnl class < ? extends base test case > clazz , string prefix ) { dcnl string name = m . get name ( ) ;
class < ? > [ ] parameters = m . get parameter types ( ) ; dcnl class < ? > return type = m . get return type ( ) ;
test test = test suite . create test ( clazz , name ) ;
final list < i status > status log = collections . synchronized list ( new array list < > ( ) ) ;
if ( status log . size ( ) ! = this . f expected logged non ok ) { dcnl string builder msg = new string builder ( " expected number ( " + this . f expected logged non ok + " ) of " ) ;
if ( !this . f expect failure | | boolean . parse boolean ( system . get property ( "show expected failures" ) ) ) {
if ( this . f bug number > 0 ) { dcnl err + = " , bug #" + this . f bug number ;
this . f expect failure = true ; dcnl this . f bug number = bug number ;
import org . eclipse . jdt . internal . compiler . classfmt . class file reader ;
import org . eclipse . jdt . internal . core . nd . java . model . binary type descriptor ;
iteration mon . set work remaining ( result . size ( ) ) ;
sub monitor class mon = iteration mon . split ( 1 ) ; dcnl binary type descriptor descriptor = binary type factory . create descriptor ( next class ) ; dcnl index binary type indexed binary type = ( index binary type ) binary type factory . read from index ( descriptor , class mon ) ; dcnl class file reader original binary type = binary type factory . raw read type ( descriptor , true ) ;
import org . eclipse . jdt . core . i class file ;
import org . eclipse . jdt . internal . compiler . classfmt . class format exception ;
import org . eclipse . jdt . internal . core . class file ; dcnl import org . eclipse . jdt . internal . core . java element ; dcnl import org . eclipse . jdt . internal . core . java project ; dcnl import org . eclipse . jdt . internal . core . name lookup ; dcnl import org . eclipse . jdt . internal . core . openable ; dcnl import org . eclipse . jdt . internal . core . resolved binary type ; dcnl import org . eclipse . jdt . internal . core . searchable environment ; dcnl import org . eclipse . jdt . internal . core . source type element info ;
i class file cf = ( i class file ) class file ; dcnl i binary type info ; dcnl try { dcnl info = binary type factory . create ( cf , null ) ; dcnl } catch ( java model exception | class format exception e ) { dcnl if ( type hierarchy . debug ) { dcnl e . print stack trace ( ) ;
return null ;
/ / the old version returned this , but it doesn't conform to the spec on i binary type . get file name ( ) :
/ / version that conforms to the java doc spec on i binary type . get file name ( ) - - note that this breaks dcnl / / inline method tests in the jdt ui project . need to investigate why before using it . dcnl / / index path = workspace path . to string ( ) + i dependent . jar file entry separator + entry name ;
index path = workspace path . append ( entry name ) . to string ( ) ;
import org . eclipse . core . runtime . operation canceled exception ;
boolean was interrupted = false ;
was interrupted = this . db . give up exclusive lock ( flush ) | | was interrupted ;
/ * * dcnl * uninterruptable . returns true iff an attempt was made to interrupt the flush with dcnl * { @ link thread#interrupt ( ) } . dcnl * / dcnl boolean flush ( ) throws index exception { dcnl boolean was canceled = false ;
was canceled = this . f database . write ( buf , ( long ) this . f sequence number * database . chunk size ) ;
import org . eclipse . core . runtime . operation canceled exception ;
/ / always reopen the file if possible or subsequent reads will fail . dcnl open file ( ) ; dcnl dcnl / / this is the most common type of interruption . if another thread called thread . interrupt , dcnl / / throw an operation canceled exception . dcnl if ( e instanceof closed by interrupt exception ) { dcnl throw new operation canceled exception ( ) ; dcnl } dcnl dcnl / / if we've retried too many times , just rethrow the exception . dcnl if ( + + retries > = 20 ) { dcnl throw e ; dcnl } dcnl dcnl / / otherwise , retry
/ * * dcnl * attempts to write to the given position in the file . will retry if interrupted by thread . interrupt ( ) until , dcnl * the write succeeds . it will return true if any call to thread . interrupt ( ) was detected . dcnl * dcnl * @ return true iff a call to thread . interrupt ( ) was detected at any point during the operation . dcnl * @ throws io exception dcnl * / dcnl boolean write ( byte buffer buf , long position ) throws io exception { dcnl return perform uninterruptable write ( ( ) - > { this . f file . get channel ( ) . write ( buf , position ) ; } ) ; dcnl } dcnl dcnl private static interface io runnable { dcnl void run ( ) throws io exception ; dcnl } dcnl dcnl / * * dcnl * attempts to perform an uninterruptable write operation on the database . returns true if an attempt was made dcnl * to interrupt it . dcnl * dcnl * @ throws io exception dcnl * / dcnl private boolean perform uninterruptable write ( io runnable runnable ) throws io exception { dcnl boolean interrupted = false ;
runnable . run ( ) ; dcnl return interrupted ;
open file ( ) ; dcnl dcnl if ( e instanceof closed by interrupt exception ) { dcnl / / retry forever if necessary as long as another thread is calling thread . interrupt dcnl interrupted = true ; dcnl } else { dcnl if ( + + retries > 20 ) { dcnl throw e ; dcnl } dcnl }
* empty the contents of the database , make it ready to start again . interrupting the thread with dcnl * { @ link thread#interrupt ( ) } won't interrupt the write . returns true iff the thread was interrupted dcnl * with { @ link thread#interrupt ( ) } . dcnl *
public boolean clear ( int version ) throws index exception {
boolean was canceled = false ;
was canceled = this . f header chunk . flush ( ) | | was canceled ; / / zero out header chunk . dcnl was canceled = perform uninterruptable write ( ( ) - > { dcnl this . f file . get channel ( ) . truncate ( chunk size ) ; dcnl } ) | | was canceled ;
was canceled = flush ( ) | | was canceled ;
return was canceled ;
public boolean give up exclusive lock ( final boolean flush ) throws index exception { dcnl boolean was interrupted = false ;
was interrupted = flush and unlock chunks ( dirty chunks , flush ) | | was interrupted ;
return was interrupted ;
public boolean flush ( ) throws index exception { dcnl boolean was interrupted = false ;
was interrupted = give up exclusive lock ( true ) | | was interrupted ;
return was interrupted ;
return flush and unlock chunks ( dirty chunks , true ) | | was interrupted ;
/ * * dcnl * interrupting the thread with { @ link thread#interrupt ( ) } won't interrupt the write . returns true iff an attempt dcnl * was made to interrupt the thread with { @ link thread#interrupt ( ) } . dcnl * dcnl * @ throws index exception dcnl * / dcnl private boolean flush and unlock chunks ( final array list < chunk > dirty chunks , boolean is complete ) throws index exception { dcnl boolean was interrupted = false ;
was interrupted = mark file incomplete ( ) | | was interrupted ;
was interrupted = chunk . flush ( ) | | was interrupted ;
was interrupted = this . f header chunk . flush ( ) | | was interrupted ;
return was interrupted ;
private boolean mark file incomplete ( ) throws index exception { dcnl boolean was interrupted = false ;
was interrupted = perform uninterruptable write ( ( ) - > this . f file . get channel ( ) . write ( buf , 0 ) ) ;
final i progress monitor monitor ) {
import org . eclipse . jdt . internal . compiler . lookup . binary type binding . external annotation status ;
import org . eclipse . ui . platform ui ;
platform ui . get workbench ( ) . get help system ( ) . set help ( res action , i java help context ids . show javadoc action ) ;
platform ui . get workbench ( ) . get help system ( ) . set help ( action , i java help context ids . show outline action ) ;
platform ui . get workbench ( ) . get help system ( ) . set help ( action , i java help context ids . open structure action ) ;
private button f enable hcr button ;
f enable hcr button = swt factory . create check button ( group , debug ui messages . java debug preference page enable hot code replace 1 , null , true , 1 ) ;
prefs . put boolean ( jdi debug plugin . pref enable hcr , f enable hcr button . get selection ( ) ) ;
f enable hcr button . set selection ( prefs . get boolean ( jdi debug plugin . pref enable hcr , true ) ) ;
expected problem attributes . put ( " exported package does not exist or is empty" , new problem attributes ( categorized problem . cat type ) ) ;
expected problem attributes . put ( " nested service impl" , new problem attributes ( categorized problem . cat type ) ) ;
expected problem attributes . put ( " service impl not defined by module" , new problem attributes ( categorized problem . cat type ) ) ;
expected problem attributes . put ( " exported package does not exist or is empty" , skip ) ;
expected problem attributes . put ( " nested service impl" , skip ) ;
" the service implementation com . greetings . my world does not have a no - arg constructor" , markers ) ;
" the no - arg constructor of service implementation com . greetings . my world is not public" , markers ) ;
import org . eclipse . jdt . internal . compiler . lookup . package binding ;
public package binding resolved package ;
import org . eclipse . jdt . internal . compiler . lookup . package binding ;
set < package binding > exported pkgs = new hash set < > ( ) ;
export reference ref = this . exports [ i ] ; dcnl if ( ref . resolve ( this . scope ) ) { dcnl if ( !exported pkgs . add ( ref . resolved package ) ) { dcnl this . scope . problem reporter ( ) . invalid export reference ( i problem . duplicate exports , ref ) ; dcnl } dcnl }
module binding declaring module = impl . module ( ) ; dcnl if ( declaring module ! = this . module binding ) { dcnl problem id = problem reasons . service impl not defined by module ; dcnl } else if ( impl . is nested type ( ) & & !impl . is static ( ) ) { dcnl problem id = problem reasons . service impl cannotbe nested ; dcnl } else if ( impl . is abstract ( ) ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* dcnl * this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp .
import org . eclipse . jdt . internal . compiler . ast . export reference ;
public void invalid export reference ( int problem , export reference ref ) { dcnl this . handle ( problem , dcnl no argument , new string [ ] { char operation . char to string ( ref . pkg name ) } , dcnl ref . source start , ref . source end ) ; dcnl } dcnl
# java9 - module declaration related
string okname = base + ok + integer . to string ( i + 1 ) + " . png" ; / / $non - nls - 1$
statement then statement = node . get then statement ( ) ; dcnl statement else statement = node . get else statement ( ) ; dcnl if ( ! ( then statement instanceof block ) ) { dcnl boolean keep then on same line = this . options . keep then statement on same line dcnl | | ( this . options . keep simple if on one line & & else statement = = null ) ; dcnl if ( keep then on same line ) { dcnl this . wrap indexes . add ( this . tm . first index in ( then statement , - 1 ) ) ;
this . wrap group end = this . tm . last index in ( then statement , - 1 ) ;
set token wrap policy ( 0 , policy , true ) ;
set token wrap policy ( i , policy , wrap preceeding comments ) ;
private void set token wrap policy ( int wrap indexes index , wrap policy policy , boolean wrap preceeding comments ) { dcnl int index = this . wrap indexes . get ( wrap indexes index ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
if ( ref ! = null & & ref . resolve ( this . scope ) ! = null ) {
if ( ref ! = null & & ref . resolve ( this . scope ) ) {
if ( this . uses [ i ] ! = null & & this . uses [ i ] . resolve type ( this . scope ) ! = null ) {
if ( this . interfaces [ i ] ! = null & & this . interfaces [ i ] . resolve type ( this . scope ) ! = null ) {
seek module aware partial package fragments ( name , requestor , context ) ;
check module packages ( requestor , context , pkg index ) ;
* true iff automatic reindexing ( that is , the { @ link #rescan all ( ) } method ) is disabled synchronize on dcnl * { @ link #automatic indexing mutex } while accessing .
* true iff any code tried to schedule reindexing while automatic reindexing was disabled . synchronize on dcnl * { @ link #automatic indexing mutex } while accessing .
* enable this to index the content of output folders , in cases where that content exists and is up - to - date . this is dcnl * much faster than indexing source files directly .
private job rescan job = job . create ( messages . indexer updating index job name , monitor - > { dcnl rescan ( monitor ) ;
set < i path > indexables with changes = new hash set < > ( dcnl get indexables that have changed ( all indexables . key set ( ) , fingerprints ) ) ;
classes indexed + = rescan archive ( current time ms , next , all indexables . get ( next ) , dcnl fingerprints . get ( next ) . get new fingerprint ( ) , loop monitor . split ( 1 ) ) ;
double average gc time ms = gc files = = 0 ? 0 : ( double ) garbage collection ms / ( double ) gc files ; dcnl double average index time ms = classes indexed = = 0 ? 0 : ( double ) indexing time ms / ( double ) classes indexed ; dcnl double average fingerprint time ms = all indexables . size ( ) = = 0 ? 0 dcnl : ( double ) fingerprint time ms / ( double ) all indexables . size ( ) ; dcnl double average resource mapping ms = paths to update . size ( ) = = 0 ? 0 dcnl : ( double ) resource mapping time ms / ( double ) paths to update . size ( ) ;
string binary name = file name . substring ( 0 , dcnl file name . length ( ) - suffix constants . suffix string class . length ( ) ) ;
string index path = jar root . get handle identifier ( ) + i dependent . jar file entry separator dcnl + binary name ; dcnl binary type descriptor descriptor = new binary type descriptor ( location . to string ( ) . to char array ( ) , dcnl field descriptor , workspace path . to string ( ) . to char array ( ) , index path . to char array ( ) ) ;
byte [ ] contents = org . eclipse . jdt . internal . compiler . util . util . get zip entry byte content ( member , dcnl zip file ) ;
package . log info ( " inserting " + new string ( field descriptor ) + " into " / / $non - nls - 1$ / / $non - nls - 2$ dcnl + resource file . get location ( ) . get string ( ) + " " + resource file . address ) ; / / $non - nls - 1$
/ / when this debug flag is on , we test everything written to the index by reading it back immediately after dcnl / / indexing and comparing it with the original class file .
package . log info ( dcnl " could not find class in index immediately after indexing it : " + new string ( index path ) ) ; / / $non - nls - 1$
this . listeners = collections . new set from map ( new weak hash map < > ( ) ) ;
# copyright ( c ) 2000 , 2016 ibm corporation and others .
# copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2004 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , 1 ) ;
import org . eclipse . core . runtime . sub monitor ;
compiler options compiler options = new compiler options ( options ) ; dcnl compiler options . ignore method bodies = ( flags & i compilation unit . ignore method bodies ) ! = 0 ; dcnl parser parser = new comment recorder parser ( dcnl new problem reporter ( dcnl default error handling policies . proceed with all problems ( ) , dcnl compiler options , dcnl new default problem factory ( ) ) , dcnl false ) ; dcnl int unit length = compilation units . length ; dcnl sub monitor sub monitor = sub monitor . convert ( monitor ) ; dcnl for ( int i = 0 ; i < unit length ; i + + ) { dcnl sub monitor . set work remaining ( unit length - i ) ; dcnl org . eclipse . jdt . internal . compiler . env . i compilation unit source unit = ( org . eclipse . jdt . internal . compiler . env . i compilation unit ) compilation units [ i ] ; dcnl compilation result compilation result = new compilation result ( source unit , 0 , 0 , dcnl compiler options . max problems per unit ) ; dcnl compilation unit declaration compilation unit declaration = parser . diet parse ( source unit , compilation result ) ; dcnl dcnl if ( compilation unit declaration . ignore method bodies ) { dcnl compilation unit declaration . ignore further investigation = true ; dcnl / / if initial diet parse did not work , no need to dig into method bodies . dcnl continue ; dcnl }
/ / fill the methods bodies in order for the code to be generated dcnl / / real parse of the method . . . . dcnl org . eclipse . jdt . internal . compiler . ast . type declaration [ ] types = compilation unit declaration . types ; dcnl if ( types ! = null ) { dcnl for ( int j = 0 , type length = types . length ; j < type length ; j + + ) { dcnl types [ j ] . parse methods ( parser , compilation unit declaration ) ;
}
/ / convert ast dcnl compilation unit node = convert ( compilation unit declaration , parser . scanner . get source ( ) , api level , options , dcnl false / * don't resolve binding * / , null / * no owner needed * / , null / * no binding table needed * / , dcnl flags / * flags * / , sub monitor . split ( 1 ) , true ) ; dcnl node . set type root ( compilation units [ i ] ) ;
/ / accept ast dcnl ast requestor . accept ast ( compilation units [ i ] , node ) ;
compiler options compiler options = new compiler options ( options ) ; dcnl compiler options . ignore method bodies = ( flags & i compilation unit . ignore method bodies ) ! = 0 ; dcnl parser parser = new comment recorder parser ( dcnl new problem reporter ( dcnl default error handling policies . proceed with all problems ( ) , dcnl compiler options , dcnl new default problem factory ( ) ) , dcnl false ) ; dcnl int unit length = source units . length ; dcnl sub monitor sub monitor = sub monitor . convert ( monitor , unit length ) ; dcnl for ( int i = 0 ; i < unit length ; i + + ) { dcnl sub monitor iteration monitor = sub monitor . split ( 1 ) ; dcnl char [ ] contents = null ; dcnl string encoding = encodings ! = null ? encodings [ i ] : null ; dcnl try { dcnl contents = util . get file char content ( new file ( source units [ i ] ) , encoding ) ; dcnl } catch ( io exception e ) { dcnl / / go to the next unit dcnl continue ; dcnl } dcnl if ( contents = = null ) { dcnl / / go to the next unit dcnl continue ; dcnl } dcnl org . eclipse . jdt . internal . compiler . batch . compilation unit compilation unit = new org . eclipse . jdt . internal . compiler . batch . compilation unit ( contents , source units [ i ] , encoding ) ; dcnl org . eclipse . jdt . internal . compiler . env . i compilation unit source unit = compilation unit ; dcnl compilation result compilation result = new compilation result ( source unit , 0 , 0 , compiler options . max problems per unit ) ; dcnl compilation unit declaration compilation unit declaration = parser . diet parse ( source unit , compilation result ) ; dcnl dcnl if ( compilation unit declaration . ignore method bodies ) { dcnl compilation unit declaration . ignore further investigation = true ; dcnl / / if initial diet parse did not work , no need to dig into method bodies . dcnl continue ; dcnl }
/ / fill the methods bodies in order for the code to be generated dcnl / / real parse of the method . . . . dcnl org . eclipse . jdt . internal . compiler . ast . type declaration [ ] types = compilation unit declaration . types ; dcnl if ( types ! = null ) { dcnl for ( int j = 0 , type length = types . length ; j < type length ; j + + ) { dcnl types [ j ] . parse methods ( parser , compilation unit declaration ) ;
}
/ / convert ast dcnl compilation unit node = convert ( compilation unit declaration , parser . scanner . get source ( ) , api level , options , dcnl false / * don't resolve binding * / , null / * no owner needed * / , null / * no binding table needed * / , dcnl flags / * flags * / , iteration monitor , true ) ; dcnl node . set type root ( null ) ;
/ / accept ast dcnl ast requestor . accept ast ( source units [ i ] , node ) ;
int amount of work = ( compilation units . length + binding keys . length ) * 2 ; / / 1 for begin to compile , 1 for resolve dcnl sub monitor sub monitor = sub monitor . convert ( monitor , amount of work ) ; dcnl environment = new cancelable name environment ( ( ( java project ) java project ) , owner , sub monitor ) ; dcnl problem factory = new cancelable problem factory ( sub monitor ) ;
sub monitor ,
int amount of work = ( source units . length + binding keys . length ) * 2 ; / / 1 for begin to compile , 1 for resolve dcnl sub monitor sub monitor = sub monitor . convert ( monitor , amount of work ) ;
environment = new name environment with progress ( all entries , null , sub monitor ) ; dcnl problem factory = new cancelable problem factory ( sub monitor ) ;
sub monitor sub monitor = sub monitor . convert ( monitor , dcnl messages . bind ( messages . import rewrite process description ) , 2 ) ; dcnl if ( !has recorded changes ( ) ) { dcnl this . created imports = char operation . no strings ; dcnl this . created static imports = char operation . no strings ; dcnl return new multi text edit ( ) ; dcnl } dcnl dcnl compilation unit used ast root = this . ast root ; dcnl if ( used ast root = = null ) { dcnl ast parser parser = ast parser . new parser ( ast . jls8 ) ; dcnl parser . set source ( this . compilation unit ) ; dcnl parser . set focal position ( 0 ) ; / / reduced ast dcnl parser . set resolve bindings ( false ) ; dcnl used ast root = ( compilation unit ) parser . create ast ( sub monitor . split ( 1 ) ) ; dcnl } dcnl dcnl import rewrite configuration config = build import rewrite configuration ( ) ; dcnl dcnl import rewrite analyzer computer = dcnl new import rewrite analyzer ( this . compilation unit , used ast root , config ) ; dcnl dcnl for ( string added import : this . added imports ) { dcnl boolean is static = static prefix = = added import . char at ( 0 ) ; dcnl string qualified name = added import . substring ( 1 ) ; dcnl computer . add import ( is static , qualified name ) ; dcnl } dcnl dcnl for ( string removed import : this . removed imports ) { dcnl boolean is static = static prefix = = removed import . char at ( 0 ) ; dcnl string qualified name = removed import . substring ( 1 ) ; dcnl computer . remove import ( is static , qualified name ) ; dcnl } dcnl dcnl for ( string type explicit simple name : this . type explicit simple names ) { dcnl computer . require explicit import ( false , type explicit simple name ) ; dcnl } dcnl dcnl for ( string static explicit simple name : this . static explicit simple names ) { dcnl computer . require explicit import ( true , static explicit simple name ) ;
sub monitor main monitor = sub monitor . convert ( monitor , messages . javamodel initialization , 100 ) ; dcnl main monitor . sub task ( messages . javamodel configuring classpath containers ) ; dcnl dcnl / / initialize all containers and variables dcnl java model manager manager = java model manager . get java model manager ( ) ;
sub monitor sub monitor = main monitor . split ( 50 ) . set work remaining ( 100 ) ; / / 50 % of the time is spent in initializing containers and variables dcnl sub monitor . step ( 5 ) ; / / give feedback to the user that something is happening dcnl manager . batch container initializations progress . initialize after load monitor . set ( sub monitor ) ; dcnl if ( manager . force batch initializations ( true / * init after load * / ) ) { / / if no other thread has started the batch container initializations dcnl manager . get classpath container ( path . empty , null ) ; / / force the batch initialization dcnl } else { / / else wait for the batch initialization to finish dcnl while ( manager . batch container initializations = = java model manager . batch initialization in progress ) { dcnl sub monitor . sub task ( manager . batch container initializations progress . sub task name ) ; dcnl sub monitor . step ( manager . batch container initializations progress . get worked ( ) ) ; dcnl synchronized ( manager ) { dcnl try { dcnl manager . wait ( 100 ) ; dcnl } catch ( interrupted exception e ) { dcnl / / continue
} finally { dcnl manager . batch container initializations progress . initialize after load monitor . set ( null ) ; dcnl } dcnl dcnl / / avoid leaking source attachment properties ( see https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 183413 ) dcnl / / and recreate links for external folders if needed dcnl main monitor . sub task ( messages . javamodel resetting source attachment properties ) ; dcnl final i java project [ ] projects = manager . get java model ( ) . get java projects ( ) ; dcnl hash set visited paths = new hash set ( ) ; dcnl external folders manager external folders manager = java model manager . get external manager ( ) ; dcnl for ( int i = 0 , length = projects . length ; i < length ; i + + ) { dcnl java project java project = ( java project ) projects [ i ] ; dcnl i classpath entry [ ] classpath ;
classpath = java project . get resolved classpath ( ) ;
/ / project no longer exist : ignore dcnl continue ;
if ( classpath ! = null ) { dcnl for ( int j = 0 , length2 = classpath . length ; j < length2 ; j + + ) { dcnl i classpath entry entry = classpath [ j ] ; dcnl if ( entry . get source attachment path ( ) ! = null ) { dcnl i path entry path = entry . get path ( ) ; dcnl if ( visited paths . add ( entry path ) ) { dcnl util . set source attachment property ( entry path , null ) ;
} dcnl / / else source might have been attached by i package fragment root#attach source ( . . . ) , we keep it dcnl if ( entry . get entry kind ( ) = = i classpath entry . cpe library ) { dcnl i path entry path = entry . get path ( ) ; dcnl if ( external folders manager . is external folder path ( entry path ) & & external folders manager . get folder ( entry path ) = = null ) { dcnl external folders manager . add folder ( entry path , true ) ;
} dcnl } dcnl try { dcnl external folders manager . create pending folders ( main monitor . split ( 1 ) ) ; dcnl } dcnl catch ( java model exception jme ) { dcnl / / creation of external folder project failed . log it and continue ; dcnl util . log ( jme , " error while processing external folders" ) ; / / $non - nls - 1$ dcnl } dcnl dcnl / / ensure external jars are refreshed ( see https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 93668 ) dcnl / / before search is initialized ( see https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 405051 ) dcnl final java model model = manager . get java model ( ) ; dcnl try { dcnl main monitor . sub task ( messages . javamodel refreshing external jars ) ; dcnl model . refresh external archives ( dcnl null / * refresh all projects * / , dcnl main monitor . split ( 1 ) / / 1 % of the time is spent in jar refresh dcnl ) ; dcnl } catch ( java model exception e ) { dcnl / / refreshing failed : ignore dcnl } dcnl dcnl / / initialize delta state dcnl main monitor . sub task ( messages . javamodel initializing delta state ) ; dcnl manager . delta state . roots are stale = true ; / / in case it was already initialized before we cleaned up the source attachment properties dcnl manager . delta state . initialize roots ( true / * init afte load * / ) ; dcnl dcnl / / dummy query for waiting until the indexes are ready dcnl main monitor . sub task ( messages . javamodel configuring searchengine ) ; dcnl search engine engine = new search engine ( ) ; dcnl i java search scope scope = search engine . create workspace scope ( ) ; dcnl try { dcnl engine . search all type names ( dcnl null , dcnl search pattern . r exact match , dcnl "! @ $#! @ " . to char array ( ) , / / $non - nls - 1$ dcnl search pattern . r pattern match | search pattern . r case sensitive , dcnl i java search constants . class , dcnl scope , dcnl new type name requestor ( ) { dcnl public void accept type ( dcnl int modifiers , dcnl char [ ] package name , dcnl char [ ] simple type name , dcnl char [ ] [ ] enclosing type names , dcnl string path ) { dcnl / / no type to accept dcnl } dcnl } , dcnl / / will not activate index query caches if indexes are not ready , since it would take to long dcnl / / to wait until indexes are fully rebuild dcnl i java search constants . cancel if not ready to search , dcnl main monitor . split ( 47 ) / / 47 % of the time is spent in the dummy search dcnl ) ; dcnl } catch ( java model exception e ) { dcnl / / / search failed : ignore dcnl } catch ( operation canceled exception e ) { dcnl if ( main monitor . is canceled ( ) ) dcnl throw e ; dcnl / / else indexes were not ready : catch the exception so that jars are still refreshed dcnl } dcnl dcnl / / check if the build state version number has changed since last session dcnl / / ( see https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 98969 ) dcnl main monitor . sub task ( messages . javamodel getting build state number ) ; dcnl qualified name q name = new qualified name ( java core . plugin id , "state version number" ) ; / / $non - nls - 1$ dcnl i workspace root root = resources plugin . get workspace ( ) . get root ( ) ; dcnl string version number = null ; dcnl try { dcnl version number = root . get persistent property ( q name ) ; dcnl } catch ( core exception e ) { dcnl / / could not read version number : consider it is new dcnl } dcnl string new version number = byte . to string ( state . version ) ; dcnl if ( !new version number . equals ( version number ) ) { dcnl / / build state version number has changed : touch every projects to force a rebuild dcnl if ( java builder . debug ) dcnl system . out . println ( " build state version number has changed" ) ; / / $non - nls - 1$ dcnl i workspace runnable runnable = new i workspace runnable ( ) { dcnl public void run ( i progress monitor progress monitor2 ) throws core exception { dcnl for ( int i = 0 , length = projects . length ; i < length ; i + + ) { dcnl i java project project = projects [ i ] ; dcnl try { dcnl if ( java builder . debug ) dcnl system . out . println ( " touching " + project . get element name ( ) ) ; / / $non - nls - 1$ dcnl new classpath validation ( ( java project ) project ) . validate ( ) ; / / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 287164 dcnl project . get project ( ) . touch ( progress monitor2 ) ; dcnl } catch ( core exception e ) { dcnl / / could not touch this project : ignore dcnl } dcnl }
} ; dcnl main monitor . sub task ( messages . javamodel building after upgrade ) ; dcnl try { dcnl resources plugin . get workspace ( ) . run ( runnable , main monitor . split ( 1 ) ) ; dcnl } catch ( core exception e ) { dcnl / / could not touch all projects
return org . eclipse . jdt . internal . compiler . classfmt . java binary names . is clinit ( get selector ( ) ) ;
return org . eclipse . jdt . internal . compiler . classfmt . java binary names . is constructor ( get selector ( ) ) ;
t = ( reference binding ) scope . substitute ( get result substitution ( this . current bounds ) , t ) ;
private substitution get result substitution ( final bound set result ) {
if ( instantiation ! = null )
expected problem attributes . put ( " non denotable type argument for anonymous diamond" , new problem attributes ( categorized problem . cat type ) ) ;
if ( allocation type . is interface ( ) ) { dcnl parameterized type binding parameterized type = ( parameterized type binding ) factory . return type ; dcnl return new parameterized method binding ( parameterized type , sfmb . get constructor ( ) ) ; dcnl }
return infer elided types ( ( parameterized type binding ) this . resolved type , scope ) ; dcnl } dcnl public type binding [ ] infer elided types ( parameterized type binding parameterized type , final scope scope ) {
reference binding generic type = parameterized type . generic type ( ) ; dcnl reference binding enclosing type = parameterized type . enclosing type ( ) ;
import java . util . arrays ; dcnl
import org . eclipse . jdt . internal . compiler . lookup . intersection type binding18 ;
import org . eclipse . jdt . internal . compiler . lookup . scope ;
import org . eclipse . jdt . internal . compiler . lookup . type binding visitor ;
if ( source level < class file constants . jdk9 ) { dcnl scope . problem reporter ( ) . diamond not with anoymous classes ( this . type ) ; dcnl return null ; dcnl }
this . resolved type = receiver type ;
method binding constructor binding = null ;
this . binding = constructor binding = infer constructor of elided parameterized type ( scope ) ;
if ( this . anonymous type ! = null ) { dcnl constructor binding = get anonymous constructor binding ( ( reference binding ) receiver type , scope ) ; dcnl if ( constructor binding = = null ) dcnl return null ; dcnl this . resolved type = this . anonymous type . binding ; dcnl / / check that inferred type is denotable dcnl if ( !check type argument validity ( ( parameterized type binding ) receiver type , scope ) ) { dcnl scope . problem reporter ( ) . anonymous diamond with non denotable type arguments ( this . type , receiver type ) ; dcnl return this . resolved type ; dcnl } dcnl }
if ( this . anonymous type ! = null ) { dcnl constructor binding = get anonymous constructor binding ( ( reference binding ) receiver type , scope ) ; dcnl if ( constructor binding = = null ) dcnl return null ; dcnl this . resolved type = this . anonymous type . binding ; dcnl } else { dcnl this . binding = constructor binding = find constructor binding ( scope , this , ( reference binding ) receiver type , this . argument types ) ; dcnl }
reference binding receiver = ( reference binding ) receiver type ; dcnl reference binding super type = receiver . is interface ( ) ? scope . get java lang object ( ) : receiver ; dcnl if ( constructor binding . is valid binding ( ) ) { dcnl if ( is method use deprecated ( constructor binding , scope , true ) ) { dcnl scope . problem reporter ( ) . deprecated method ( constructor binding , this ) ;
if ( check invocation arguments ( scope , null , super type , constructor binding , this . arguments , dcnl this . argument types , this . args contain cast , this ) ) {
if ( this . type arguments ! = null & & constructor binding . original ( ) . type variables = = binding . no type variables ) { dcnl scope . problem reporter ( ) . unnecessary type arguments for method invocation ( constructor binding , dcnl this . generic type arguments , this . type arguments ) ;
if ( constructor binding . declaring class = = null ) { dcnl constructor binding . declaring class = super type ;
scope . problem reporter ( ) . invalid constructor ( this , constructor binding ) ; dcnl return this . resolved type ; dcnl } dcnl if ( ( constructor binding . tag bits & tag bits . has missing type ) ! = 0 ) { dcnl scope . problem reporter ( ) . missing type in constructor ( this , constructor binding ) ;
if ( this . enclosing instance ! = null ) { dcnl reference binding target enclosing = constructor binding . declaring class . enclosing type ( ) ; dcnl if ( target enclosing = = null ) { dcnl scope . problem reporter ( ) . unnecessary enclosing instance specification ( this . enclosing instance , receiver ) ; dcnl return this . resolved type ; dcnl } else if ( !enclosing instance type . is compatible with ( target enclosing ) & & !scope . is boxing compatible with ( enclosing instance type , target enclosing ) ) { dcnl scope . problem reporter ( ) . type mismatch error ( enclosing instance type , target enclosing , this . enclosing instance , null ) ; dcnl return this . resolved type ; dcnl } dcnl this . enclosing instance . compute conversion ( scope , target enclosing , enclosing instance type ) ;
check type argument redundancy ( ( parameterized type binding ) receiver type , scope ) ;
if ( this . anonymous type ! = null ) { dcnl / / anonymous type scenario dcnl / / update the anonymous inner class : superclass , interface dcnl dcnl this . binding = this . anonymous type . create default constructor with binding ( constructor binding , ( this . bits & ast node . unchecked ) ! = 0 & & this . generic type arguments = = null ) ; dcnl return this . resolved type ; dcnl } else {
long source level = compiler options ( ) . source level ;
boolean is interface = allocation type . is interface ( ) ; dcnl reference binding type to search = is interface ? get java lang object ( ) : allocation type ;
method binding [ ] methods = type to search . get methods ( type constants . init , argument types . length ) ;
method binding target method = is interface ? new method binding ( method . original ( ) , generic type ) : method . original ( ) ; dcnl method binding static factory = new synthetic factory method binding ( target method , environment , original enclosing type ) ;
mismatch non null nullable ( " string" ) +
" null type mismatch : required \ ' @ non null string \ ' but the provided value is null \ n" +
if ( this . environment . uses null type annotations ( ) ) { dcnl if ( method binding . return type ! = null & & !method binding . return type . has null type annotations ( ) ) { dcnl method binding . return type = this . environment . create annotated type ( method binding . return type , dcnl new annotation binding [ ] { this . environment . get non null annotation ( ) } ) ; dcnl } dcnl }
if ( this . environment . uses null type annotations ( ) ) { dcnl if ( method binding . return type ! = null & & !method binding . return type . has null type annotations ( ) ) { dcnl method binding . return type = this . environment . create annotated type ( method binding . return type , dcnl new annotation binding [ ] { this . environment . get nullable annotation ( ) } ) ; dcnl } dcnl }
if ( this . environment . uses null type annotations ( ) ) { dcnl if ( method binding . parameters [ j ] ! = null dcnl & & !method binding . parameters [ j ] . has null type annotations ( ) ) { dcnl method binding . parameters [ j ] = this . environment . create annotated type ( dcnl method binding . parameters [ j ] , dcnl new annotation binding [ ] { this . environment . get non null annotation ( ) } ) ; dcnl } dcnl }
" null type safety ( type annotations ) : the expression of type \ ' set < @ non null t > \ ' needs unchecked conversion to conform to \ ' @ non null collection < @ non null t > \ ' , corresponding supertype is \ ' collection < @ non null t > \ ' \ n" +
import org . eclipse . jdt . internal . compiler . lookup . lookup environment ; dcnl import org . eclipse . jdt . internal . compiler . lookup . method binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . method scope ;
lookup environment environment = scope . environment ( ) ; dcnl boolean is annotation based null analysis enabled = environment . global options . is annotation based null analysis enabled ;
if ( !this . binding . has null type annotations ( ) dcnl & & scope . has default nullness for ( binding . default location type parameter ) ) { dcnl annotation binding [ ] annots = new annotation binding [ ] { environment . get non null annotation ( ) } ; dcnl type variable binding previous binding = this . binding ; dcnl this . binding = ( type variable binding ) environment . create annotated type ( this . binding , annots ) ; dcnl dcnl if ( scope instanceof method scope ) { dcnl / * dcnl * for method type parameters , references to the bindings have already been copied into dcnl * method binding . type variables - update them . dcnl * / dcnl method scope method scope = ( method scope ) scope ; dcnl if ( method scope . reference context instanceof abstract method declaration ) { dcnl method binding method binding = ( ( abstract method declaration ) method scope . reference context ) . binding ; dcnl if ( method binding ! = null ) { dcnl method binding . update type variable binding ( previous binding , this . binding ) ; dcnl } dcnl } dcnl } dcnl }
/ / tests names = new string [ ] { "test bug496574 small" } ;
static final boolean should workaround bug jdk 8153748 = true ; / / emulating javac behaviour after private email communication dcnl
if ( should workaround bug jdk 8153748 ) { dcnl if ( add jdk 8153748 constraints from invocation ( this . invocation arguments , method ) = = reduction result . true ) / / todo : return null on answer false ? dcnl this . current bounds . incorporate ( this ) ; dcnl }
list < set < inference variable > > components = this . current bounds . compute connected components ( this . inference variables ) ;
if ( argument instanceof functional expression ) { dcnl return add jdk 8153748 constraints from functional expr ( ( functional expression ) argument , parameter , method ) ; dcnl } else if ( argument instanceof invocation & & argument . is poly expression ( method ) ) {
} else if ( argument instanceof conditional expression ) { dcnl conditional expression ce = ( conditional expression ) argument ; dcnl if ( add jdk 8153748 constraints from expression ( ce . value if true , parameter , method ) = = reduction result . false ) dcnl return reduction result . false ; dcnl return add jdk 8153748 constraints from expression ( ce . value if false , parameter , method ) ;
boolean different context = outermost context ! = this ; dcnl int id = different context ? math . max ( this . next var id , outermost context . next var id ) : this . next var id ; dcnl this . next var id = id + 1 ; dcnl if ( different context ) dcnl outermost context . next var id = this . next var id ; dcnl return outermost context . interned variables [ i ] = new inference variable ( type parameter , rank , id , site , this . environment , this . object ) ;
add inference variables ( new variables ) ; dcnl return new variables ; dcnl } dcnl dcnl private void add inference variables ( inference variable [ ] new variables ) {
int len = new variables . length ;
if ( !is interned ( variable ) ) dcnl variable . update source name ( this . next var id + + ) ; dcnl } dcnl dcnl boolean is interned ( inference variable iv ) { dcnl if ( this . interned variables ! = null ) dcnl for ( int i = 0 ; i < this . interned variables . length ; i + + ) { dcnl if ( this . interned variables [ i ] = = iv ) / / $identity - comparison$ dcnl return true ; dcnl } dcnl return false ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
requestor . set ignored ( completion proposal . module ref , true ) ;
}
* copyright ( c ) 2008 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* copyright ( c ) 2005 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
step handler handler = create step into handler ( ) ;
step handler handler = create step over handler ( ) ;
step handler handler = create step return handler ( ) ;
step handler handler = create drop to frame handler ( frame ) ;
step handler handler = create step to frame handler ( frame ) ;
protected class step into handler extends step handler {
protected class step return handler extends step handler {
protected class step to frame handler extends step return handler {
protected class drop to frame handler extends step return handler {
import org . eclipse . jdt . internal . compiler . env . i module environment ;
i name environment name environment = this . environment . name environment ; dcnl if ( name environment instanceof i module aware name environment ) { dcnl return ( ( i module aware name environment ) name environment ) . is package ( parent package name , name , get module lookup context ( ) ) ;
return name environment . is package ( parent package name , name ) ;
import org . eclipse . jdt . internal . compiler . env . i module environment ; dcnl import org . eclipse . jdt . internal . compiler . env . i module path entry ;
import org . eclipse . jdt . internal . compiler . env . i module environment ;
* filters out members of { @ link java . lang . object } .
/ / reduced version for analysis ( no need to run during normal tests ) dcnl public void test439594 small ( ) { dcnl this . run negative test ( dcnl new string [ ] { dcnl "x . java" , dcnl "import java . util . array list ; \ n" + dcnl "import java . util . list ; \ n" + dcnl "import java . util . function . function ; \ n" + dcnl "import java . util . function . predicate ; \ n" + dcnl "import java . util . stream . collectors ; \ n" + dcnl "import java . util . stream . stream ; \ n" + dcnl "public class x { \ n" + dcnl " protected static interface i list entry { \ n" + dcnl " public < t > t visit records with result ( function < stream < record > , t > func ) ; \ n" + dcnl " } \ n" + dcnl " protected static final class immutable record { \ n" + dcnl " public immutable record ( record r ) { } \ n" + dcnl " } \ n" + dcnl " protected static final class record { } \ n" + dcnl " public list < immutable record > compiles with javac but not eclipse1 ( ) \ n" + dcnl " { \ n" + dcnl " return visit entries with result ( stream - > { \ n" + dcnl " return stream . map ( entry - > { \ n" + dcnl " return entry . visit records with result ( stream2 - > stream2 \ n" + dcnl " . filter ( some predicate ( ) ) \ n" + dcnl " . map ( immutable record : : new ) \ n" + dcnl " . collect ( collectors . to list ( ) ) \ n" + dcnl " ) ; \ n" + dcnl " } ) . flat map ( list : : stream ) . collect ( collectors . to collection ( array list : : new ) ) ; \ n" + dcnl " } ) ; \ n" + dcnl " } \ n" + dcnl " private static predicate < record > some predicate ( ) { \ n" + dcnl " return record - > true ; \ n" + dcnl " } \ n" + dcnl " private < t > t visit entries with result ( function < stream < i list entry > , t > func ) { \ n" + dcnl " return func . apply ( new array list < i list entry > ( ) . stream ( ) ) ; \ n" + dcnl " } \ n" + dcnl " } \ n" dcnl } , dcnl "" ) ; dcnl }
reduction result jdk8153748result = add jdk 8153748 constraints from invocation ( this . invocation arguments , method ) ; dcnl if ( jdk8153748result ! = null ) {
}
if ( !add constraints to c ( this . invocation arguments , c , method , this . inference kind , false , false , invocation site ) )
private boolean add constraints to c ( expression [ ] exprs , set < constraint formula > c , method binding method , int inference kind for method , boolean interleaved , boolean is inner ic18 , invocation site site )
if ( !add constraints to c one expr ( exprs [ i ] , c , fsi , subst f , method , interleaved , is inner ic18 ) )
private boolean add constraints to c one expr ( expression expri , set < constraint formula > c , type binding fsi , type binding subst f , method binding method , boolean interleaved , boolean is inner ic18 )
{ dcnl / / - - not per jls , emulate javac behavior : dcnl subst f = scope . substitute ( get result substitution ( is inner ic18 ? this . b2 : this . current bounds ) , subst f ) ; / / todo : b3 , rather than b2 ? ! dcnl / / - - dcnl
if ( !add constraints to c one expr ( result expression , c , r . original ( ) , r , method , true , is inner ic18 ) )
return inner context . add constraints to c ( arguments , c , inner method . generic method ( ) , inner context . inference kind , interleaved , true , invocation ) ;
return this . add constraints to c ( arguments , c , inner method . generic method ( ) , applicability kind , interleaved , is inner ic18 , invocation ) ;
public class project entry implements i module path entry {
return this . project ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
if ( parsed unit . is module info ( ) ) { dcnl module declaration module = ( module declaration ) parsed unit . types [ 0 ] ; / / todo , could be null dcnl export reference [ ] exports = module . exports ; dcnl if ( exports ! = null ) { dcnl for ( export reference export reference : exports ) { dcnl if ( export reference instanceof selection on export reference ) { dcnl char [ ] [ ] tokens = ( ( selection on export reference ) export reference ) . tokens ; dcnl this . no proposal = false ; dcnl this . requestor . accept package ( char operation . concat with ( tokens , ' . ' ) ) ; dcnl } dcnl } dcnl } dcnl }
import org . eclipse . jdt . internal . compiler . lookup . module binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . scope ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
import org . eclipse . jdt . core . i module description ;
import org . eclipse . jdt . internal . core . name lookup . answer ;
@ override dcnl public void accept module ( char [ ] module name , char [ ] unique key , int start , int end ) { dcnl i module description module = resolve module ( module name ) ; dcnl add element ( module ) ; dcnl / / todo : implement use cases to construct modules from location / key dcnl }
/ / tests names = new string [ ] { "test convert to module" } ;
system . set property ( "modules . to . load" , "java . base , java . desktop ; java . rmi ; java . sql ; " ) ;
* creates a corresponding module - info as a string for the given source package fragment root and with dcnl * the given name . the module name is optional and a null argument can be passed to indicate that the dcnl * package fragment root's element name to be used as the module name .
* this is a utility method and computes a module configuration by looking at the source files inside dcnl * the package fragment root and what modules within the project's build path are needed in order to dcnl * successfully compile the source files . for non - source package fragment roots dcnl * ( i . e . , { @ link i package fragment root#is archive ( ) } returns true ) , this method returns null .
* note this is a long - running operation and it is preferable that clients run this in a background thread .
* @ param root the package fragment root for which the module is sought dcnl * @ return the module - info content as a string
public static string create module from package root ( string module name , i package fragment root root ) throws core exception { dcnl i java project project = root . get java project ( ) ; dcnl string line delimiter = null ; dcnl if ( project ! = null ) { dcnl i scope context [ ] scope context ; dcnl / / project preference dcnl scope context = new i scope context [ ] { new project scope ( project . get project ( ) ) } ; dcnl line delimiter = platform . get preferences service ( ) . get string ( platform . pi runtime , platform . pref line separator , null , scope context ) ; dcnl } dcnl if ( line delimiter = = null ) { dcnl line delimiter = system . get property ( "line . separator" , " \ n" ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl } dcnl local module impl module = ( local module impl ) create module from package fragment root ( module name , project ) ; dcnl return module . to string ( line delimiter ) ; dcnl } dcnl
private bound set b3 ;
this . b3 = this . current bounds . copy ( ) ; dcnl dcnl if ( should workaround bug jdk 8153748 ) { / / "before 18 . 5 . 2" , but should not spill into b3 . . . ( heuristically ) dcnl reduction result jdk8153748result = add jdk 8153748 constraints from invocation ( this . invocation arguments , method ) ; dcnl if ( jdk8153748result ! = null ) { dcnl this . current bounds . incorporate ( this ) ; dcnl } dcnl } dcnl
if ( !add constraints to c ( this . invocation arguments , c , method , this . inference kind , false , invocation site ) )
private boolean add constraints to c ( expression [ ] exprs , set < constraint formula > c , method binding method , int inference kind for method , boolean interleaved , invocation site site )
if ( !add constraints to c one expr ( exprs [ i ] , c , fsi , subst f , method , interleaved ) )
private boolean add constraints to c one expr ( expression expri , set < constraint formula > c , type binding fsi , type binding subst f , method binding method , boolean interleaved )
subst f = scope . substitute ( get result substitution ( this . b3 ) , subst f ) ;
if ( !add constraints to c one expr ( result expression , c , r . original ( ) , r , method , true ) )
return inner context . add constraints to c ( arguments , c , inner method . generic method ( ) , inner context . inference kind , interleaved , invocation ) ;
return this . add constraints to c ( arguments , c , inner method . generic method ( ) , applicability kind , interleaved , invocation ) ;
url url = get default javadoc location ( install location ) ;
i path source root path = path . empty ; dcnl i path path = new path ( install location . get absolute path ( ) ) . append ( "src . zip" ) ; / / $non - nls - 1$ dcnl file lib = path . to file ( ) ; dcnl if ( lib . exists ( ) & & lib . is file ( ) ) { dcnl source root path = get default system library source ( lib ) ; / / to attach source if available dcnl }
source root path , get default package root path ( ) , dcnl get default javadoc location ( install location ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
import java . net . uri syntax exception ;
import org . eclipse . core . runtime . uri util ;
} catch ( io exception | uri syntax exception e ) {
private void add entry ( list < string > junit entries , final j unit runtime classpath entry entry ) throws io exception , malformed url exception , uri syntax exception {
private string entry string ( final j unit runtime classpath entry entry ) throws io exception , malformed url exception , uri syntax exception {
private string local url ( j unit runtime classpath entry jar ) throws io exception , malformed url exception , uri syntax exception {
if ( !inference context . compute b3 ( invocation , this . right , method ) )
/ * * not per jls : inbox for emulation of how javac passes type bounds from inner to outer * / dcnl private bound set inner inbox ; dcnl / * * not per jls : signal when current is ready to directly merge all bounds from inner . * / dcnl private boolean directly accepting inner bounds = false ;
/ * * perform steps from jls 18 . 5 . 2 . needed for computing the bound set b3 . * / dcnl boolean compute b3 ( invocation site invocation site , type binding target type , method binding method ) dcnl throws inference failure exception dcnl { dcnl boolean result = constraint expression formula . infer poly invocation type ( this , invocation site , target type , method ) ; dcnl if ( result ) { dcnl merge inner bounds ( ) ; dcnl if ( this . b3 = = null ) dcnl this . b3 = this . current bounds . copy ( ) ; dcnl } dcnl return result ; dcnl } dcnl
if ( !compute b3 ( invocation site , expected type , method ) ) {
} else { dcnl merge inner bounds ( ) ; dcnl this . b3 = this . current bounds . copy ( ) ;
push bounds to outer ( ) ; dcnl this . directly accepting inner bounds = true ; dcnl
if ( !add constraints to c ( this . invocation arguments , c , method , this . inference kind , invocation site ) )
/ / - - - not per jls : emulate how javac passes type bounds from inner to outer : - - - dcnl / * * not per jls : push current bounds to outer inference if outer is ready for it . * / dcnl private void push bounds to outer ( ) { dcnl inference context18 outer = this . outer context ; dcnl if ( outer ! = null & & outer . step completed > = applicability inferred ) { dcnl if ( outer . directly accepting inner bounds ) { dcnl outer . current bounds . add bounds ( this . current bounds , this . environment ) ; dcnl } else if ( outer . inner inbox = = null ) { dcnl outer . inner inbox = this . current bounds . copy ( ) ; dcnl } else { dcnl outer . inner inbox . add bounds ( this . current bounds , this . environment ) ; dcnl } dcnl } dcnl } dcnl / * * not jls : merge pending bounds of inner inference into current . * / dcnl private void merge inner bounds ( ) { dcnl if ( this . inner inbox ! = null ) { dcnl this . current bounds . add bounds ( this . inner inbox , this . environment ) ; dcnl this . inner inbox = null ; dcnl } dcnl } dcnl dcnl interface inference operation { dcnl boolean perform ( ) throws inference failure exception ; dcnl } dcnl / * * not per jls : if operation succeeds merge new bounds from inner into current . * / dcnl private boolean collecting inner bounds ( inference operation operation ) throws inference failure exception { dcnl boolean result = operation . perform ( ) ; dcnl if ( result ) dcnl merge inner bounds ( ) ; dcnl else dcnl this . inner inbox = null ; dcnl return result ; dcnl } dcnl / / - - - dcnl
constraint formula expr constraint = new constraint expression formula ( functional expr , target type , reduction result . compatible , argument constraints are soft ) ; dcnl if ( collecting inner bounds ( ( ) - > expr constraint . input variables ( this ) . is empty ( ) ) ) { / / input variable would signal : not ready for inference dcnl if ( !collecting inner bounds ( ( ) - > reduce and incorporate ( expr constraint ) ) )
constraint formula exc constraint = new constraint exception formula ( functional expr , target type ) ; / / ? ? dcnl if ( !collecting inner bounds ( ( ) - > reduce and incorporate ( exc constraint ) ) )
private boolean add constraints to c ( expression [ ] exprs , set < constraint formula > c , method binding method , int inference kind for method , invocation site site )
if ( !add constraints to c one expr ( exprs [ i ] , c , fsi , subst f , method ) )
private boolean add constraints to c one expr ( expression expri , set < constraint formula > c , type binding fsi , type binding subst f , method binding method )
if ( !add constraints to c one expr ( result expression , c , r . original ( ) , r , method ) )
if ( inner context ! = null ) {
if ( !inner context . compute b3 ( invocation , subst f , shallow method ) )
return inner context . add constraints to c ( arguments , c , inner method . generic method ( ) , inner context . inference kind , invocation ) ;
return this . add constraints to c ( arguments , c , inner method . generic method ( ) , applicability kind , invocation ) ;
return add constraints to c one expr ( ce . value if true , c , fsi , subst f , method ) dcnl & & add constraints to c one expr ( ce . value if false , c , fsi , subst f , method ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . debug . tests . connectors . multiple connections test ;
import junit . framework . test ; dcnl import junit . framework . test suite ; dcnl
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* ibm - initial api and implementation dcnl * google inc - add support for accepting multiple connections
# copyright ( c ) 2000 , 2016 ibm corporation and others .
# google inc - add support for accepting multiple connections
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* google inc - add support for accepting multiple connections
import java . io . input stream ;
import java . net . socket ;
/ / for attaching connector dcnl private socket f socket ;
private input stream f input ; dcnl dcnl private output stream f output ; dcnl dcnl socket connection ( socket socket , input stream in , output stream out ) { dcnl f socket = socket ; dcnl f input = in ; dcnl f output = out ;
if ( f socket = = null )
f socket . close ( ) ; dcnl f socket = null ;
return f socket ! = null ;
stream = new data input stream ( f input ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* google inc - add support for accepting multiple connections
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* google inc - add support for accepting multiple connections
socket socket ;
socket = f server socket . accept ( ) ;
input stream input = socket . get input stream ( ) ; dcnl output stream output = socket . get output stream ( ) ; dcnl perform handshake ( input , output , handshake timeout ) ; dcnl return new socket connection ( socket , input , output ) ;
final socket connection [ ] result = new socket connection [ 1 ] ;
socket socket = new socket ( host , port ) ; dcnl input stream input = socket . get input stream ( ) ; dcnl output stream output = socket . get output stream ( ) ; dcnl perform handshake ( input , output , handshake timeout ) ; dcnl result [ 0 ] = new socket connection ( socket , input , output ) ;
* copyright ( c ) 2007 , 2016 ibm corporation and others .
* google inc - add support for accepting multiple connections
/ / retain default behaviour to accept 1 connection only dcnl int connection limit = 1 ; dcnl if ( arguments . contains key ( "connection limit" ) ) { / / $non - nls - 1$ dcnl connection limit = integer . value of ( arguments . get ( "connection limit" ) ) ; / / $non - nls - 1$ dcnl } dcnl
socket listen connector process process = new socket listen connector process ( launch , port number string , connection limit ) ;
* copyright ( c ) 2007 , 2016 ibm corporation and others .
* google inc - add support for accepting multiple connections
import java . io . print writer ; dcnl import java . io . string writer ;
* a process that represents a vm listening connector that is waiting for some vm ( s ) to remotely connect . allows the user to see the status of the dcnl * connection and terminate it . if a successful connection occurs , the debug target is added to the launch and , if a configured number of connections dcnl * have been reached , then this process is removed . dcnl *
/ * * dcnl * the number of incoming connections to accept ( 0 = unlimited ) . setting to 1 mimics previous behaviour . dcnl * / dcnl private int f connection limit ; dcnl / * * the number of connections accepted so far . * / dcnl private int f accepted = 0 ;
/ * * time when this instance was created ( milliseconds ) * / dcnl private long f start time ; dcnl
* @ param connection limit the number of incoming connections to accept ( 0 = unlimited )
public socket listen connector process ( i launch launch , string port , int connection limit ) {
f connection limit = connection limit ;
f start time = system . current time millis ( ) ; dcnl f accepted = 0 ; dcnl / / if the connector does not support multiple connections , accept a single connection dcnl try { dcnl if ( !connector . supports multiple connections ( ) ) { dcnl f connection limit = 1 ; dcnl } dcnl } dcnl catch ( io exception | illegal connector arguments exception ex ) { dcnl f connection limit = 1 ; dcnl } dcnl f launch . add process ( this ) ; dcnl f wait for connection job = new wait for connection job ( connector , arguments ) ;
f wait for connection job . set system ( true ) ;
if ( event . get result ( ) . is ok ( ) & & continue listening ( ) ) { dcnl f wait for connection job . schedule ( ) ; dcnl } else {
/ * * dcnl * return true if this connector should continue listening for further connections . dcnl * / dcnl protected boolean continue listening ( ) { dcnl return !is terminated ( ) & & ( f connection limit < = 0 | | f connection limit - f accepted > 0 ) ; dcnl } dcnl
f launch . remove process ( this ) ;
* return the time since this connector was started . dcnl * / dcnl private string get running time ( ) { dcnl long total = system . current time millis ( ) - f start time ; dcnl string writer result = new string writer ( ) ; dcnl print writer writer = new print writer ( result ) ; dcnl int minutes = ( int ) ( total / 60 / 1000 ) ; dcnl int seconds = ( int ) ( total / 1000 ) % 60 ; dcnl int milliseconds = ( int ) ( total / 1000 ) % 1000 ; dcnl writer . printf ( " % 02d : % 02d . % 03d" , minutes , seconds , milliseconds ) . close ( ) ; / / $non - nls - 1$ dcnl return result . to string ( ) ; dcnl } dcnl dcnl / * * dcnl * job that waits for incoming vm connections . when a remote vm connection is accepted , a debug target is created .
public wait for connection job ( listening connector connector , map < string , connector . argument > arguments ) {
f accepted + + ;
public static final string img objs module = name prefix + "module obj . gif" ; / / $non - nls - 1$
import org . eclipse . jdt . core . i module description ;
if ( parent instanceof i parent & & ! ( parent instanceof i module description ) ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . core . i module description ;
if ( get provide members ( ) & & element instanceof i source reference & & element instanceof i parent dcnl & & ! ( element instanceof i module description ) ) {
"incorrectly formatted option : - - add - exports mod . one = mod . two , mod . three \ n" ,
/ / tests names = new string [ ] { "test009" } ;
string file content = "module my . mod { } \ n" ;
string file content = dcnl "module my . mod { \ n" +
string file content = dcnl "module my . mod { \ n" +
string file content = dcnl "module my . mod { \ n" +
import org . eclipse . jdt . internal . compiler . lookup . module binding ; dcnl import org . eclipse . jdt . internal . compiler . lookup . scope ;
public class completion on module reference extends module reference {
module reference reference = create assist module reference ( index ) ;
module reference reference = create assist module reference ( index ) ;
reference . declaration source end = ( int ) reference . source positions [ reference . tokens . length - 1 ] ;
import org . eclipse . jdt . core . i module description ;
private static string [ ] emptry string array = new string [ 0 ] ; dcnl
exports . add ( new local package export impl ( pack , emptry string array ) ) ;
required . add ( new local module reference impl ( string , false ) ) ;
class local module reference impl extends module requirement {
local module reference impl ( string name , boolean is public ) { dcnl super ( null , name ) ; dcnl this . name = name ;
public boolean equals ( object o ) { dcnl if ( ! ( o instanceof local module reference impl ) ) { dcnl return false ; dcnl } dcnl return this . name . equals ( ( ( local module reference impl ) o ) . name ) ; dcnl }
class local package export impl extends package export {
super ( null , pkg name ) ;
import org . eclipse . jdt . internal . compiler . lookup . type constants ;
source file unit = new source file ( ( i file ) resource , md , true ) ; dcnl this . source files . add ( unit ) ;
/ / tests names = new string [ ] { "test010" } ;
import org . eclipse . jdt . internal . compiler . env . i module ;
i module module = null ;
public void accept module ( i module mod ) { dcnl / / todo : if module was already part of another source folder , flag an error ? dcnl this . module = mod ; dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . debug . core . model . i trigger point ;
import org . eclipse . core . resources . i workspace description ;
i package fragment root [ ] roots = compute package fragment roots ( resolved classpath , false , null / * no reverse map * / ) ; dcnl info . set children ( roots ) ; dcnl i module description module = null ; dcnl for ( i package fragment root root : roots ) { dcnl if ( root . get kind ( ) ! = i package fragment root . k source ) dcnl continue ; dcnl module = root . get module description ( ) ; dcnl if ( module ! = null ) { dcnl java model manager . get module path manager ( ) . add entry ( module , this ) ; dcnl break ; dcnl } dcnl }
if ( updated argument type ! = null & & updated argument type . kind ( ) ! = binding . poly type ) {
* jean - marie henaff < jmhenaff @ google . com > ( google ) - bug 481555
* copyright ( c ) 2000 , 2016 ibm corporation and others .
defaults to = "org . eclipse . ui . workbench . hover background"
sub monitor . split ( 5 ) ; / / give feedback to the user that something is happening
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
import org . eclipse . core . runtime . sub monitor ;
delete index files ( known paths , null ) ;
/ * * dcnl * use { @ link #delete index files ( i progress monitor ) } dcnl * / dcnl public final void delete index files ( ) { dcnl delete index files ( null ) ; dcnl } dcnl public void delete index files ( i progress monitor monitor ) {
delete index files ( null , monitor ) ;
private void delete index files ( simple set paths to keep , i progress monitor monitor ) {
sub monitor sub monitor = sub monitor . convert ( monitor , indexes files . length ) ;
/ / it is permitted for the to clause of an exports or opens statement to dcnl / / specify a module which is not observable
import org . eclipse . jdt . internal . compiler . util . hashtable of object ;
hashtable of object modules = new hashtable of object ( this . targets . length ) ;
* copyright ( c ) 2007 , 2016 ibm corporation and others .
import org . eclipse . core . resources . i container ;
if ( !is synchronized excluding linked resources ( resource ) ) {
expected problem attributes . put ( " null annotation at qualifying type" , new problem attributes ( categorized problem . cat syntax ) ) ;
expected problem attributes . put ( " type annotation at qualified name" , new problem attributes ( categorized problem . cat syntax ) ) ;
expected problem attributes . put ( " null annotation at qualifying type" , skip ) ;
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" ^ ^ ^ ^ ^ ^ \ n" + dcnl " marker cannot be resolved to a type \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "3 . error in x . java ( at line 10 ) \ n" + dcnl " object p = ( @ marker java . lang . @ readonly string & i & j ) ( ) - > { } ; \ n" +
"4 . error in x . java ( at line 10 ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" ^ ^ ^ ^ ^ ^ \ n" + dcnl " marker cannot be resolved to a type \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "6 . error in x . java ( at line 4 ) \ n" + dcnl " object q = ( @ marker java . @ marker util . @ marker list < @ marker string > [ ] ) null ; \ n" +
"7 . error in x . java ( at line 4 ) \ n" +
"8 . error in x . java ( at line 4 ) \ n" +
"9 . error in x . java ( at line 5 ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
"10 . error in x . java ( at line 5 ) \ n" +
"11 . error in x . java ( at line 5 ) \ n" + dcnl " object r = ( @ marker java . @ marker util . @ marker map < @ marker string , @ marker string > . @ marker entry @ marker [ ] ) null ; \ n" + dcnl " ^ ^ ^ ^ ^ ^ \ n" + dcnl " marker cannot be resolved to a type \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "12 . error in x . java ( at line 5 ) \ n" +
"13 . error in x . java ( at line 5 ) \ n" + dcnl " object r = ( @ marker java . @ marker util . @ marker map < @ marker string , @ marker string > . @ marker entry @ marker [ ] ) null ; \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " type annotations are not allowed on type names used to access static members \ n" +
"14 . error in x . java ( at line 5 ) \ n" +
"15 . error in x . java ( at line 5 ) \ n" +
"16 . error in x . java ( at line 5 ) \ n" +
"17 . error in x . java ( at line 5 ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
"2 . error in x . java ( at line 4 ) \ n" + dcnl " object o1 = ( @ marker @ annot java . util . list < string > ) null ; / / 1 . wrong . \ n" + dcnl " ^ ^ ^ ^ ^ ^ \ n" + dcnl " illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "3 . error in x . java ( at line 5 ) \ n" +
"4 . error in x . java ( at line 6 ) \ n" +
" ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "5 . error in x . java ( at line 6 ) \ n" + dcnl " object o3 = ( @ marker @ annot java . util . list < string > [ ] ) null ; / / 3 . wrong . \ n" + dcnl " ^ ^ ^ ^ ^ ^ \ n" + dcnl " illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" illegally placed annotation : type annotations must directly precede the simple name of the type they are meant to affect ( or the [ ] for arrays ) \ n" +
" the nullness annotation \ ' non null \ ' is not applicable at this location , it must be placed directly before the nested type name . \ n" +
" the nullness annotation \ ' non null \ ' is not applicable at this location , it must be placed directly before the nested type name . \ n" +
" the nullness annotation \ ' non null \ ' is not applicable at this location , it must be placed directly before the nested type name . \ n" +
dcnl / * * @ since 3 . 13 * / dcnl int type annotation at qualified name = internal + syntax + 1060 ; dcnl dcnl / * * @ since 3 . 13 * / dcnl int null annotation at qualifying type = internal + syntax + 1061 ;
if ( is annotation target allowed ( repeating annotation , scope , container annotation type , repeating annotation . recipient . kind ( ) ) ! = annotation target allowed . yes ) {
public enum annotation target allowed { dcnl yes , type annotation on qualified name , no ; dcnl } dcnl dcnl private static annotation target allowed is annotation target allowed ( binding recipient , block scope scope , type binding annotation type , int kind , long meta tag bits ) {
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ;
return annotation target allowed . yes ; dcnl } else { dcnl return annotation target allowed . type annotation on qualified name ;
return annotation target allowed . yes ;
return annotation target allowed . yes ; dcnl } else { dcnl return annotation target allowed . type annotation on qualified name ;
return annotation target allowed . yes ;
return annotation target allowed . yes ; dcnl } else { dcnl return annotation target allowed . type annotation on qualified name ;
return annotation target allowed . yes ;
return annotation target allowed . yes ; dcnl } else { dcnl return annotation target allowed . type annotation on qualified name ;
return annotation target allowed . yes ;
return annotation target allowed . no ;
return is annotation target allowed ( recipient , scope , annotation type , recipient . kind ( ) , meta tag bits ) = = annotation target allowed . yes ;
static annotation target allowed is annotation target allowed ( annotation annotation , block scope scope , type binding annotation type , int kind ) {
return annotation target allowed . yes ;
annotation target allowed annotation target allowed = is annotation target allowed ( annotation , scope , annotation type , kind ) ; dcnl if ( annotation target allowed ! = annotation target allowed . yes ) { dcnl if ( annotation target allowed = = annotation target allowed . type annotation on qualified name ) { dcnl scope . problem reporter ( ) . type annotation at qualified name ( annotation ) ; dcnl } else {
}
public void null annotation at qualifying type ( annotation annotation ) { dcnl string [ ] arguments = new string [ ] { dcnl string . value of ( annotation . resolved type . readable name ( ) ) dcnl } ; dcnl string [ ] short arguments = new string [ ] { dcnl string . value of ( annotation . resolved type . short readable name ( ) ) dcnl } ; dcnl int severity = problem severities . error | problem severities . fatal ; dcnl handle ( i problem . null annotation at qualifying type , dcnl arguments , short arguments , dcnl severity , dcnl annotation . source start , annotation . source end ) ; dcnl }
import org . eclipse . core . runtime . core exception ;
} else if ( ast node instanceof completion on single type reference ) { dcnl completion on single type reference ( ast node , ast node parent , qualified binding , scope ) ; dcnl } else if ( ast node instanceof completion on qualified name reference ) { dcnl completion on qualified name reference ( ast node , enclosing node , qualified binding , scope , inside type annotation ) ;
type reference [ ] uses = this . module declaration . uses ; dcnl if ( uses ! = null ) { dcnl for ( int i = 0 , l = uses . length ; i < l ; + + i ) { dcnl type reference uses reference = uses [ i ] ; dcnl if ( uses reference instanceof completion on uses single type reference | | dcnl uses reference instanceof completion on uses qualified type reference ) { dcnl this . lookup environment . build type bindings ( parsed unit , null ) ; dcnl if ( ( this . unit scope = parsed unit . scope ) ! = null ) { dcnl context accepted = true ; dcnl build context ( uses reference , null , parsed unit , null , null ) ; dcnl find type references ( uses reference , true ) ; dcnl debug printf ( ) ; dcnl return ; dcnl } dcnl } dcnl } dcnl } dcnl
if ( !source type . is module ( ) ) dcnl create type proposal ( dcnl source type , dcnl type name , dcnl i access rule . k accessible , dcnl type name , dcnl relevance , dcnl null , dcnl null , dcnl null , dcnl false ) ;
if ( import bindings = = null ) return ;
private boolean attach orphan in module info ( recovered type type , type reference orphan ) { dcnl if ( type instanceof recovered module ) { dcnl recovered module r module = ( recovered module ) type ; dcnl if ( is in uses statement ( ) ) { dcnl r module . add uses ( orphan , 0 ) ; dcnl return true ; dcnl } dcnl } dcnl dcnl return false ; dcnl }
if ( attach orphan in module info ( recovered type , ( type reference ) orphan ) ) return ; dcnl
if ( ( index = this . index of assist identifier ( ) ) < = - 1 ) return false ; dcnl if ( check module info keyword ( module , index ) ) return true ;
private boolean check module info keyword ( recovered module module , int index ) { dcnl module keyword keyword = get keyword ( ) ; dcnl if ( keyword = = module keyword . not a keyword ) return false ; dcnl dcnl int length = this . identifier length stack [ this . identifier length ptr ] ; dcnl int ptr = this . identifier ptr - length + index + 1 ; dcnl dcnl char [ ] ident = this . identifier stack [ ptr ] ; dcnl long pos = this . identifier position stack [ ptr ] ; dcnl char [ ] [ ] keywords = get module keywords ( keyword ) ; dcnl module . add ( new completion on keyword module info ( ident , pos , keywords ) , 0 ) ; dcnl return true ;
} else if ( token = = token nameto ) {
} else if ( token = = token namewith ) {
return is in uses statement ( ) ? new completion on uses qualified type reference ( previous identifiers , assist name , positions ) : dcnl new completion on qualified type reference (
return is in uses statement ( ) ? new completion on uses single type reference ( assist name , position ) : dcnl new completion on single type reference ( assist name , position ) ;
protected boolean is in uses statement ( ) {
f v ms = new array list < > ( 10 ) ;
ivm install removed vm = null ;
if ( f v ms . get ( i ) . get id ( ) . equals ( id ) ) { dcnl removed vm = f v ms . remove ( i ) ; dcnl break ;
scope . problem reporter ( ) . cannot implement incompatible nullness ( scope . reference context ( ) , current method , inherited method , use type annotations ) ;
scope . problem reporter ( ) . cannot implement incompatible nullness ( scope . reference context ( ) , current method , inherited method , use type annotations ) ;
scope . problem reporter ( ) . cannot implement incompatible nullness ( scope . reference context ( ) , current method , inherited method , false ) ;
scope . problem reporter ( ) . cannot implement incompatible nullness ( scope . reference context ( ) , current method , inherited method , false ) ;
public void cannot implement incompatible nullness ( reference context context , method binding current method , method binding inherited method , boolean show return ) {
import java . util . objects ;
public void reset ( ) {
public void reset ( ) {
thread thread ; dcnl synchronized ( this ) { dcnl thread = this . processing thread ; dcnl } dcnl dcnl if ( thread ! = null ) {
assert equals ( "no method return value" , var in main2 . get name ( ) ) ;
public static final string img objs method result disabled = "img objs method result disabled" ; / / $non - nls - 1$
public final boolean has result ;
public jdi return value variable ( string name , i java value value , boolean has result ) {
variables . add ( 0 , new jdi return value variable ( name , jdi value . create value ( get java debug target ( ) , step result . f value ) , true ) ) ;
variables . add ( 0 , new jdi return value variable ( name , jdi value . create value ( get java debug target ( ) , step result . f value ) , true ) ) ;
public synchronized ivm install create vm install ( string id ) throws illegal argument exception {
# copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2010 , 2016 ibm corporation and others .
import org . eclipse . jdt . core . i type ; dcnl import org . eclipse . jdt . core . java model exception ;
* java element implementation hyperlink detector for types and methods .
* copyright ( c ) 2009 , 2016 ibm corporation and others .
import org . eclipse . jdt . core . i java element ;
private final i java element f element ;
* creates a new java element implementation hyperlink for types and methods .
* @ param java element the element ( type or method ) to open
* element
public java element implementation hyperlink ( i region region , selection dispatch action open action , i java element java element , boolean qualify , i editor part editor ) {
assert . is not null ( java element ) ; dcnl assert . is true ( java element instanceof i type | | java element instanceof i method ) ;
f element = java element ;
string element label = java element labels . get element label ( f element , java element labels . all fully qualified ) ; dcnl return messages . format ( java editor messages . java element implementation hyperlink hyperlink text qualified , new object [ ] { element label } ) ;
* opens the given implementation hyperlink for types and methods .
* if there's only one implementor that hyperlink is opened in the editor , otherwise the quick dcnl * hierarchy is opened .
import java . util . objects ;
import java . util . hash set ;
import java . util . regex . matcher ; dcnl import java . util . regex . pattern ;
dcnl problem log problem log = new problem log ( computed problem log ) ;
if ( problem log . same as ( alternate platform independant expected logs [ i ] ) )
import java . util . stream . * ;
private static string sort lines ( string to split ) { dcnl return arrays . stream ( to split . split ( " \ n" ) ) . sorted ( ) . collect ( collectors . joining ( " \ n" ) ) ; dcnl } dcnl protected void assert search results ( string message , string expected string , object collector , boolean assertion ) { dcnl string expected = sort lines ( expected string ) ; dcnl string actual = sort lines ( collector . to string ( ) ) ;
assert elements equal ( message , expected , elements , show resolved info , false ) ; dcnl } dcnl protected void assert elements equal ( string message , string expected , i java element [ ] elements , boolean show resolved info , boolean sorted ) {
assert sorted results (
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* stefan xenos < sxenos @ gmail . com > ( google ) - bug 501283 - lots of hash collisions during indexing
import java . util . arrays ; dcnl
lookup environment environment = scope . environment ( ) ; dcnl if ( ( original method . tag bits & tag bits . is nullness known ) = = 0 ) { dcnl / / ensure nullness of original method is known ( but we are not interested in reporting problems against original method ) dcnl new implicit null annotation verifier ( environment , environment . global options . inherit null annotations ) dcnl . check implicit null annotations ( original method , null / * src method * / , false , scope ) ; dcnl }
copyright ( c ) 2012 , 2016 eclipse foundation and others .
copyright ( c ) 2012 , 2016 eclipse foundation and others .
private void consume provide interface ( ) { dcnl / / do nothing dcnl }
case 119 : if ( debug ) { system . out . println ( " provides statement : : = provides interface with clause . . . " ) ; } / / $non - nls - 1$
case 120 : if ( debug ) { system . out . println ( " provides interface : : = provides name" ) ; } / / $non - nls - 1$ dcnl consume provide interface ( ) ; dcnl break ; dcnl dcnl case 121 : if ( debug ) { system . out . println ( " with clause : : = with name" ) ; } / / $non - nls - 1$
case 122 : if ( debug ) { system . out . println ( " reduce imports : : = " ) ; } / / $non - nls - 1$
case 123 : if ( debug ) { system . out . println ( " enter compilation unit : : = " ) ; } / / $non - nls - 1$
case 139 : if ( debug ) { system . out . println ( " catch header : : = catch lparen catch formal parameter rparen" ) ; } / / $non - nls - 1$
case 141 : if ( debug ) { system . out . println ( " import declarations : : = import declarations . . . " ) ; } / / $non - nls - 1$
case 143 : if ( debug ) { system . out . println ( " type declarations : : = type declarations type declaration" ) ; } / / $non - nls - 1$
case 144 : if ( debug ) { system . out . println ( " package declaration : : = package declaration name semicolon" ) ; } / / $non - nls - 1$
case 145 : if ( debug ) { system . out . println ( " package declaration name : : = modifiers package . . . " ) ; } / / $non - nls - 1$
case 146 : if ( debug ) { system . out . println ( " package declaration name : : = package comment package name" ) ; } / / $non - nls - 1$
case 147 : if ( debug ) { system . out . println ( " package comment : : = " ) ; } / / $non - nls - 1$
case 152 : if ( debug ) { system . out . println ( " single type import declaration : : = . . . " ) ; } / / $non - nls - 1$
case 153 : if ( debug ) { system . out . println ( " single type import declaration name : : = import name . . . " ) ; } / / $non - nls - 1$
case 154 : if ( debug ) { system . out . println ( " type import on demand declaration : : = . . . " ) ; } / / $non - nls - 1$
case 155 : if ( debug ) { system . out . println ( " type import on demand declaration name : : = import name dot . . . " ) ; } / / $non - nls - 1$
case 158 : if ( debug ) { system . out . println ( " type declaration : : = semicolon" ) ; } / / $non - nls - 1$
case 162 : if ( debug ) { system . out . println ( " modifiers : : = modifiers modifier" ) ; } / / $non - nls - 1$
case 174 : if ( debug ) { system . out . println ( " modifier : : = annotation" ) ; } / / $non - nls - 1$
case 175 : if ( debug ) { system . out . println ( " class declaration : : = class header class body" ) ; } / / $non - nls - 1$
case 176 : if ( debug ) { system . out . println ( " class header : : = class header name class header extendsopt . . . " ) ; } / / $non - nls - 1$
case 177 : if ( debug ) { system . out . println ( " class header name : : = class header name1 type parameters" ) ; } / / $non - nls - 1$
case 179 : if ( debug ) { system . out . println ( " class header name1 : : = modifiersopt class identifier" ) ; } / / $non - nls - 1$
case 180 : if ( debug ) { system . out . println ( " class header extends : : = extends class type" ) ; } / / $non - nls - 1$
case 181 : if ( debug ) { system . out . println ( " class header implements : : = implements interface type list" ) ; } / / $non - nls - 1$
case 183 : if ( debug ) { system . out . println ( " interface type list : : = interface type list comma . . . " ) ; } / / $non - nls - 1$
case 184 : if ( debug ) { system . out . println ( " interface type : : = class or interface type" ) ; } / / $non - nls - 1$
case 187 : if ( debug ) { system . out . println ( " class body declarations : : = class body declarations . . . " ) ; } / / $non - nls - 1$
case 191 : if ( debug ) { system . out . println ( " class body declaration : : = diet nested method . . . " ) ; } / / $non - nls - 1$
case 192 : if ( debug ) { system . out . println ( " diet : : = " ) ; } / / $non - nls - 1$
case 193 : if ( debug ) { system . out . println ( " initializer : : = diet nested method create initializer . . . " ) ; } / / $non - nls - 1$
case 194 : if ( debug ) { system . out . println ( " create initializer : : = " ) ; } / / $non - nls - 1$
case 201 : if ( debug ) { system . out . println ( " class member declaration : : = semicolon" ) ; } / / $non - nls - 1$
case 204 : if ( debug ) { system . out . println ( " field declaration : : = modifiersopt type . . . " ) ; } / / $non - nls - 1$
case 206 : if ( debug ) { system . out . println ( " variable declarators : : = variable declarators comma . . . " ) ; } / / $non - nls - 1$
case 209 : if ( debug ) { system . out . println ( " enter variable : : = " ) ; } / / $non - nls - 1$
case 210 : if ( debug ) { system . out . println ( " exit variable with initialization : : = " ) ; } / / $non - nls - 1$
case 211 : if ( debug ) { system . out . println ( " exit variable without initialization : : = " ) ; } / / $non - nls - 1$
case 212 : if ( debug ) { system . out . println ( " force no diet : : = " ) ; } / / $non - nls - 1$
case 213 : if ( debug ) { system . out . println ( " restore diet : : = " ) ; } / / $non - nls - 1$
case 218 : if ( debug ) { system . out . println ( " method declaration : : = method header method body" ) ; } / / $non - nls - 1$
case 219 : if ( debug ) { system . out . println ( " method declaration : : = default method header method body" ) ; } / / $non - nls - 1$
case 220 : if ( debug ) { system . out . println ( " abstract method declaration : : = method header semicolon" ) ; } / / $non - nls - 1$
case 221 : if ( debug ) { system . out . println ( " method header : : = method header name formal parameter listopt" ) ; } / / $non - nls - 1$
case 222 : if ( debug ) { system . out . println ( " default method header : : = default method header name . . . " ) ; } / / $non - nls - 1$
case 223 : if ( debug ) { system . out . println ( " method header name : : = modifiersopt type parameters type . . . " ) ; } / / $non - nls - 1$
case 224 : if ( debug ) { system . out . println ( " method header name : : = modifiersopt type identifier lparen" ) ; } / / $non - nls - 1$
case 225 : if ( debug ) { system . out . println ( " default method header name : : = modifiers with default . . . " ) ; } / / $non - nls - 1$
case 226 : if ( debug ) { system . out . println ( " default method header name : : = modifiers with default type . . . " ) ; } / / $non - nls - 1$
case 227 : if ( debug ) { system . out . println ( " modifiers with default : : = modifiersopt default . . . " ) ; } / / $non - nls - 1$
case 228 : if ( debug ) { system . out . println ( " method header right paren : : = rparen" ) ; } / / $non - nls - 1$
case 229 : if ( debug ) { system . out . println ( " method header extended dims : : = dimsopt" ) ; } / / $non - nls - 1$
case 230 : if ( debug ) { system . out . println ( " method header throws clause : : = throws class type list" ) ; } / / $non - nls - 1$
case 231 : if ( debug ) { system . out . println ( " constructor header : : = constructor header name . . . " ) ; } / / $non - nls - 1$
case 232 : if ( debug ) { system . out . println ( " constructor header name : : = modifiersopt type parameters . . . " ) ; } / / $non - nls - 1$
case 233 : if ( debug ) { system . out . println ( " constructor header name : : = modifiersopt identifier lparen" ) ; } / / $non - nls - 1$
case 235 : if ( debug ) { system . out . println ( " formal parameter list : : = formal parameter list comma . . . " ) ; } / / $non - nls - 1$
case 236 : if ( debug ) { system . out . println ( " formal parameter : : = modifiersopt type . . . " ) ; } / / $non - nls - 1$
case 237 : if ( debug ) { system . out . println ( " formal parameter : : = modifiersopt type . . . " ) ; } / / $non - nls - 1$
case 238 : if ( debug ) { system . out . println ( " formal parameter : : = modifiersopt type at308 dotdotdot . . . " ) ; } / / $non - nls - 1$
case 239 : if ( debug ) { system . out . println ( " catch formal parameter : : = modifiersopt catch type . . . " ) ; } / / $non - nls - 1$
case 240 : if ( debug ) { system . out . println ( " catch type : : = union type" ) ; } / / $non - nls - 1$
case 241 : if ( debug ) { system . out . println ( " union type : : = type" ) ; } / / $non - nls - 1$
case 242 : if ( debug ) { system . out . println ( " union type : : = union type or type" ) ; } / / $non - nls - 1$
case 244 : if ( debug ) { system . out . println ( " class type list : : = class type list comma class type elt" ) ; } / / $non - nls - 1$
case 245 : if ( debug ) { system . out . println ( " class type elt : : = class type" ) ; } / / $non - nls - 1$
case 246 : if ( debug ) { system . out . println ( " method body : : = nested method lbrace block statementsopt . . . " ) ; } / / $non - nls - 1$
case 247 : if ( debug ) { system . out . println ( " nested method : : = " ) ; } / / $non - nls - 1$
case 248 : if ( debug ) { system . out . println ( " static initializer : : = static only block" ) ; } / / $non - nls - 1$
case 249 : if ( debug ) { system . out . println ( " static only : : = static" ) ; } / / $non - nls - 1$
case 250 : if ( debug ) { system . out . println ( " constructor declaration : : = constructor header method body" ) ; } / / $non - nls - 1$
case 251 : if ( debug ) { system . out . println ( " constructor declaration : : = constructor header semicolon" ) ; } / / $non - nls - 1$
case 252 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = this lparen . . . " ) ; } / / $non - nls - 1$
case 253 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = only type arguments this" ) ; } / / $non - nls - 1$
case 254 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = super lparen . . . " ) ; } / / $non - nls - 1$
case 255 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = only type arguments . . . " ) ; } / / $non - nls - 1$
case 256 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = primary dot super . . . " ) ; } / / $non - nls - 1$
case 257 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = primary dot . . . " ) ; } / / $non - nls - 1$
case 258 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = name dot super lparen" ) ; } / / $non - nls - 1$
case 259 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = name dot . . . " ) ; } / / $non - nls - 1$
case 260 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = primary dot this . . . " ) ; } / / $non - nls - 1$
case 261 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = primary dot . . . " ) ; } / / $non - nls - 1$
case 262 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = name dot this lparen" ) ; } / / $non - nls - 1$
case 263 : if ( debug ) { system . out . println ( " explicit constructor invocation : : = name dot . . . " ) ; } / / $non - nls - 1$
case 264 : if ( debug ) { system . out . println ( " interface declaration : : = interface header interface body" ) ; } / / $non - nls - 1$
case 265 : if ( debug ) { system . out . println ( " interface header : : = interface header name . . . " ) ; } / / $non - nls - 1$
case 266 : if ( debug ) { system . out . println ( " interface header name : : = interface header name1 . . . " ) ; } / / $non - nls - 1$
case 268 : if ( debug ) { system . out . println ( " interface header name1 : : = modifiersopt interface . . . " ) ; } / / $non - nls - 1$
case 269 : if ( debug ) { system . out . println ( " interface header extends : : = extends interface type list" ) ; } / / $non - nls - 1$
case 272 : if ( debug ) { system . out . println ( " interface member declarations : : = . . . " ) ; } / / $non - nls - 1$
case 273 : if ( debug ) { system . out . println ( " interface member declaration : : = semicolon" ) ; } / / $non - nls - 1$
case 275 : if ( debug ) { system . out . println ( " interface member declaration : : = default method header . . . " ) ; } / / $non - nls - 1$
case 276 : if ( debug ) { system . out . println ( " interface member declaration : : = method header method body" ) ; } / / $non - nls - 1$
case 277 : if ( debug ) { system . out . println ( " interface member declaration : : = default method header . . . " ) ; } / / $non - nls - 1$
case 278 : if ( debug ) { system . out . println ( " invalid constructor declaration : : = constructor header . . . " ) ; } / / $non - nls - 1$
case 279 : if ( debug ) { system . out . println ( " invalid constructor declaration : : = constructor header . . . " ) ; } / / $non - nls - 1$
case 290 : if ( debug ) { system . out . println ( " push left brace : : = " ) ; } / / $non - nls - 1$
case 291 : if ( debug ) { system . out . println ( " array initializer : : = lbrace push left brace , opt rbrace" ) ; } / / $non - nls - 1$
case 292 : if ( debug ) { system . out . println ( " array initializer : : = lbrace push left brace . . . " ) ; } / / $non - nls - 1$
case 293 : if ( debug ) { system . out . println ( " array initializer : : = lbrace push left brace . . . " ) ; } / / $non - nls - 1$
case 295 : if ( debug ) { system . out . println ( " variable initializers : : = variable initializers comma . . . " ) ; } / / $non - nls - 1$
case 296 : if ( debug ) { system . out . println ( " block : : = open block lbrace block statementsopt rbrace" ) ; } / / $non - nls - 1$
case 297 : if ( debug ) { system . out . println ( " open block : : = " ) ; } / / $non - nls - 1$
case 298 : if ( debug ) { system . out . println ( " block statements : : = block statement" ) ; } / / $non - nls - 1$
case 299 : if ( debug ) { system . out . println ( " block statements : : = block statements block statement" ) ; } / / $non - nls - 1$
case 306 : if ( debug ) { system . out . println ( " block statement : : = interface declaration" ) ; } / / $non - nls - 1$
case 307 : if ( debug ) { system . out . println ( " block statement : : = annotation type declaration" ) ; } / / $non - nls - 1$
case 308 : if ( debug ) { system . out . println ( " block statement : : = enum declaration" ) ; } / / $non - nls - 1$
case 309 : if ( debug ) { system . out . println ( " local variable declaration statement : : = . . . " ) ; } / / $non - nls - 1$
case 310 : if ( debug ) { system . out . println ( " local variable declaration : : = type push modifiers . . . " ) ; } / / $non - nls - 1$
case 311 : if ( debug ) { system . out . println ( " local variable declaration : : = modifiers type . . . " ) ; } / / $non - nls - 1$
case 312 : if ( debug ) { system . out . println ( " push modifiers : : = " ) ; } / / $non - nls - 1$
case 313 : if ( debug ) { system . out . println ( " push modifiers for header : : = " ) ; } / / $non - nls - 1$
case 314 : if ( debug ) { system . out . println ( " push real modifiers : : = " ) ; } / / $non - nls - 1$
case 341 : if ( debug ) { system . out . println ( " empty statement : : = semicolon" ) ; } / / $non - nls - 1$
case 342 : if ( debug ) { system . out . println ( " labeled statement : : = label colon statement" ) ; } / / $non - nls - 1$
case 343 : if ( debug ) { system . out . println ( " labeled statement no short if : : = label colon . . . " ) ; } / / $non - nls - 1$
case 344 : if ( debug ) { system . out . println ( " label : : = identifier" ) ; } / / $non - nls - 1$
case 345 : if ( debug ) { system . out . println ( " expression statement : : = statement expression semicolon" ) ; } / / $non - nls - 1$
case 354 : if ( debug ) { system . out . println ( " if then statement : : = if lparen expression rparen . . . " ) ; } / / $non - nls - 1$
case 355 : if ( debug ) { system . out . println ( " if then else statement : : = if lparen expression rparen . . . " ) ; } / / $non - nls - 1$
case 356 : if ( debug ) { system . out . println ( " if then else statement no short if : : = if lparen expression . . . " ) ; } / / $non - nls - 1$
case 357 : if ( debug ) { system . out . println ( " switch statement : : = switch lparen expression rparen . . . " ) ; } / / $non - nls - 1$
case 358 : if ( debug ) { system . out . println ( " switch block : : = lbrace rbrace" ) ; } / / $non - nls - 1$
case 361 : if ( debug ) { system . out . println ( " switch block : : = lbrace switch block statements . . . " ) ; } / / $non - nls - 1$
case 363 : if ( debug ) { system . out . println ( " switch block statements : : = switch block statements . . . " ) ; } / / $non - nls - 1$
case 364 : if ( debug ) { system . out . println ( " switch block statement : : = switch labels block statements" ) ; } / / $non - nls - 1$
case 366 : if ( debug ) { system . out . println ( " switch labels : : = switch labels switch label" ) ; } / / $non - nls - 1$
case 367 : if ( debug ) { system . out . println ( " switch label : : = case constant expression colon" ) ; } / / $non - nls - 1$
case 368 : if ( debug ) { system . out . println ( " switch label : : = default colon" ) ; } / / $non - nls - 1$
case 369 : if ( debug ) { system . out . println ( " while statement : : = while lparen expression rparen . . . " ) ; } / / $non - nls - 1$
case 370 : if ( debug ) { system . out . println ( " while statement no short if : : = while lparen expression . . . " ) ; } / / $non - nls - 1$
case 371 : if ( debug ) { system . out . println ( " do statement : : = do statement while lparen expression . . . " ) ; } / / $non - nls - 1$
case 372 : if ( debug ) { system . out . println ( " for statement : : = for lparen for initopt semicolon . . . " ) ; } / / $non - nls - 1$
case 373 : if ( debug ) { system . out . println ( " for statement no short if : : = for lparen for initopt . . . " ) ; } / / $non - nls - 1$
case 374 : if ( debug ) { system . out . println ( " for init : : = statement expression list" ) ; } / / $non - nls - 1$
case 378 : if ( debug ) { system . out . println ( " statement expression list : : = statement expression list . . . " ) ; } / / $non - nls - 1$
case 379 : if ( debug ) { system . out . println ( " assert statement : : = assert expression semicolon" ) ; } / / $non - nls - 1$
case 380 : if ( debug ) { system . out . println ( " assert statement : : = assert expression colon expression" ) ; } / / $non - nls - 1$
case 381 : if ( debug ) { system . out . println ( " break statement : : = break semicolon" ) ; } / / $non - nls - 1$
case 382 : if ( debug ) { system . out . println ( " break statement : : = break identifier semicolon" ) ; } / / $non - nls - 1$
case 383 : if ( debug ) { system . out . println ( " continue statement : : = continue semicolon" ) ; } / / $non - nls - 1$
case 384 : if ( debug ) { system . out . println ( " continue statement : : = continue identifier semicolon" ) ; } / / $non - nls - 1$
case 385 : if ( debug ) { system . out . println ( " return statement : : = return expressionopt semicolon" ) ; } / / $non - nls - 1$
case 386 : if ( debug ) { system . out . println ( " throw statement : : = throw expression semicolon" ) ; } / / $non - nls - 1$
case 387 : if ( debug ) { system . out . println ( " synchronized statement : : = only synchronized lparen . . . " ) ; } / / $non - nls - 1$
case 388 : if ( debug ) { system . out . println ( " only synchronized : : = synchronized" ) ; } / / $non - nls - 1$
case 389 : if ( debug ) { system . out . println ( " try statement : : = try try block catches" ) ; } / / $non - nls - 1$
case 390 : if ( debug ) { system . out . println ( " try statement : : = try try block catchesopt finally" ) ; } / / $non - nls - 1$
case 391 : if ( debug ) { system . out . println ( " try statement with resources : : = try resource specification" ) ; } / / $non - nls - 1$
case 392 : if ( debug ) { system . out . println ( " try statement with resources : : = try resource specification" ) ; } / / $non - nls - 1$
case 393 : if ( debug ) { system . out . println ( " resource specification : : = lparen resources ; opt rparen" ) ; } / / $non - nls - 1$
case 394 : if ( debug ) { system . out . println ( " ; opt : : = " ) ; } / / $non - nls - 1$
case 395 : if ( debug ) { system . out . println ( " ; opt : : = semicolon" ) ; } / / $non - nls - 1$
case 396 : if ( debug ) { system . out . println ( " resources : : = resource" ) ; } / / $non - nls - 1$
case 397 : if ( debug ) { system . out . println ( " resources : : = resources trailing semi colon resource" ) ; } / / $non - nls - 1$
case 398 : if ( debug ) { system . out . println ( " trailing semi colon : : = semicolon" ) ; } / / $non - nls - 1$
case 399 : if ( debug ) { system . out . println ( " resource : : = type push modifiers variable declarator id . . . " ) ; } / / $non - nls - 1$
case 400 : if ( debug ) { system . out . println ( " resource : : = modifiers type push real modifiers . . . " ) ; } / / $non - nls - 1$
case 401 : if ( debug ) { system . out . println ( " resource : : = name" ) ; } / / $non - nls - 1$
case 402 : if ( debug ) { system . out . println ( " resource : : = field access" ) ; } / / $non - nls - 1$
case 404 : if ( debug ) { system . out . println ( " exit try block : : = " ) ; } / / $non - nls - 1$
case 406 : if ( debug ) { system . out . println ( " catches : : = catches catch clause" ) ; } / / $non - nls - 1$
case 407 : if ( debug ) { system . out . println ( " catch clause : : = catch lparen catch formal parameter rparen" ) ; } / / $non - nls - 1$
case 409 : if ( debug ) { system . out . println ( " push lparen : : = lparen" ) ; } / / $non - nls - 1$
case 410 : if ( debug ) { system . out . println ( " push rparen : : = rparen" ) ; } / / $non - nls - 1$
case 415 : if ( debug ) { system . out . println ( " primary no new array : : = this" ) ; } / / $non - nls - 1$
case 416 : if ( debug ) { system . out . println ( " primary no new array : : = push lparen expression not name . . . " ) ; } / / $non - nls - 1$
case 417 : if ( debug ) { system . out . println ( " primary no new array : : = push lparen name push rparen" ) ; } / / $non - nls - 1$
case 420 : if ( debug ) { system . out . println ( " primary no new array : : = name dot this" ) ; } / / $non - nls - 1$
case 421 : if ( debug ) { system . out . println ( " qualified super receiver : : = name dot super" ) ; } / / $non - nls - 1$
case 422 : if ( debug ) { system . out . println ( " primary no new array : : = name dot class" ) ; } / / $non - nls - 1$
case 423 : if ( debug ) { system . out . println ( " primary no new array : : = name dims dot class" ) ; } / / $non - nls - 1$
case 424 : if ( debug ) { system . out . println ( " primary no new array : : = primitive type dims dot class" ) ; } / / $non - nls - 1$
case 425 : if ( debug ) { system . out . println ( " primary no new array : : = primitive type dot class" ) ; } / / $non - nls - 1$
case 431 : if ( debug ) { system . out . println ( " reference expression type arguments and trunk0 : : = . . . " ) ; } / / $non - nls - 1$
case 432 : if ( debug ) { system . out . println ( " reference expression type arguments and trunk0 : : = . . . " ) ; } / / $non - nls - 1$
case 433 : if ( debug ) { system . out . println ( " reference expression : : = primitive type dims colon colon" ) ; } / / $non - nls - 1$
case 434 : if ( debug ) { system . out . println ( " reference expression : : = name dimsopt colon colon . . . " ) ; } / / $non - nls - 1$
case 435 : if ( debug ) { system . out . println ( " reference expression : : = name begin type arguments . . . " ) ; } / / $non - nls - 1$
case 436 : if ( debug ) { system . out . println ( " reference expression : : = primary colon colon . . . " ) ; } / / $non - nls - 1$
case 437 : if ( debug ) { system . out . println ( " reference expression : : = qualified super receiver . . . " ) ; } / / $non - nls - 1$
case 438 : if ( debug ) { system . out . println ( " reference expression : : = super colon colon . . . " ) ; } / / $non - nls - 1$
case 439 : if ( debug ) { system . out . println ( " non wild type argumentsopt : : = " ) ; } / / $non - nls - 1$
case 441 : if ( debug ) { system . out . println ( " identifier or new : : = identifier" ) ; } / / $non - nls - 1$
case 442 : if ( debug ) { system . out . println ( " identifier or new : : = new" ) ; } / / $non - nls - 1$
case 443 : if ( debug ) { system . out . println ( " lambda expression : : = lambda parameters arrow lambda body" ) ; } / / $non - nls - 1$
case 444 : if ( debug ) { system . out . println ( " nested lambda : : = " ) ; } / / $non - nls - 1$
case 445 : if ( debug ) { system . out . println ( " lambda parameters : : = identifier nested lambda" ) ; } / / $non - nls - 1$
case 451 : if ( debug ) { system . out . println ( " type elided formal parameter list : : = . . . " ) ; } / / $non - nls - 1$
case 452 : if ( debug ) { system . out . println ( " type elided formal parameter : : = modifiersopt identifier" ) ; } / / $non - nls - 1$
case 455 : if ( debug ) { system . out . println ( " elided left brace and return : : = " ) ; } / / $non - nls - 1$
case 456 : if ( debug ) { system . out . println ( " allocation header : : = new class type lparen . . . " ) ; } / / $non - nls - 1$
case 457 : if ( debug ) { system . out . println ( " class instance creation expression : : = new . . . " ) ; } / / $non - nls - 1$
case 458 : if ( debug ) { system . out . println ( " class instance creation expression : : = new class type . . . " ) ; } / / $non - nls - 1$
case 459 : if ( debug ) { system . out . println ( " class instance creation expression : : = primary dot new . . . " ) ; } / / $non - nls - 1$
case 460 : if ( debug ) { system . out . println ( " class instance creation expression : : = primary dot new . . . " ) ; } / / $non - nls - 1$
case 461 : if ( debug ) { system . out . println ( " class instance creation expression : : = . . . " ) ; } / / $non - nls - 1$
case 462 : if ( debug ) { system . out . println ( " class instance creation expression : : = . . . " ) ; } / / $non - nls - 1$
case 463 : if ( debug ) { system . out . println ( " enter instance creation argument list : : = " ) ; } / / $non - nls - 1$
case 464 : if ( debug ) { system . out . println ( " class instance creation expression name : : = name dot new" ) ; } / / $non - nls - 1$
case 465 : if ( debug ) { system . out . println ( " unqualified class bodyopt : : = " ) ; } / / $non - nls - 1$
case 467 : if ( debug ) { system . out . println ( " unqualified enter anonymous class body : : = " ) ; } / / $non - nls - 1$
case 468 : if ( debug ) { system . out . println ( " qualified class bodyopt : : = " ) ; } / / $non - nls - 1$
case 470 : if ( debug ) { system . out . println ( " qualified enter anonymous class body : : = " ) ; } / / $non - nls - 1$
case 472 : if ( debug ) { system . out . println ( " argument list : : = argument list comma expression" ) ; } / / $non - nls - 1$
case 473 : if ( debug ) { system . out . println ( " array creation header : : = new primitive type . . . " ) ; } / / $non - nls - 1$
case 474 : if ( debug ) { system . out . println ( " array creation header : : = new class or interface type . . . " ) ; } / / $non - nls - 1$
case 475 : if ( debug ) { system . out . println ( " array creation without array initializer : : = new . . . " ) ; } / / $non - nls - 1$
case 476 : if ( debug ) { system . out . println ( " array creation with array initializer : : = new primitive type" ) ; } / / $non - nls - 1$
case 477 : if ( debug ) { system . out . println ( " array creation without array initializer : : = new . . . " ) ; } / / $non - nls - 1$
case 478 : if ( debug ) { system . out . println ( " array creation with array initializer : : = new . . . " ) ; } / / $non - nls - 1$
case 480 : if ( debug ) { system . out . println ( " dim with or with out exprs : : = dim with or with out exprs . . . " ) ; } / / $non - nls - 1$
case 482 : if ( debug ) { system . out . println ( " dim with or with out expr : : = type annotationsopt lbracket . . . " ) ; } / / $non - nls - 1$
case 483 : if ( debug ) { system . out . println ( " dims : : = dims loop" ) ; } / / $non - nls - 1$
case 486 : if ( debug ) { system . out . println ( " one dim loop : : = lbracket rbracket" ) ; } / / $non - nls - 1$
case 487 : if ( debug ) { system . out . println ( " one dim loop : : = type annotations lbracket rbracket" ) ; } / / $non - nls - 1$
case 488 : if ( debug ) { system . out . println ( " field access : : = primary dot identifier" ) ; } / / $non - nls - 1$
case 489 : if ( debug ) { system . out . println ( " field access : : = super dot identifier" ) ; } / / $non - nls - 1$
case 490 : if ( debug ) { system . out . println ( " field access : : = qualified super receiver dot identifier" ) ; } / / $non - nls - 1$
case 491 : if ( debug ) { system . out . println ( " method invocation : : = name lparen argument listopt rparen" ) ; } / / $non - nls - 1$
case 492 : if ( debug ) { system . out . println ( " method invocation : : = name dot only type arguments . . . " ) ; } / / $non - nls - 1$
case 493 : if ( debug ) { system . out . println ( " method invocation : : = primary dot only type arguments . . . " ) ; } / / $non - nls - 1$
case 494 : if ( debug ) { system . out . println ( " method invocation : : = primary dot identifier lparen . . . " ) ; } / / $non - nls - 1$
case 495 : if ( debug ) { system . out . println ( " method invocation : : = qualified super receiver dot . . . " ) ; } / / $non - nls - 1$
case 496 : if ( debug ) { system . out . println ( " method invocation : : = qualified super receiver dot . . . " ) ; } / / $non - nls - 1$
case 497 : if ( debug ) { system . out . println ( " method invocation : : = super dot only type arguments . . . " ) ; } / / $non - nls - 1$
case 498 : if ( debug ) { system . out . println ( " method invocation : : = super dot identifier lparen . . . " ) ; } / / $non - nls - 1$
case 499 : if ( debug ) { system . out . println ( " array access : : = name lbracket expression rbracket" ) ; } / / $non - nls - 1$
case 500 : if ( debug ) { system . out . println ( " array access : : = primary no new array lbracket expression . . . " ) ; } / / $non - nls - 1$
case 501 : if ( debug ) { system . out . println ( " array access : : = array creation with array initializer . . . " ) ; } / / $non - nls - 1$
case 503 : if ( debug ) { system . out . println ( " postfix expression : : = name" ) ; } / / $non - nls - 1$
case 506 : if ( debug ) { system . out . println ( " post increment expression : : = postfix expression plus plus" ) ; } / / $non - nls - 1$
case 507 : if ( debug ) { system . out . println ( " post decrement expression : : = postfix expression . . . " ) ; } / / $non - nls - 1$
case 508 : if ( debug ) { system . out . println ( " push position : : = " ) ; } / / $non - nls - 1$
case 511 : if ( debug ) { system . out . println ( " unary expression : : = plus push position unary expression" ) ; } / / $non - nls - 1$
case 512 : if ( debug ) { system . out . println ( " unary expression : : = minus push position unary expression" ) ; } / / $non - nls - 1$
case 514 : if ( debug ) { system . out . println ( " pre increment expression : : = plus plus push position . . . " ) ; } / / $non - nls - 1$
case 515 : if ( debug ) { system . out . println ( " pre decrement expression : : = minus minus push position . . . " ) ; } / / $non - nls - 1$
case 517 : if ( debug ) { system . out . println ( " unary expression not plus minus : : = twiddle push position . . . " ) ; } / / $non - nls - 1$
case 518 : if ( debug ) { system . out . println ( " unary expression not plus minus : : = not push position . . . " ) ; } / / $non - nls - 1$
case 520 : if ( debug ) { system . out . println ( " cast expression : : = push lparen primitive type dimsopt . . . " ) ; } / / $non - nls - 1$
case 521 : if ( debug ) { system . out . println ( " cast expression : : = push lparen name . . . " ) ; } / / $non - nls - 1$
case 522 : if ( debug ) { system . out . println ( " cast expression : : = push lparen name . . . " ) ; } / / $non - nls - 1$
case 523 : if ( debug ) { system . out . println ( " cast expression : : = push lparen name push rparen . . . " ) ; } / / $non - nls - 1$
case 524 : if ( debug ) { system . out . println ( " cast expression : : = begin intersection cast push lparen . . . " ) ; } / / $non - nls - 1$
case 525 : if ( debug ) { system . out . println ( " cast expression : : = push lparen name dims . . . " ) ; } / / $non - nls - 1$
case 526 : if ( debug ) { system . out . println ( " additional bounds list opt : : = " ) ; } / / $non - nls - 1$
case 530 : if ( debug ) { system . out . println ( " only type arguments for cast expression : : = only type arguments" ) ; } / / $non - nls - 1$
case 531 : if ( debug ) { system . out . println ( " inside cast expression : : = " ) ; } / / $non - nls - 1$
case 532 : if ( debug ) { system . out . println ( " inside cast expression ll1 : : = " ) ; } / / $non - nls - 1$
case 533 : if ( debug ) { system . out . println ( " inside cast expression ll1 with bounds : : = " ) ; } / / $non - nls - 1$
case 534 : if ( debug ) { system . out . println ( " inside cast expression with qualified generics : : = " ) ; } / / $non - nls - 1$
case 536 : if ( debug ) { system . out . println ( " multiplicative expression : : = multiplicative expression . . . " ) ; } / / $non - nls - 1$
case 537 : if ( debug ) { system . out . println ( " multiplicative expression : : = multiplicative expression . . . " ) ; } / / $non - nls - 1$
case 538 : if ( debug ) { system . out . println ( " multiplicative expression : : = multiplicative expression . . . " ) ; } / / $non - nls - 1$
case 540 : if ( debug ) { system . out . println ( " additive expression : : = additive expression plus . . . " ) ; } / / $non - nls - 1$
case 541 : if ( debug ) { system . out . println ( " additive expression : : = additive expression minus . . . " ) ; } / / $non - nls - 1$
case 543 : if ( debug ) { system . out . println ( " shift expression : : = shift expression left shift . . . " ) ; } / / $non - nls - 1$
case 544 : if ( debug ) { system . out . println ( " shift expression : : = shift expression right shift . . . " ) ; } / / $non - nls - 1$
case 545 : if ( debug ) { system . out . println ( " shift expression : : = shift expression unsigned right shift" ) ; } / / $non - nls - 1$
case 547 : if ( debug ) { system . out . println ( " relational expression : : = relational expression less . . . " ) ; } / / $non - nls - 1$
case 548 : if ( debug ) { system . out . println ( " relational expression : : = relational expression greater . . . " ) ; } / / $non - nls - 1$
case 549 : if ( debug ) { system . out . println ( " relational expression : : = relational expression less equal" ) ; } / / $non - nls - 1$
case 550 : if ( debug ) { system . out . println ( " relational expression : : = relational expression . . . " ) ; } / / $non - nls - 1$
case 552 : if ( debug ) { system . out . println ( " instanceof expression : : = instanceof expression instanceof" ) ; } / / $non - nls - 1$
case 554 : if ( debug ) { system . out . println ( " equality expression : : = equality expression equal equal . . . " ) ; } / / $non - nls - 1$
case 555 : if ( debug ) { system . out . println ( " equality expression : : = equality expression not equal . . . " ) ; } / / $non - nls - 1$
case 557 : if ( debug ) { system . out . println ( " and expression : : = and expression and equality expression" ) ; } / / $non - nls - 1$
case 559 : if ( debug ) { system . out . println ( " exclusive or expression : : = exclusive or expression xor . . . " ) ; } / / $non - nls - 1$
case 561 : if ( debug ) { system . out . println ( " inclusive or expression : : = inclusive or expression or . . . " ) ; } / / $non - nls - 1$
case 563 : if ( debug ) { system . out . println ( " conditional and expression : : = conditional and expression . . . " ) ; } / / $non - nls - 1$
case 565 : if ( debug ) { system . out . println ( " conditional or expression : : = conditional or expression . . . " ) ; } / / $non - nls - 1$
case 567 : if ( debug ) { system . out . println ( " conditional expression : : = conditional or expression . . . " ) ; } / / $non - nls - 1$
case 570 : if ( debug ) { system . out . println ( " assignment : : = postfix expression assignment operator . . . " ) ; } / / $non - nls - 1$
case 572 : if ( debug ) { system . out . println ( " assignment : : = invalid array initializer assignement" ) ; } / / $non - nls - 1$
case 573 : if ( debug ) { system . out . println ( " assignment operator : : = equal" ) ; } / / $non - nls - 1$
case 574 : if ( debug ) { system . out . println ( " assignment operator : : = multiply equal" ) ; } / / $non - nls - 1$
case 575 : if ( debug ) { system . out . println ( " assignment operator : : = divide equal" ) ; } / / $non - nls - 1$
case 576 : if ( debug ) { system . out . println ( " assignment operator : : = remainder equal" ) ; } / / $non - nls - 1$
case 577 : if ( debug ) { system . out . println ( " assignment operator : : = plus equal" ) ; } / / $non - nls - 1$
case 578 : if ( debug ) { system . out . println ( " assignment operator : : = minus equal" ) ; } / / $non - nls - 1$
case 579 : if ( debug ) { system . out . println ( " assignment operator : : = left shift equal" ) ; } / / $non - nls - 1$
case 580 : if ( debug ) { system . out . println ( " assignment operator : : = right shift equal" ) ; } / / $non - nls - 1$
case 581 : if ( debug ) { system . out . println ( " assignment operator : : = unsigned right shift equal" ) ; } / / $non - nls - 1$
case 582 : if ( debug ) { system . out . println ( " assignment operator : : = and equal" ) ; } / / $non - nls - 1$
case 583 : if ( debug ) { system . out . println ( " assignment operator : : = xor equal" ) ; } / / $non - nls - 1$
case 584 : if ( debug ) { system . out . println ( " assignment operator : : = or equal" ) ; } / / $non - nls - 1$
case 585 : if ( debug ) { system . out . println ( " expression : : = assignment expression" ) ; } / / $non - nls - 1$
case 588 : if ( debug ) { system . out . println ( " expressionopt : : = " ) ; } / / $non - nls - 1$
case 593 : if ( debug ) { system . out . println ( " class body declarationsopt : : = " ) ; } / / $non - nls - 1$
case 594 : if ( debug ) { system . out . println ( " class body declarationsopt : : = nested type . . . " ) ; } / / $non - nls - 1$
case 595 : if ( debug ) { system . out . println ( " modifiersopt : : = " ) ; } / / $non - nls - 1$
case 596 : if ( debug ) { system . out . println ( " modifiersopt : : = modifiers" ) ; } / / $non - nls - 1$
case 597 : if ( debug ) { system . out . println ( " block statementsopt : : = " ) ; } / / $non - nls - 1$
case 599 : if ( debug ) { system . out . println ( " dimsopt : : = " ) ; } / / $non - nls - 1$
case 601 : if ( debug ) { system . out . println ( " argument listopt : : = " ) ; } / / $non - nls - 1$
case 605 : if ( debug ) { system . out . println ( " formal parameter listopt : : = " ) ; } / / $non - nls - 1$
case 609 : if ( debug ) { system . out . println ( " interface member declarationsopt : : = " ) ; } / / $non - nls - 1$
case 610 : if ( debug ) { system . out . println ( " interface member declarationsopt : : = nested type . . . " ) ; } / / $non - nls - 1$
case 611 : if ( debug ) { system . out . println ( " nested type : : = " ) ; } / / $non - nls - 1$
case 612 : if ( debug ) { system . out . println ( " for initopt : : = " ) ; } / / $non - nls - 1$
case 614 : if ( debug ) { system . out . println ( " for updateopt : : = " ) ; } / / $non - nls - 1$
case 618 : if ( debug ) { system . out . println ( " catchesopt : : = " ) ; } / / $non - nls - 1$
case 620 : if ( debug ) { system . out . println ( " enum declaration : : = enum header enum body" ) ; } / / $non - nls - 1$
case 621 : if ( debug ) { system . out . println ( " enum header : : = enum header name class header implementsopt" ) ; } / / $non - nls - 1$
case 622 : if ( debug ) { system . out . println ( " enum header name : : = modifiersopt enum identifier" ) ; } / / $non - nls - 1$
case 623 : if ( debug ) { system . out . println ( " enum header name : : = modifiersopt enum identifier . . . " ) ; } / / $non - nls - 1$
case 624 : if ( debug ) { system . out . println ( " enum body : : = lbrace enum body declarationsopt rbrace" ) ; } / / $non - nls - 1$
case 625 : if ( debug ) { system . out . println ( " enum body : : = lbrace comma enum body declarationsopt . . . " ) ; } / / $non - nls - 1$
case 626 : if ( debug ) { system . out . println ( " enum body : : = lbrace enum constants comma . . . " ) ; } / / $non - nls - 1$
case 627 : if ( debug ) { system . out . println ( " enum body : : = lbrace enum constants . . . " ) ; } / / $non - nls - 1$
case 629 : if ( debug ) { system . out . println ( " enum constants : : = enum constants comma enum constant" ) ; } / / $non - nls - 1$
case 630 : if ( debug ) { system . out . println ( " enum constant header name : : = modifiersopt identifier" ) ; } / / $non - nls - 1$
case 631 : if ( debug ) { system . out . println ( " enum constant header : : = enum constant header name . . . " ) ; } / / $non - nls - 1$
case 632 : if ( debug ) { system . out . println ( " enum constant : : = enum constant header force no diet . . . " ) ; } / / $non - nls - 1$
case 633 : if ( debug ) { system . out . println ( " enum constant : : = enum constant header" ) ; } / / $non - nls - 1$
case 634 : if ( debug ) { system . out . println ( " arguments : : = lparen argument listopt rparen" ) ; } / / $non - nls - 1$
case 635 : if ( debug ) { system . out . println ( " argumentsopt : : = " ) ; } / / $non - nls - 1$
case 637 : if ( debug ) { system . out . println ( " enum declarations : : = semicolon class body declarationsopt" ) ; } / / $non - nls - 1$
case 638 : if ( debug ) { system . out . println ( " enum body declarationsopt : : = " ) ; } / / $non - nls - 1$
case 640 : if ( debug ) { system . out . println ( " enhanced for statement : : = enhanced for statement header . . . " ) ; } / / $non - nls - 1$
case 641 : if ( debug ) { system . out . println ( " enhanced for statement no short if : : = . . . " ) ; } / / $non - nls - 1$
case 642 : if ( debug ) { system . out . println ( " enhanced for statement header init : : = for lparen type . . . " ) ; } / / $non - nls - 1$
case 643 : if ( debug ) { system . out . println ( " enhanced for statement header init : : = for lparen modifiers" ) ; } / / $non - nls - 1$
case 644 : if ( debug ) { system . out . println ( " enhanced for statement header : : = . . . " ) ; } / / $non - nls - 1$
case 645 : if ( debug ) { system . out . println ( " single static import declaration : : = . . . " ) ; } / / $non - nls - 1$
case 646 : if ( debug ) { system . out . println ( " single static import declaration name : : = import static name" ) ; } / / $non - nls - 1$
case 647 : if ( debug ) { system . out . println ( " static import on demand declaration : : = . . . " ) ; } / / $non - nls - 1$
case 648 : if ( debug ) { system . out . println ( " static import on demand declaration name : : = import static . . . " ) ; } / / $non - nls - 1$
case 649 : if ( debug ) { system . out . println ( " type arguments : : = less type argument list1" ) ; } / / $non - nls - 1$
case 650 : if ( debug ) { system . out . println ( " only type arguments : : = less type argument list1" ) ; } / / $non - nls - 1$
case 652 : if ( debug ) { system . out . println ( " type argument list1 : : = type argument list comma . . . " ) ; } / / $non - nls - 1$
case 654 : if ( debug ) { system . out . println ( " type argument list : : = type argument list comma type argument" ) ; } / / $non - nls - 1$
case 655 : if ( debug ) { system . out . println ( " type argument : : = reference type" ) ; } / / $non - nls - 1$
case 659 : if ( debug ) { system . out . println ( " reference type1 : : = reference type greater" ) ; } / / $non - nls - 1$
case 660 : if ( debug ) { system . out . println ( " reference type1 : : = class or interface less . . . " ) ; } / / $non - nls - 1$
case 662 : if ( debug ) { system . out . println ( " type argument list2 : : = type argument list comma . . . " ) ; } / / $non - nls - 1$
case 665 : if ( debug ) { system . out . println ( " reference type2 : : = reference type right shift" ) ; } / / $non - nls - 1$
case 666 : if ( debug ) { system . out . println ( " reference type2 : : = class or interface less . . . " ) ; } / / $non - nls - 1$
case 668 : if ( debug ) { system . out . println ( " type argument list3 : : = type argument list comma . . . " ) ; } / / $non - nls - 1$
case 671 : if ( debug ) { system . out . println ( " reference type3 : : = reference type unsigned right shift" ) ; } / / $non - nls - 1$
case 672 : if ( debug ) { system . out . println ( " wildcard : : = type annotationsopt question" ) ; } / / $non - nls - 1$
case 673 : if ( debug ) { system . out . println ( " wildcard : : = type annotationsopt question wildcard bounds" ) ; } / / $non - nls - 1$
case 674 : if ( debug ) { system . out . println ( " wildcard bounds : : = extends reference type" ) ; } / / $non - nls - 1$
case 675 : if ( debug ) { system . out . println ( " wildcard bounds : : = super reference type" ) ; } / / $non - nls - 1$
case 676 : if ( debug ) { system . out . println ( " wildcard1 : : = type annotationsopt question greater" ) ; } / / $non - nls - 1$
case 677 : if ( debug ) { system . out . println ( " wildcard1 : : = type annotationsopt question . . . " ) ; } / / $non - nls - 1$
case 678 : if ( debug ) { system . out . println ( " wildcard bounds1 : : = extends reference type1" ) ; } / / $non - nls - 1$
case 679 : if ( debug ) { system . out . println ( " wildcard bounds1 : : = super reference type1" ) ; } / / $non - nls - 1$
case 680 : if ( debug ) { system . out . println ( " wildcard2 : : = type annotationsopt question right shift" ) ; } / / $non - nls - 1$
case 681 : if ( debug ) { system . out . println ( " wildcard2 : : = type annotationsopt question . . . " ) ; } / / $non - nls - 1$
case 682 : if ( debug ) { system . out . println ( " wildcard bounds2 : : = extends reference type2" ) ; } / / $non - nls - 1$
case 683 : if ( debug ) { system . out . println ( " wildcard bounds2 : : = super reference type2" ) ; } / / $non - nls - 1$
case 684 : if ( debug ) { system . out . println ( " wildcard3 : : = type annotationsopt question . . . " ) ; } / / $non - nls - 1$
case 685 : if ( debug ) { system . out . println ( " wildcard3 : : = type annotationsopt question . . . " ) ; } / / $non - nls - 1$
case 686 : if ( debug ) { system . out . println ( " wildcard bounds3 : : = extends reference type3" ) ; } / / $non - nls - 1$
case 687 : if ( debug ) { system . out . println ( " wildcard bounds3 : : = super reference type3" ) ; } / / $non - nls - 1$
case 688 : if ( debug ) { system . out . println ( " type parameter header : : = type annotationsopt identifier" ) ; } / / $non - nls - 1$
case 689 : if ( debug ) { system . out . println ( " type parameters : : = less type parameter list1" ) ; } / / $non - nls - 1$
case 691 : if ( debug ) { system . out . println ( " type parameter list : : = type parameter list comma . . . " ) ; } / / $non - nls - 1$
case 693 : if ( debug ) { system . out . println ( " type parameter : : = type parameter header extends . . . " ) ; } / / $non - nls - 1$
case 694 : if ( debug ) { system . out . println ( " type parameter : : = type parameter header extends . . . " ) ; } / / $non - nls - 1$
case 696 : if ( debug ) { system . out . println ( " additional bound list : : = additional bound list . . . " ) ; } / / $non - nls - 1$
case 697 : if ( debug ) { system . out . println ( " additional bound : : = and reference type" ) ; } / / $non - nls - 1$
case 699 : if ( debug ) { system . out . println ( " type parameter list1 : : = type parameter list comma . . . " ) ; } / / $non - nls - 1$
case 700 : if ( debug ) { system . out . println ( " type parameter1 : : = type parameter header greater" ) ; } / / $non - nls - 1$
case 701 : if ( debug ) { system . out . println ( " type parameter1 : : = type parameter header extends . . . " ) ; } / / $non - nls - 1$
case 702 : if ( debug ) { system . out . println ( " type parameter1 : : = type parameter header extends . . . " ) ; } / / $non - nls - 1$
case 704 : if ( debug ) { system . out . println ( " additional bound list1 : : = additional bound list . . . " ) ; } / / $non - nls - 1$
case 705 : if ( debug ) { system . out . println ( " additional bound1 : : = and reference type1" ) ; } / / $non - nls - 1$
case 711 : if ( debug ) { system . out . println ( " unary expression not name : : = plus push position . . . " ) ; } / / $non - nls - 1$
case 712 : if ( debug ) { system . out . println ( " unary expression not name : : = minus push position . . . " ) ; } / / $non - nls - 1$
case 715 : if ( debug ) { system . out . println ( " unary expression not plus minus not name : : = twiddle . . . " ) ; } / / $non - nls - 1$
case 716 : if ( debug ) { system . out . println ( " unary expression not plus minus not name : : = not push position" ) ; } / / $non - nls - 1$
case 719 : if ( debug ) { system . out . println ( " multiplicative expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 720 : if ( debug ) { system . out . println ( " multiplicative expression not name : : = name multiply . . . " ) ; } / / $non - nls - 1$
case 721 : if ( debug ) { system . out . println ( " multiplicative expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 722 : if ( debug ) { system . out . println ( " multiplicative expression not name : : = name divide . . . " ) ; } / / $non - nls - 1$
case 723 : if ( debug ) { system . out . println ( " multiplicative expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 724 : if ( debug ) { system . out . println ( " multiplicative expression not name : : = name remainder . . . " ) ; } / / $non - nls - 1$
case 726 : if ( debug ) { system . out . println ( " additive expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 727 : if ( debug ) { system . out . println ( " additive expression not name : : = name plus . . . " ) ; } / / $non - nls - 1$
case 728 : if ( debug ) { system . out . println ( " additive expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 729 : if ( debug ) { system . out . println ( " additive expression not name : : = name minus . . . " ) ; } / / $non - nls - 1$
case 731 : if ( debug ) { system . out . println ( " shift expression not name : : = shift expression not name . . . " ) ; } / / $non - nls - 1$
case 732 : if ( debug ) { system . out . println ( " shift expression not name : : = name left shift . . . " ) ; } / / $non - nls - 1$
case 733 : if ( debug ) { system . out . println ( " shift expression not name : : = shift expression not name . . . " ) ; } / / $non - nls - 1$
case 734 : if ( debug ) { system . out . println ( " shift expression not name : : = name right shift . . . " ) ; } / / $non - nls - 1$
case 735 : if ( debug ) { system . out . println ( " shift expression not name : : = shift expression not name . . . " ) ; } / / $non - nls - 1$
case 736 : if ( debug ) { system . out . println ( " shift expression not name : : = name unsigned right shift . . . " ) ; } / / $non - nls - 1$
case 738 : if ( debug ) { system . out . println ( " relational expression not name : : = shift expression not name" ) ; } / / $non - nls - 1$
case 739 : if ( debug ) { system . out . println ( " relational expression not name : : = name less . . . " ) ; } / / $non - nls - 1$
case 740 : if ( debug ) { system . out . println ( " relational expression not name : : = shift expression not name" ) ; } / / $non - nls - 1$
case 741 : if ( debug ) { system . out . println ( " relational expression not name : : = name greater . . . " ) ; } / / $non - nls - 1$
case 742 : if ( debug ) { system . out . println ( " relational expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 743 : if ( debug ) { system . out . println ( " relational expression not name : : = name less equal . . . " ) ; } / / $non - nls - 1$
case 744 : if ( debug ) { system . out . println ( " relational expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 745 : if ( debug ) { system . out . println ( " relational expression not name : : = name greater equal . . . " ) ; } / / $non - nls - 1$
case 747 : if ( debug ) { system . out . println ( " instanceof expression not name : : = name instanceof . . . " ) ; } / / $non - nls - 1$
case 748 : if ( debug ) { system . out . println ( " instanceof expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 750 : if ( debug ) { system . out . println ( " equality expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 751 : if ( debug ) { system . out . println ( " equality expression not name : : = name equal equal . . . " ) ; } / / $non - nls - 1$
case 752 : if ( debug ) { system . out . println ( " equality expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 753 : if ( debug ) { system . out . println ( " equality expression not name : : = name not equal . . . " ) ; } / / $non - nls - 1$
case 755 : if ( debug ) { system . out . println ( " and expression not name : : = and expression not name and . . . " ) ; } / / $non - nls - 1$
case 756 : if ( debug ) { system . out . println ( " and expression not name : : = name and equality expression" ) ; } / / $non - nls - 1$
case 758 : if ( debug ) { system . out . println ( " exclusive or expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 759 : if ( debug ) { system . out . println ( " exclusive or expression not name : : = name xor and expression" ) ; } / / $non - nls - 1$
case 761 : if ( debug ) { system . out . println ( " inclusive or expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 762 : if ( debug ) { system . out . println ( " inclusive or expression not name : : = name or . . . " ) ; } / / $non - nls - 1$
case 764 : if ( debug ) { system . out . println ( " conditional and expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 765 : if ( debug ) { system . out . println ( " conditional and expression not name : : = name and and . . . " ) ; } / / $non - nls - 1$
case 767 : if ( debug ) { system . out . println ( " conditional or expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 768 : if ( debug ) { system . out . println ( " conditional or expression not name : : = name or or . . . " ) ; } / / $non - nls - 1$
case 770 : if ( debug ) { system . out . println ( " conditional expression not name : : = . . . " ) ; } / / $non - nls - 1$
case 771 : if ( debug ) { system . out . println ( " conditional expression not name : : = name question . . . " ) ; } / / $non - nls - 1$
case 775 : if ( debug ) { system . out . println ( " annotation type declaration header name : : = modifiers at . . . " ) ; } / / $non - nls - 1$
case 776 : if ( debug ) { system . out . println ( " annotation type declaration header name : : = modifiers at . . . " ) ; } / / $non - nls - 1$
case 777 : if ( debug ) { system . out . println ( " annotation type declaration header name : : = at . . . " ) ; } / / $non - nls - 1$
case 778 : if ( debug ) { system . out . println ( " annotation type declaration header name : : = at . . . " ) ; } / / $non - nls - 1$
case 779 : if ( debug ) { system . out . println ( " annotation type declaration header : : = . . . " ) ; } / / $non - nls - 1$
case 780 : if ( debug ) { system . out . println ( " annotation type declaration : : = . . . " ) ; } / / $non - nls - 1$
case 782 : if ( debug ) { system . out . println ( " annotation type member declarationsopt : : = " ) ; } / / $non - nls - 1$
case 783 : if ( debug ) { system . out . println ( " annotation type member declarationsopt : : = nested type . . . " ) ; } / / $non - nls - 1$
case 785 : if ( debug ) { system . out . println ( " annotation type member declarations : : = . . . " ) ; } / / $non - nls - 1$
case 786 : if ( debug ) { system . out . println ( " annotation method header name : : = modifiersopt . . . " ) ; } / / $non - nls - 1$
case 787 : if ( debug ) { system . out . println ( " annotation method header name : : = modifiersopt type . . . " ) ; } / / $non - nls - 1$
case 788 : if ( debug ) { system . out . println ( " annotation method header default valueopt : : = " ) ; } / / $non - nls - 1$
case 789 : if ( debug ) { system . out . println ( " annotation method header default valueopt : : = default value" ) ; } / / $non - nls - 1$
case 790 : if ( debug ) { system . out . println ( " annotation method header : : = annotation method header name . . . " ) ; } / / $non - nls - 1$
case 791 : if ( debug ) { system . out . println ( " annotation type member declaration : : = . . . " ) ; } / / $non - nls - 1$
case 799 : if ( debug ) { system . out . println ( " annotation name : : = at unannotatable name" ) ; } / / $non - nls - 1$
case 800 : if ( debug ) { system . out . println ( " normal annotation : : = annotation name lparen . . . " ) ; } / / $non - nls - 1$
case 801 : if ( debug ) { system . out . println ( " member value pairsopt : : = " ) ; } / / $non - nls - 1$
case 804 : if ( debug ) { system . out . println ( " member value pairs : : = member value pairs comma . . . " ) ; } / / $non - nls - 1$
case 805 : if ( debug ) { system . out . println ( " member value pair : : = simple name equal enter member value . . . " ) ; } / / $non - nls - 1$
case 806 : if ( debug ) { system . out . println ( " enter member value : : = " ) ; } / / $non - nls - 1$
case 807 : if ( debug ) { system . out . println ( " exit member value : : = " ) ; } / / $non - nls - 1$
case 809 : if ( debug ) { system . out . println ( " member value : : = name" ) ; } / / $non - nls - 1$
case 812 : if ( debug ) { system . out . println ( " member value array initializer : : = . . . " ) ; } / / $non - nls - 1$
case 813 : if ( debug ) { system . out . println ( " member value array initializer : : = . . . " ) ; } / / $non - nls - 1$
case 814 : if ( debug ) { system . out . println ( " member value array initializer : : = . . . " ) ; } / / $non - nls - 1$
case 815 : if ( debug ) { system . out . println ( " member value array initializer : : = . . . " ) ; } / / $non - nls - 1$
case 816 : if ( debug ) { system . out . println ( " enter member value array initializer : : = " ) ; } / / $non - nls - 1$
case 818 : if ( debug ) { system . out . println ( " member values : : = member values comma member value" ) ; } / / $non - nls - 1$
case 819 : if ( debug ) { system . out . println ( " marker annotation : : = annotation name" ) ; } / / $non - nls - 1$
case 820 : if ( debug ) { system . out . println ( " single member annotation member value : : = member value" ) ; } / / $non - nls - 1$
case 821 : if ( debug ) { system . out . println ( " single member annotation : : = annotation name lparen . . . " ) ; } / / $non - nls - 1$
case 822 : if ( debug ) { system . out . println ( " recovery method header name : : = modifiersopt type parameters" ) ; } / / $non - nls - 1$
case 823 : if ( debug ) { system . out . println ( " recovery method header name : : = modifiersopt type . . . " ) ; } / / $non - nls - 1$
case 824 : if ( debug ) { system . out . println ( " recovery method header name : : = modifiers with default . . . " ) ; } / / $non - nls - 1$
case 825 : if ( debug ) { system . out . println ( " recovery method header name : : = modifiers with default type" ) ; } / / $non - nls - 1$
case 826 : if ( debug ) { system . out . println ( " recovery method header : : = recovery method header name . . . " ) ; } / / $non - nls - 1$
num states = 1140 ,
la state offset = 16424 ,
num rules = 827 ,
num non terminals = 377 , dcnl num symbols = 502 , dcnl start state = 874 ,
* commented since reverted to original behaviour as per bug 495598
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2015 ibm corporation and others .
try { dcnl member . delete ( i resource . force , null ) ; dcnl } catch ( core exception e ) { dcnl util . log ( e , " error occurred while deleting : " + member . get full path ( ) ) ; / / $non - nls - 1$ dcnl }
* copyright ( c ) 2000 , 2010 ibm corporation and others .
/ / tests names = new string [ ] { "test bug496574 small" } ;
static final boolean should workaround bug jdk 8153748 = true ; / / emulating javac behaviour after private email communication dcnl
if ( should workaround bug jdk 8153748 ) { dcnl if ( add jdk 8153748 constraints from invocation ( this . invocation arguments , method ) = = reduction result . true ) / / todo : return null on answer false ? dcnl this . current bounds . incorporate ( this ) ; dcnl }
list < set < inference variable > > components = this . current bounds . compute connected components ( this . inference variables ) ;
/ / reduced version for analysis ( no need to run during normal tests ) dcnl public void test439594 small ( ) { dcnl this . run negative test ( dcnl new string [ ] { dcnl "x . java" , dcnl "import java . util . array list ; \ n" + dcnl "import java . util . list ; \ n" + dcnl "import java . util . function . function ; \ n" + dcnl "import java . util . function . predicate ; \ n" + dcnl "import java . util . stream . collectors ; \ n" + dcnl "import java . util . stream . stream ; \ n" + dcnl "public class x { \ n" + dcnl " protected static interface i list entry { \ n" + dcnl " public < t > t visit records with result ( function < stream < record > , t > func ) ; \ n" + dcnl " } \ n" + dcnl " protected static final class immutable record { \ n" + dcnl " public immutable record ( record r ) { } \ n" + dcnl " } \ n" + dcnl " protected static final class record { } \ n" + dcnl " public list < immutable record > compiles with javac but not eclipse1 ( ) \ n" + dcnl " { \ n" + dcnl " return visit entries with result ( stream - > { \ n" + dcnl " return stream . map ( entry - > { \ n" + dcnl " return entry . visit records with result ( stream2 - > stream2 \ n" + dcnl " . filter ( some predicate ( ) ) \ n" + dcnl " . map ( immutable record : : new ) \ n" + dcnl " . collect ( collectors . to list ( ) ) \ n" + dcnl " ) ; \ n" + dcnl " } ) . flat map ( list : : stream ) . collect ( collectors . to collection ( array list : : new ) ) ; \ n" + dcnl " } ) ; \ n" + dcnl " } \ n" + dcnl " private static predicate < record > some predicate ( ) { \ n" + dcnl " return record - > true ; \ n" + dcnl " } \ n" + dcnl " private < t > t visit entries with result ( function < stream < i list entry > , t > func ) { \ n" + dcnl " return func . apply ( new array list < i list entry > ( ) . stream ( ) ) ; \ n" + dcnl " } \ n" + dcnl " } \ n" dcnl } , dcnl "" ) ; dcnl }
private bound set b3 ;
this . b3 = this . current bounds . copy ( ) ; dcnl dcnl if ( should workaround bug jdk 8153748 ) { / / "before 18 . 5 . 2" , but should not spill into b3 . . . ( heuristically ) dcnl reduction result jdk8153748result = add jdk 8153748 constraints from invocation ( this . invocation arguments , method ) ; dcnl if ( jdk8153748result ! = null ) { dcnl this . current bounds . incorporate ( this ) ; dcnl } dcnl } dcnl
{ dcnl / / - - not per jls , emulate javac behavior : dcnl subst f = scope . substitute ( get result substitution ( this . b3 , false ) , subst f ) ; dcnl / / - - dcnl
if ( !inference context . compute b3 ( invocation , this . right , method ) )
/ * * not per jls : inbox for emulation of how javac passes type bounds from inner to outer * / dcnl private bound set inner inbox ; dcnl / * * not per jls : signal when current is ready to directly merge all bounds from inner . * / dcnl private boolean directly accepting inner bounds = false ;
/ * * perform steps from jls 18 . 5 . 2 . needed for computing the bound set b3 . * / dcnl boolean compute b3 ( invocation site invocation site , type binding target type , method binding method ) dcnl throws inference failure exception dcnl { dcnl boolean result = constraint expression formula . infer poly invocation type ( this , invocation site , target type , method ) ; dcnl if ( result ) { dcnl merge inner bounds ( ) ; dcnl if ( this . b3 = = null ) dcnl this . b3 = this . current bounds . copy ( ) ; dcnl } dcnl return result ; dcnl } dcnl
if ( !compute b3 ( invocation site , expected type , method ) ) {
} else { dcnl merge inner bounds ( ) ; dcnl this . b3 = this . current bounds . copy ( ) ;
push bounds to outer ( ) ; dcnl this . directly accepting inner bounds = true ; dcnl
if ( !add constraints to c ( this . invocation arguments , c , method , this . inference kind , invocation site ) )
/ / - - - not per jls : emulate how javac passes type bounds from inner to outer : - - - dcnl / * * not per jls : push current bounds to outer inference if outer is ready for it . * / dcnl private void push bounds to outer ( ) { dcnl inference context18 outer = this . outer context ; dcnl if ( outer ! = null & & outer . step completed > = applicability inferred ) { dcnl if ( outer . directly accepting inner bounds ) { dcnl outer . current bounds . add bounds ( this . current bounds , this . environment ) ; dcnl } else if ( outer . inner inbox = = null ) { dcnl outer . inner inbox = this . current bounds . copy ( ) ; dcnl } else { dcnl outer . inner inbox . add bounds ( this . current bounds , this . environment ) ; dcnl } dcnl } dcnl } dcnl / * * not jls : merge pending bounds of inner inference into current . * / dcnl private void merge inner bounds ( ) { dcnl if ( this . inner inbox ! = null ) { dcnl this . current bounds . add bounds ( this . inner inbox , this . environment ) ; dcnl this . inner inbox = null ; dcnl } dcnl } dcnl dcnl interface inference operation { dcnl boolean perform ( ) throws inference failure exception ; dcnl } dcnl / * * not per jls : if operation succeeds merge new bounds from inner into current . * / dcnl private boolean collecting inner bounds ( inference operation operation ) throws inference failure exception { dcnl boolean result = operation . perform ( ) ; dcnl if ( result ) dcnl merge inner bounds ( ) ; dcnl else dcnl this . inner inbox = null ; dcnl return result ; dcnl } dcnl / / - - - dcnl
final constraint formula expr constraint = new constraint expression formula ( functional expr , target type , reduction result . compatible , argument constraints are soft ) ; dcnl if ( collecting inner bounds ( new inference operation ( ) { dcnl @ override dcnl public boolean perform ( ) throws inference failure exception { dcnl return expr constraint . input variables ( inference context18 . this ) . is empty ( ) ; dcnl } dcnl } ) ) { / / input variable would signal : not ready for inference dcnl if ( !collecting inner bounds ( new inference operation ( ) { dcnl @ override dcnl public boolean perform ( ) throws inference failure exception { dcnl return reduce and incorporate ( expr constraint ) ; dcnl } dcnl } ) )
final constraint formula exc constraint = new constraint exception formula ( functional expr , target type ) ; / / ? ? dcnl if ( !collecting inner bounds ( new inference operation ( ) { dcnl @ override dcnl public boolean perform ( ) throws inference failure exception { dcnl return reduce and incorporate ( exc constraint ) ; dcnl } dcnl } ) )
private boolean add constraints to c ( expression [ ] exprs , set < constraint formula > c , method binding method , int inference kind for method , invocation site site )
if ( !add constraints to c one expr ( exprs [ i ] , c , fsi , subst f , method ) )
private boolean add constraints to c one expr ( expression expri , set < constraint formula > c , type binding fsi , type binding subst f , method binding method )
if ( !add constraints to c one expr ( result expression , c , r . original ( ) , r , method ) )
if ( inner context ! = null ) {
if ( !inner context . compute b3 ( invocation , subst f , shallow method ) )
return inner context . add constraints to c ( arguments , c , inner method . generic method ( ) , inner context . inference kind , invocation ) ;
return this . add constraints to c ( arguments , c , inner method . generic method ( ) , applicability kind , invocation ) ;
return add constraints to c one expr ( ce . value if true , c , fsi , subst f , method ) dcnl & & add constraints to c one expr ( ce . value if false , c , fsi , subst f , method ) ;
provides statement : : = provides interface with clause ' ; '
if ( ( element . get element type ( ) = = i java element . method | | is implementable type ( element ) ) & & selection converter . can operate on ( editor ) ) {
if ( type binding . equals equals ( alpha , bound t . left ) ) { dcnl type binding t = bound t . right ; dcnl return constraint type formula . create ( s , t , bound t . relation , bound t . is soft | | bound s . is soft ) ; dcnl } dcnl if ( type binding . equals equals ( alpha , bound t . right ) ) { dcnl type binding t = bound t . left ; dcnl return constraint type formula . create ( t , s , bound t . relation , bound t . is soft | | bound s . is soft ) ; dcnl }
* copyright ( c ) 2011 , 2016 ibm corporation and others .
public void atest inspect class file from jar ( ) throws exception {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
< template name = "public method" description = " % templates . public method" id = "org . eclipse . jdt . ui . templates . public method" context = "java - members" enabled = "true" autoinsert = "false" > public $ { void } $ { name } ( $ { } ) {
< template name = "public static method" description = " % templates . public static method" id = "org . eclipse . jdt . ui . templates . public static method" context = "java - members" enabled = "true" autoinsert = "false" > public static $ { void } $ { name } ( $ { } ) {
< template name = "protected method" description = " % templates . protected method" id = "org . eclipse . jdt . ui . templates . protected method" context = "java - members" enabled = "true" autoinsert = "false" > protected $ { void } $ { name } ( $ { } ) {
< template name = "private method" description = " % templates . private method" id = "org . eclipse . jdt . ui . templates . private method" context = "java - members" enabled = "true" autoinsert = "false" > private $ { void } $ { name } ( $ { } ) {
import java . util . hash map ; dcnl import java . util . map ;
public static boolean is same site ( invocation site site1 , invocation site site2 ) {
if ( site1 . source start ( ) = = site2 . source start ( ) & & site1 . source end ( ) = = site2 . source end ( ) )
new variables [ i ] = inference variable . get ( type variables [ i ] , i , this . current invocation , this . scope , this . object ) ;
import java . util . map ;
dcnl / * * structured key for interning . * / dcnl static class inference var key { dcnl / * @ non null * / type binding type parameter ; dcnl long position ; dcnl int rank ; dcnl inference var key ( type binding type parameter , invocation site site , int rank ) { dcnl this . type parameter = type parameter ; dcnl this . position = ( ( long ) site . source start ( ) < < 32 ) + site . source end ( ) ; dcnl this . rank = rank ; dcnl } dcnl @ override dcnl public int hash code ( ) { dcnl final int prime = 31 ; dcnl int result = 1 ; dcnl result = prime * result + ( int ) ( this . position ^ ( this . position > > > 32 ) ) ; dcnl result = prime * result + this . rank ; dcnl result = prime * result + this . type parameter . id ; dcnl return result ; dcnl } dcnl @ override dcnl public boolean equals ( object obj ) { dcnl if ( this = = obj ) dcnl return true ; dcnl if ( obj = = null ) dcnl return false ; dcnl if ( ! ( obj instanceof inference var key ) ) dcnl return false ; dcnl inference var key other = ( inference var key ) obj ; dcnl if ( this . position ! = other . position ) dcnl return false ; dcnl if ( this . rank ! = other . rank ) dcnl return false ; dcnl if ( type binding . not equals ( this . type parameter , other . type parameter ) ) dcnl return false ; dcnl return true ; dcnl } dcnl } dcnl dcnl / * * dcnl * create or retrieve the inference variable representing the given type parameter . dcnl * inference variables are interned to avoid duplication due to lambda copying . dcnl * / dcnl public static inference variable get ( type binding type parameter , int rank , invocation site site , scope scope , reference binding object ) { dcnl map < inference var key , inference variable > unique inference variables = scope . compilation unit scope ( ) . unique inference variables ; dcnl inference variable var = null ; dcnl inference var key key = null ; dcnl if ( site ! = null & & type parameter ! = null ) { dcnl key = new inference var key ( type parameter , site , rank ) ; dcnl var = unique inference variables . get ( key ) ; dcnl } dcnl if ( var = = null ) { dcnl int new var id = unique inference variables . size ( ) ; dcnl var = new inference variable ( type parameter , rank , new var id , site , scope . environment ( ) , object ) ; dcnl if ( key ! = null ) dcnl unique inference variables . put ( key , var ) ; dcnl } dcnl return var ; dcnl } dcnl
int var id ; / / this is used for constructing a source name like t#0 .
private inference variable ( type binding type parameter , int parameter rank , int i var id , invocation site site , lookup environment environment , reference binding object ) {
if ( this . site ! = null ) { dcnl code = 31 * code + this . site . source start ( ) ; dcnl code = 31 * code + this . site . source end ( ) ; dcnl } dcnl return code ;
public void atest translate containers ( ) throws exception {
type reference [ ] p interfaces = this . module declaration . interfaces ; dcnl for ( int i = 0 , l = p interfaces . length ; i < l ; + + i ) { dcnl type reference p interface = p interfaces [ i ] ; dcnl if ( p interface instanceof completion on provides interfaces single type reference | | dcnl p interface instanceof completion on provides interfaces qualified type reference ) { dcnl this . lookup environment . build type bindings ( parsed unit , null ) ; dcnl if ( ( this . unit scope = parsed unit . scope ) ! = null ) { dcnl context accepted = true ; dcnl build context ( p interface , null , parsed unit , null , null ) ; dcnl find type references ( p interface , true ) ; dcnl debug printf ( ) ; dcnl return ; dcnl } dcnl } dcnl } dcnl type reference [ ] implementations = this . module declaration . implementations ; dcnl for ( int i = 0 , l = implementations . length ; i < l ; + + i ) { dcnl type reference implementation = implementations [ i ] ; dcnl if ( implementation instanceof completion on provides interfaces single type reference | | dcnl implementation instanceof completion on provides interfaces qualified type reference ) { dcnl this . lookup environment . build type bindings ( parsed unit , null ) ; dcnl if ( ( this . unit scope = parsed unit . scope ) ! = null ) { dcnl context accepted = true ; dcnl build context ( implementation , null , parsed unit , null , null ) ; dcnl find type references ( implementation , true ) ; dcnl debug printf ( ) ; dcnl return ; dcnl } dcnl } dcnl }
protected static final int k after with in provides statement = completion parser + 50 ;
exports to , dcnl provides with ,
if ( found token ( k after package in exports statement ) ) keyword = module keyword . exports to ; dcnl else if ( found token ( k after name in provides statement ) ) keyword = module keyword . provides with ;
if ( keyword = = module keyword . exports to ) return new char [ ] [ ] { keywords . to } ; dcnl else if ( keyword = = module keyword . provides with ) return new char [ ] [ ] { keywords . with } ;
protected void consume provides interface ( ) { dcnl super . consume provides interface ( ) ; dcnl push on element stack ( k after name in provides statement ) ; dcnl }
protected void consume with clause ( ) { dcnl super . consume with clause ( ) ; dcnl pop element ( k after with in provides statement ) ; dcnl }
private type reference check and create module qualified assist type reference ( char [ ] [ ] previous identifiers , char [ ] assist name , long [ ] positions ) { dcnl if ( is in uses statement ( ) ) return new completion on uses qualified type reference ( previous identifiers , assist name , positions ) ; dcnl if ( is in provides statement ( ) ) { dcnl if ( is after with clause ( ) ) return new completion on provides implementations qualified type reference ( previous identifiers , assist name , positions ) ; dcnl return new completion on provides interfaces qualified type reference ( previous identifiers , assist name , positions ) ; dcnl } dcnl return new completion on qualified type reference ( previous identifiers , assist name , positions ) ; dcnl }
return check and create module qualified assist type reference (
private type reference check and create module single assist type reference ( char [ ] assist name , long position ) { dcnl if ( is in uses statement ( ) ) return new completion on uses single type reference ( assist name , position ) ; dcnl if ( is in provides statement ( ) ) { dcnl if ( is after with clause ( ) ) return new completion on provides implementations single type reference ( assist name , position ) ; dcnl return new completion on provides interfaces single type reference ( assist name , position ) ; dcnl } dcnl return new completion on single type reference ( assist name , position ) ; dcnl }
return check and create module single assist type reference ( assist name , position ) ;
protected void consume provides interface ( ) {
module . interfaces [ module . services count ] = si name ;
protected void consume provides statement ( ) { dcnl / / do nothing dcnl }
module . implementations [ module . services count + + ] = si name ;
public void test translate containers ( ) throws exception {
open implementation action . tooltip = opens the implementations of a method or type in its hierarchy
open implementation action tooltip = open the implementations in the method's or type's hierarchy dcnl open implementation action description = open the implementations in the method's or type's hierarchy
if ( can open implementation ( element ) & & selection converter . can operate on ( editor ) ) { dcnl hyperlinks collector . add ( new java element implementation hyperlink ( word region , open action , element , qualify , editor ) ) ;
public static boolean can open implementation ( i java element element ) { dcnl return element . get element type ( ) = = i java element . method | | is implementable type ( element ) ; dcnl } dcnl dcnl private static boolean is implementable type ( i java element element ) {
import java . util . arrays ;
open implementations ( f editor , f region , f element , f open action ) ;
* finds the implementations for the method or type .
* if there's only one implementor that element is opened in the editor , otherwise the quick
* @ param java element the method or type dcnl * @ param open action the action to use to open the elements dcnl * @ since 3 . 6
public static void open implementations ( i editor part editor , i region region , final i java element java element , selection dispatch action open action ) { dcnl final boolean is method abstract [ ] = new boolean [ 1 ] ;
final array list < i java element > links = new array list < > ( ) ; dcnl i runnable with progress runnable ; dcnl dcnl if ( java element instanceof i method ) { dcnl i method method = ( i method ) java element ; dcnl try { dcnl if ( cannot be overridden method ( method ) ) { dcnl open action . run ( new structured selection ( method ) ) ; dcnl return ;
} catch ( java model exception e ) { dcnl java plugin . log ( e ) ;
i type root editor input = editor utility . get editor input java element ( editor , false ) ;
compilation unit ast = shared ast provider . get ast ( editor input , shared ast provider . wait active only , null ) ; dcnl if ( ast = = null ) { dcnl open quick hierarchy ( editor ) ;
ast node node = node finder . perform ( ast , region . get offset ( ) , region . get length ( ) ) ; dcnl i type binding parent type binding = null ; dcnl if ( node instanceof simple name ) { dcnl ast node parent = node . get parent ( ) ; dcnl if ( parent instanceof method invocation ) { dcnl expression expression = ( ( method invocation ) parent ) . get expression ( ) ; dcnl if ( expression = = null ) { dcnl parent type binding = bindings . get binding of parent type ( node ) ; dcnl } else { dcnl parent type binding = expression . resolve type binding ( ) ; dcnl } dcnl } else if ( parent instanceof super method invocation ) { dcnl / / directly go to the super method definition dcnl open action . run ( new structured selection ( method ) ) ; dcnl return ; dcnl } else if ( parent instanceof method declaration ) {
} dcnl final i type receiver type = parent type binding ! = null ? ( i type ) parent type binding . get java element ( ) : null ; dcnl if ( receiver type = = null ) { dcnl open quick hierarchy ( editor ) ;
runnable = new i runnable with progress ( ) {
@ override dcnl public void run ( i progress monitor monitor ) throws invocation target exception , interrupted exception { dcnl if ( monitor = = null ) { dcnl monitor = new null progress monitor ( ) ; dcnl } dcnl try { dcnl string method label = java element labels . get element label ( method , java element labels . default qualified ) ; dcnl monitor . begin task ( messages . format ( java editor messages . java element implementation hyperlink search method implementors , method label ) , 10 ) ; dcnl search requestor requestor = new search requestor ( ) { dcnl @ override dcnl public void accept search match ( search match match ) throws core exception { dcnl if ( match . get accuracy ( ) = = search match . a accurate ) { dcnl object element = match . get element ( ) ; dcnl if ( element instanceof i method ) { dcnl i method method found = ( i method ) element ; dcnl if ( ! jdt flags . is abstract ( method found ) ) { dcnl links . add ( method found ) ; dcnl if ( links . size ( ) > 1 ) { dcnl throw new operation canceled exception ( dummy string ) ; dcnl }
} ; dcnl dcnl i java search scope hierarchy scope ; dcnl if ( receiver type . is interface ( ) ) { dcnl hierarchy scope = search engine . create hierarchy scope ( method . get declaring type ( ) ) ; dcnl } else { dcnl if ( is full hierarchy needed ( new sub progress monitor ( monitor , 3 ) , method , receiver type ) ) dcnl hierarchy scope = search engine . create hierarchy scope ( receiver type ) ; dcnl else { dcnl is method abstract [ 0 ] = jdt flags . is abstract ( method ) ; dcnl hierarchy scope = search engine . create strict hierarchy scope ( null , receiver type , true , !is method abstract [ 0 ] , null ) ; dcnl }
int limit to = i java search constants . declarations | i java search constants . ignore declaring type | i java search constants . ignore return type ; dcnl search pattern pattern = search pattern . create pattern ( method , limit to ) ; dcnl assert . is not null ( pattern ) ; dcnl search participant [ ] participants = new search participant [ ] { search engine . get default search participant ( ) } ; dcnl search engine engine = new search engine ( ) ; dcnl engine . search ( pattern , participants , hierarchy scope , requestor , new sub progress monitor ( monitor , 7 ) ) ; dcnl if ( monitor . is canceled ( ) ) { dcnl throw new operation canceled exception ( ) ;
} catch ( core exception e ) { dcnl throw new invocation target exception ( e ) ; dcnl } finally { dcnl monitor . done ( ) ;
} dcnl } ;
} else if ( java element instanceof i type ) { dcnl i type type = ( i type ) java element ; dcnl runnable = new i runnable with progress ( ) { dcnl dcnl @ override dcnl public void run ( i progress monitor monitor ) throws invocation target exception , interrupted exception { dcnl if ( monitor = = null ) { dcnl monitor = new null progress monitor ( ) ; dcnl } dcnl try { dcnl string type label = java element labels . get element label ( type , java element labels . default qualified ) ; dcnl monitor . begin task ( messages . format ( java editor messages . java element implementation hyperlink search method implementors , type label ) , 10 ) ; dcnl links . add all ( arrays . as list ( type . new type hierarchy ( monitor ) . get all subtypes ( type ) ) ) ; dcnl if ( monitor . is canceled ( ) ) { dcnl throw new operation canceled exception ( ) ; dcnl } dcnl } catch ( core exception e ) { dcnl throw new invocation target exception ( e ) ; dcnl } finally { dcnl monitor . done ( ) ;
} ; dcnl dcnl } else { dcnl return ; dcnl }
messages . format ( java editor messages . java element implementation hyperlink error status message , java element . get element name ( ) ) , e . get cause ( ) ) ;
if ( links . is empty ( ) & & ( java element instanceof i method & & is method abstract [ 0 ] | | java element instanceof i type ) ) { dcnl open action . run ( new structured selection ( java element ) ) ; dcnl } else if ( links . size ( ) = = 1 ) {
} else {
* copyright ( c ) 2009 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . ui . javaeditor . java element hyperlink implementation detector ;
* the action allows to open the implementation for a method or a type in its hierarchy .
* i method < / code > or < code > i type < / code > .
if ( element = = null | | ! java element hyperlink implementation detector . can open implementation ( element ) ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ / tests names = new string [ ] { "test bug506888c" } ;
this . run conform test (
" - - - - - - - - - - \ n" + dcnl "1 . info in x . java ( at line 3 ) \ n" + dcnl " @ suppress warnings ( { \ "unchecked \ " , \ "unused \ " } ) \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " at least one of the problems in category \ 'unchecked \ ' is not analysed due to a compiler option being ignored \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "2 . error in x . java ( at line 3 ) \ n" + dcnl " @ suppress warnings ( { \ "unchecked \ " , \ "unused \ " } ) \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " unnecessary @ suppress warnings ( \ "unused \ " ) \ n" +
expected problem attributes . put ( " problem not analysed" , new problem attributes ( categorized problem . cat internal ) ) ;
if ( token irritants ! = null ) { dcnl if ( !token irritants . are all set ( ) / / no complaint against @ suppress warnings ( "all" ) dcnl & & ( found irritants [ i suppress ] = = null | | !found irritants [ i suppress ] . is any set ( token irritants ) ) ) { / / if irritant had no matching problem dcnl if ( unused warning token is warning ) { dcnl int start = value . source start , end = value . source end ; dcnl next suppress : for ( int j suppress = i suppress - 1 ; j suppress > = 0 ; j suppress - - ) { dcnl long position = this . suppress warning scope positions [ j suppress ] ; dcnl int start suppress = ( int ) ( position > > > 32 ) ; dcnl int end suppress = ( int ) position ; dcnl if ( start < start suppress ) continue next suppress ; dcnl if ( end > end suppress ) continue next suppress ; dcnl if ( this . suppress warning irritants [ j suppress ] . are all set ( ) ) break pair loop ; / / suppress all ? dcnl } dcnl } dcnl int id = options . get ignored irritant ( token irritants ) ; dcnl if ( id > 0 ) { dcnl string key = compiler options . option key from irritant ( id ) ; dcnl this . scope . problem reporter ( ) . problem not analysed ( inits [ i token ] , key ) ; dcnl } else { dcnl this . scope . problem reporter ( ) . unused warning token ( inits [ i token ] ) ;
case i problem . problem not analysed : dcnl return problem severities . info ; / / not configurable
import org . eclipse . jdt . core . tests . model . java9 element tests ;
import org . eclipse . jdt . core . tests . model . module builder tests ;
string log 18 = dcnl " - - - - - - - - - - \ n" + dcnl "1 . error in x . java ( at line 3 ) \ n" + dcnl " new x < > ( ) { \ n" + dcnl " ^ \ n" + dcnl " \ ' < > \ ' cannot be used with anonymous classes \ n" + dcnl " - - - - - - - - - - \ n" ; dcnl string log 9 = dcnl " - - - - - - - - - - \ n" + dcnl "1 . error in x . java ( at line 4 ) \ n" + dcnl " void new method ( ) { \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " the method new method ( ) of type new x < object > ( ) { } must override or implement a supertype method \ n" + dcnl " - - - - - - - - - - \ n" ; dcnl string error msg = this . compliance level < class file constants . jdk9 ? log 18 : log 9 ;
error msg ) ;
string log 18 = dcnl " - - - - - - - - - - \ n" + dcnl "1 . warning in x . java ( at line 3 ) \ n" + dcnl " x test = new x < > ( ) { \ n" + dcnl " ^ \ n" + dcnl "x is a raw type . references to generic type x < t > should be parameterized \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "2 . error in x . java ( at line 3 ) \ n" + dcnl " x test = new x < > ( ) { \ n" + dcnl " ^ \ n" + dcnl " \ ' < > \ ' cannot be used with anonymous classes \ n" + dcnl " - - - - - - - - - - \ n" ; dcnl string log 9 = dcnl " - - - - - - - - - - \ n" + dcnl "1 . warning in x . java ( at line 3 ) \ n" + dcnl " x test = new x < > ( ) { \ n" + dcnl " ^ \ n" + dcnl "x is a raw type . references to generic type x < t > should be parameterized \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "2 . error in x . java ( at line 3 ) \ n" + dcnl " x test = new x < > ( ) { \ n" + dcnl " void new method ( ) { \ n" + dcnl " } \ n" + dcnl " } . test function ( \ "success \ " ) ; \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " type mismatch : cannot convert from void to x \ n" + dcnl " - - - - - - - - - - \ n" + dcnl "3 . error in x . java ( at line 4 ) \ n" + dcnl " void new method ( ) { \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " the method new method ( ) of type new x < object > ( ) { } must override or implement a supertype method \ n" + dcnl " - - - - - - - - - - \ n" ; dcnl string error msg = this . compliance level < class file constants . jdk9 ? log 18 : log 9 ;
error msg ) ;
this . compliance level < class file constants . jdk9 ?
" - - - - - - - - - - \ n" : dcnl " - - - - - - - - - - \ n" + dcnl "1 . error in x . java ( at line 6 ) \ n" + dcnl " void new method ( ) { \ n" + dcnl " ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ ^ \ n" + dcnl " the method new method ( ) of type new x < object > . x2 < object > ( ) { } must override or implement a supertype method \ n" + dcnl " - - - - - - - - - - \ n" ) ;
string [ ] test files = new string [ ] {
string [ ] test files = new string [ ] {
} ; dcnl if ( this . compliance level < class file constants . jdk9 ) { dcnl this . run conform test ( dcnl test files ,
annotated type . first bound = first bound ;
annotated type . superclass = superclass ;
import org . eclipse . jdt . internal . ui . preferences . formatter . formatter profile store ;
import org . eclipse . jdt . internal . compiler . impl . irritant set ;
import org . eclipse . jdt . core . java core ;
import org . eclipse . jdt . core . compiler . categorized problem ;
import org . eclipse . jdt . internal . compiler . compilation result ;
import org . eclipse . jdt . internal . compiler . i compiler requestor ;
import org . eclipse . jdt . internal . compiler . impl . irritant set ;
enable all warnings for irritants ( options , irritant set . unused ) ;
enable all warnings for irritants ( options , irritant set . unused ) ;
enable all warnings for irritants ( options , irritant set . unused ) ;
enable all warnings for irritants ( custom options , irritant set . null ) ;
enable all warnings for irritants ( custom options , irritant set . null ) ;
enable all warnings for irritants ( custom options , irritant set . null ) ;
enable all warnings for irritants ( custom options , irritant set . null ) ;
enable all warnings for irritants ( custom options , irritant set . null ) ;
" at least one of the problems in category 'unused' is not analysed due to a compiler option being ignored \ n" +
expected problem attributes . put ( " unused constructor declared thrown exception" , new problem attributes ( java core . compiler pb unused declared thrown exception ) ) ;
import org . eclipse . jdt . internal . compiler . impl . irritant set ;
return option report unused declared thrown exception ;
* copyright ( c ) 2009 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . debug . core . model . jdi value ;
case i problem . problem not analysed :
* copyright ( c ) 2005 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
merged info . merge definite inits with ( inits when false . unconditional copy ( ) ) ; dcnl
merged info . merge definite inits with ( inits when true . unconditional copy ( ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
public unconditional flow info merge definite inits with ( unconditional flow info other inits ) { dcnl if ( ( other inits . tag bits & unreachable or dead ) ! = 0 & & this ! = dead end ) { dcnl if ( coverage test flag ) { dcnl if ( coverage test id = = 28 ) { dcnl throw new assertion failed exception ( "coverage 28" ) ; / / $non - nls - 1$ dcnl } dcnl } dcnl return this ; dcnl } dcnl if ( ( this . tag bits & unreachable or dead ) ! = 0 ) { dcnl if ( coverage test flag ) { dcnl if ( coverage test id = = 29 ) { dcnl throw new assertion failed exception ( "coverage 29" ) ; / / $non - nls - 1$ dcnl } dcnl } dcnl return ( unconditional flow info ) other inits . copy ( ) ; / / make sure other inits won't be affected dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
i java line breakpoint bp1 = create conditional line breakpoint ( 17 , type name , "return true" , true ) ;
import org . eclipse . core . runtime . path ;
dcnl private void create type plus ( string folder , string pack , string type name , string plus , boolean is class , boolean create folder ) throws core exception { dcnl string file path ; dcnl string file content ; dcnl file content = "package " + pack + " ; \ n" + "public " + ( is class ? "class " : "interface " ) ; dcnl if ( plus ! = null ) file content = file content + plus ; dcnl file content = file content + type name + " { } \ n" ; dcnl if ( create folder ) create folder ( folder + pack ) ; dcnl file path = folder + pack + " / " + type name + " . java" ; dcnl create file ( file path , file content ) ; dcnl } dcnl dcnl private void create type ( string folder , string pack , string type name ) throws core exception { dcnl create type plus ( folder , pack , type name , null , true / * is class * / , true / * create folder * / ) ; dcnl } dcnl
public void test486988 0015 ( ) throws exception { dcnl i java project project1 = create java project ( " completion9 1" , new string [ ] { "src" } , new string [ ] { "jcl18 lib" } , "bin" , "9" ) ; dcnl i java project project2 = create java project ( " completion9 2" , new string [ ] { "src" } , new string [ ] { "jcl18 lib" } , "bin" , "9" ) ; dcnl try { dcnl project1 . open ( null ) ; dcnl create type ( " / completion9 1 / src / " , "pack11" , "x11" ) ; dcnl create type ( " / completion9 1 / src / " , "pack11 . packinternal" , "z11" ) ; dcnl create type plus ( " / completion9 1 / src / " , "pack11 . packinternal" , "z12" , "implements pack22 . i22" , true / * is class * / , false / * create folder * / ) ; dcnl create type ( " / completion9 1 / src / " , "pack12" , "x12" ) ; dcnl create type plus ( " / completion9 1 / src / " , "pack12" , "y12" , "implements pack22 . i22" , true / * is class * / , false / * create folder * / ) ; dcnl string file path1 = " / completion9 1 / src / module - info . java" ; dcnl string complete behind = "with p" ; dcnl string file content1 = "module first { \ n" dcnl + "requires second ; \ n" dcnl + "provides pack22 . i22 " + complete behind dcnl + " } \ n" ; dcnl create file ( file path1 , file content1 ) ; dcnl add classpath entry ( project1 , java core . new container entry ( new path ( "org . eclipse . jdt . module path" ) ) ) ;
import java . util . list ;
import org . eclipse . core . runtime . core exception ;
import org . eclipse . jdt . core . i java element ;
import org . eclipse . jdt . core . search . i java search scope ; dcnl import org . eclipse . jdt . core . search . search engine ; dcnl import org . eclipse . jdt . core . search . search match ; dcnl import org . eclipse . jdt . core . search . search participant ; dcnl import org . eclipse . jdt . core . search . search pattern ; dcnl import org . eclipse . jdt . core . search . search requestor ;
import org . eclipse . jdt . internal . core . searchable environment ;
import org . eclipse . jdt . internal . core . search . basic search engine ;
i module context module context = ( ) - > { dcnl return stream . of ( ( java project ) this . java project ) ; dcnl } ; dcnl
if ( implementation instanceof completion on provides implementations single type reference | | dcnl implementation instanceof completion on provides implementations qualified type reference ) {
find implementations ( this . module declaration , i ) ;
find packages in current module ( ) ; dcnl } dcnl dcnl private void find packages in current module ( ) { dcnl this . name environment . find packages ( char operation . to lower case ( this . completion token ) , this , this . module context ) ;
reference instanceof completion on provides interfaces qualified type reference ) {
} else {
this . completion token = last token ! = null & & last token . length = = 0 ? dcnl char operation . concat ( type name , new char [ ] { ' . ' } ) : last token ; dcnl }
import org . eclipse . jdt . core . compiler . char operation ;
public string to string ( int tab ) { dcnl string buffer result = new string buffer ( tab string ( tab ) ) ; dcnl result . append ( " recovered module : \ n" ) ; / / $non - nls - 1$ dcnl result . append ( "module " ) ; / / $non - nls - 1$ dcnl result . append ( char operation . char to string ( ( ( module declaration ) this . type declaration ) . module name ) ) ; dcnl result . append ( " { " ) ; / / $non - nls - 1$ dcnl if ( this . export count > 0 ) { dcnl for ( int i = 0 ; i < this . export count ; + + i ) { dcnl result . append ( " \ n" ) ; / / $non - nls - 1$ dcnl result . append ( this . exports [ i ] . to string ( tab + 1 ) ) ; dcnl } dcnl } dcnl if ( this . requires count > 0 ) { dcnl for ( int i = 0 ; i < this . requires count ; + + i ) { dcnl result . append ( " \ n" ) ; / / $non - nls - 1$ dcnl result . append ( "requires " ) ; / / $non - nls - 1$ dcnl result . append ( this . requires [ i ] . to string ( tab + 1 ) ) ; dcnl } dcnl } dcnl if ( this . uses count > 0 ) { dcnl for ( int i = 0 ; i < this . uses count ; + + i ) { dcnl result . append ( " \ n" ) ; / / $non - nls - 1$ dcnl result . append ( "uses " ) ; / / $non - nls - 1$ dcnl result . append ( this . uses [ i ] . to string ( tab + 1 ) ) ; dcnl } dcnl } dcnl if ( this . services count > 0 ) { dcnl for ( int i = 0 ; i < this . services count ; + + i ) { dcnl result . append ( " \ n" ) ; / / $non - nls - 1$ dcnl result . append ( "provides " ) ; / / $non - nls - 1$ dcnl result . append ( this . interfaces [ i ] . to string ( tab + 1 ) ) ; dcnl result . append ( " with " ) ; / / $non - nls - 1$ dcnl result . append ( this . implementations [ i ] . to string ( tab + 1 ) ) ; dcnl } dcnl } dcnl result . append ( " \ n } " ) ; / / $non - nls - 1$ dcnl return result . to string ( ) ; dcnl }
update requires ( module declaration ) ;
import org . eclipse . jdt . core . i field ; dcnl import org . eclipse . jdt . core . i initializer ;
import org . eclipse . jdt . core . i method ;
dcnl private class selector implements i java element requestor { dcnl public list < i package fragment > pkg fragments ; dcnl string module name ; dcnl dcnl public selector ( string module name ) { dcnl this . pkg fragments = new array list < > ( ) ; dcnl this . module name = module name ! = null & & module name . length ( ) ! = 0 ? module name : null ; dcnl } dcnl dcnl @ override dcnl public void accept field ( i field field ) { dcnl / / do nothing dcnl } dcnl dcnl @ override dcnl public void accept initializer ( i initializer initializer ) { dcnl / / do nothing dcnl } dcnl dcnl @ override dcnl public void accept member type ( i type type ) { dcnl / / do nothing dcnl } dcnl dcnl @ override dcnl public void accept method ( i method method ) { dcnl / / do nothing dcnl } dcnl dcnl @ override dcnl public void accept package fragment ( i package fragment package fragment ) { dcnl this . pkg fragments . add ( package fragment ) ; dcnl } dcnl dcnl @ override dcnl public void accept type ( i type type ) { dcnl / / do nothing dcnl } dcnl dcnl @ override dcnl public void accept module ( i module description module ) { dcnl / / do nothing dcnl } dcnl dcnl @ override dcnl public boolean is canceled ( ) { dcnl / / todo auto - generated method stub dcnl return false ; dcnl } dcnl }
throw new io exception ( e ) ;
throw new io exception ( e ) ;
throw new io exception ( e ) ;
throw new io exception ( e ) ;
throw new build exception ( ant adapter messages . get string ( "check debug attributes . file . argument . must . be . a . classfile . or . a . jarfile" ) , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( this . main . bind ( "configure . cannot open log" , log file name ) , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( this . main . bind ( "configure . cannot open log invalid encoding" , log file name ) , e ) ; / / $non - nls - 1$
this . bind ( "configure . unsupported encoding" , custom encoding ) , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( this . bind ( "configure . repetition" , current arg ) , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( this . bind ( "configure . max problems" , current arg ) , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( e ) ;
throw new illegal argument exception ( e ) ;
throw new illegal argument exception ( e ) ;
throw new illegal argument exception ( e ) ;
throw new illegal argument exception ( e ) ;
throw new illegal argument exception ( element + " does not exist" , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( " alignment value is not an integer : " + value , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( " alignment value is not an integer : " + value , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( " alignment value is not an integer : " + value , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( " alignment value is not an integer : " + value , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( " alignment value is not an integer : " + value , e ) ; / / $non - nls - 1$
throw new illegal argument exception ( e ) ;
throw new illegal argument exception ( e ) ;
throw new io exception ( messages . file bad format , e ) ;
throw new io exception ( messages . file bad format , e ) ;
* copyright ( c ) 2003 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
valid line [ 0 ] = locator . get line location ( ) ;
* copyright ( c ) 2008 , 2016 ibm corporation and others .
if ( locator . get fully qualified type name ( ) = = null ) dcnl throw new core exception ( status . cancel status ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jface . resource . color registry ;
if ( this . arguments ! = null & & this . arguments . length > 0 & & !is raw type ( ) ) { / / empty arguments array happens when ptb has been created just to capture type annotations
import org . eclipse . jdt . internal . core . nd . indexer . indexer ; dcnl
indexer . get instance ( ) . wait for index ( null ) ;
import java . io . file not found exception ;
bad format , unable to read , file not found , valid ;
* @ exception core exception if unable to create / open the zip file . the dcnl * cause will be a { @ link zip exception } if the file was corrupt , a dcnl * { @ link file not found exception } if the file does not exist , or a dcnl * { @ link io exception } if we were unable to read the file .
public zip file get zip file ( i path path , boolean check invalid archive cache ) throws core exception {
archive validity reason ; dcnl dcnl if ( e instanceof zip exception ) { dcnl reason = archive validity . bad format ; dcnl } else if ( e instanceof file not found exception ) { dcnl reason = archive validity . file not found ; dcnl } else { dcnl reason = archive validity . unable to read ; dcnl }
import java . io . file not found exception ;
int result = 0 ;
if ( fingerprint . file exists ( ) ) { dcnl result = add element ( resource file , element , sub monitor . split ( 50 ) ) ; dcnl }
} catch ( file not found exception e ) { dcnl fingerprint = file fingerprint . get empty ( ) ; dcnl } dcnl dcnl if ( debug & & !fingerprint . file exists ( ) ) { dcnl package . log ( "the file " + path string + " was not indexed because it does not exist" , null ) ; / / $non - nls - 1$ / / $non - nls - 2$
* @ throws file not found exception if the file does not exist
throws java model exception , file not found exception {
} catch ( file not found exception e ) { dcnl throw e ;
import java . io . file not found exception ;
import java . io . input stream ;
import org . eclipse . core . resources . i resource status ;
import org . eclipse . core . runtime . i status ;
public static i binary type read type ( binary type descriptor descriptor , i progress monitor monitor ) throws java model exception , class format exception { dcnl
public static class file reader raw read type ( binary type descriptor descriptor , boolean fully initialize ) throws java model exception , class format exception { dcnl try { dcnl return raw read type test for exists ( descriptor , fully initialize , true ) ; dcnl } catch ( file not found exception e ) { dcnl throw new java model exception ( e , i java model status constants . io exception ) ; dcnl } dcnl } dcnl
* @ throws file not found exception if the file does not exist
public static class file reader raw read type test for exists ( binary type descriptor descriptor , boolean fully initialize , dcnl boolean use invalid archive cache ) throws java model exception , class format exception , file not found exception {
zip = java model manager . get java model manager ( ) . get zip file ( new path ( new string ( descriptor . workspace path ) ) , dcnl use invalid archive cache ) ;
method binding original = original ( ) ; dcnl if ( original = = null ) { dcnl return ; dcnl }
if ( !original . parameters [ i ] . accepts non null default ( ) )
boolean generate parts ;
unicode resource generator ( string [ ] args , boolean do part ) {
this . generate parts = do part ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ / tags inhibiting inline tags dcnl static final string tag code = "code" ; dcnl static final string tag literal = "literal" ;
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 dcnl / / when parsing tags such as @ code and @ literal , dcnl / / any tag should be discarded and considered as plain text until dcnl / / properly closed with closing brace dcnl boolean consider tag as plain text = false ; dcnl int opening braces = 0 ;
if ( tag . equals ignore case ( tag literal ) | | tag . equals ignore case ( tag code ) ) consider tag as plain text = true ;
if ( !line started ) {
} else if ( previous char = = ' { ' ) { dcnl / / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 dcnl if ( consider tag as plain text ) { dcnl opening braces + + ; dcnl } else { dcnl tag = "" ; dcnl line started = true ; dcnl }
case ' } ' : dcnl / / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 dcnl if ( consider tag as plain text ) { dcnl if ( opening braces > 0 ) { dcnl opening braces - - ; dcnl } else { dcnl consider tag as plain text = false ; dcnl } dcnl } dcnl break ;
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 dcnl if ( ! ( tag code . equals ignore case ( tag name ) | | !tag literal . equals ignore case ( tag name ) ) & & tag element . is nested ( ) ) {
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 dcnl / / when parsing tags such as @ code and @ literal , dcnl / / any tag should be discarded and considered as plain text until dcnl / / properly closed with closing brace dcnl boolean consider tag as plain text = false ; dcnl / / internal counter for opening braces dcnl int opening braces = 0 ;
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 : ignore all tags when inside @ literal or @ code tags dcnl if ( consider tag as plain text ) { dcnl / / new tag found dcnl if ( !this . line started ) { dcnl / / we may want to report invalid syntax when no closing brace found , dcnl / / or when incoherent number of closing braces found dcnl if ( opening braces > 0 & & this . report problems ) { dcnl this . source parser . problem reporter ( ) . javadoc unterminated inline tag ( this . inline tag start , invalid inline tag line end ) ; dcnl } dcnl consider tag as plain text = false ; dcnl this . inline tag started = false ; dcnl opening braces = 0 ; dcnl } dcnl } else if ( ( !this . line started | | previous char = = ' { ' ) ) {
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 dcnl / / dealing with @ literal or @ code tags : ignore next tags dcnl if ( !is formatter parser & & ( this . tag value = = tag literal value | | this . tag value = = tag code value ) ) { dcnl consider tag as plain text = true ; dcnl opening braces + + ; dcnl }
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 : when ignoring tags , only decrement the opening braces counter dcnl if ( consider tag as plain text ) { dcnl invalid inline tag line end = this . line end ; dcnl if ( - - opening braces = = 0 ) { dcnl consider tag as plain text = false ; / / re - enable tag validation dcnl } dcnl }
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 : do not push text yet if ignoring tags dcnl if ( !consider tag as plain text ) { dcnl if ( this . line started & & this . text start ! = - 1 & & this . text start < text end position ) { dcnl push text ( this . text start , text end position ) ; dcnl } dcnl refresh inline tag position ( previous position ) ;
if ( !is formatter parser & & !consider tag as plain text ) dcnl this . text start = this . index ;
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 : count opening braces when ignoring tags dcnl if ( consider tag as plain text ) { dcnl opening braces + + ; dcnl } else if ( this . inline tag started ) {
/ / https : / / bugs . eclipse . org / bugs / show bug . cgi ? id = 206345 : do not update tag start position when ignoring tags dcnl if ( !consider tag as plain text ) this . inline tag start = previous position ;
* copyright ( c ) 2004 , 2016 ibm corporation and others .
} else if ( length = = tag code length & & char operation . equals ( tag code , tag name ) ) { dcnl this . tag value = tag code value ; dcnl create tag ( ) ;
} else if ( length = = tag literal length & & char operation . equals ( tag literal , tag name ) ) { dcnl this . tag value = tag literal value ;
dcnl if ( this . tag value ! = no tag value & & this . tag value ! = tag literal value ) {
public static final int max malloc size = max block deltas * block size delta - block header size ;
this . f chunks used = this . f chunks . length ;
this . f chunks used = n chunks on disk ;
this . f chunks used = this . f chunks . length ;
freeblock = create new chunks ( 1 ) ;
private long create new chunks ( int num chunks ) throws index exception {
final int first chunk index = this . f chunks used ; dcnl final int last chunk index = first chunk index + num chunks - 1 ; dcnl dcnl final chunk last chunk = new chunk ( this , last chunk index ) ; dcnl last chunk . f dirty = true ; dcnl dcnl if ( last chunk index > = this . f chunks . length ) { dcnl int increment = math . max ( 1024 , this . f chunks . length / 20 ) ; dcnl int new num chunks = math . max ( last chunk index + 1 , this . f chunks . length + increment ) ; dcnl chunk [ ] new chunks = new chunk [ new num chunks ] ; dcnl system . arraycopy ( this . f chunks , 0 , new chunks , 0 , this . f chunks . length ) ; dcnl this . f chunks = new chunks ;
this . f chunks used = last chunk index + 1 ; dcnl this . f chunks [ last chunk index ] = last chunk ; dcnl this . f cache . add ( last chunk , true ) ; dcnl long result = ( long ) first chunk index * chunk size ;
long end address = result + ( num chunks * chunk size ) ; dcnl if ( end address > max db size ) {
nls . bind ( " database too large! address = " + end address + " , max size = " + max db size , / / $non - nls - 1$ / / $non - nls - 2$ dcnl bindings ) , null ) ) ;
return result ;
*
import java . io . byte array input stream ;
import java . nio . charset . standard charsets ;
public void test folder delete linked deleted on filesystem undo redo ltk ( ) throws execution exception , core exception { dcnl refactoring contribution delete contribution = refactoring core . get refactoring contribution ( delete resources descriptor . id ) ; dcnl delete resources descriptor desc = ( delete resources descriptor ) delete contribution . create descriptor ( ) ; dcnl desc . set resource paths ( new i path [ ] { test linked folder . get full path ( ) } ) ; dcnl dcnl perform refactoring operation op = new perform refactoring operation ( dcnl desc . create refactoring context ( new refactoring status ( ) ) , dcnl check conditions operation . all conditions ) ; dcnl dcnl folder snapshot snap = new folder snapshot ( test linked folder ) ; dcnl dcnl / / create a subfolder containing a file under the linked folder . dcnl i folder subfolder = test linked folder . get folder ( "a" ) ; dcnl subfolder . create ( true , true , get monitor ( ) ) ; dcnl i file file = subfolder . get file ( "test . txt" ) ; dcnl file . create ( new byte array input stream ( "test contents" . get bytes ( standard charsets . utf 8 ) ) , true , get monitor ( ) ) ; dcnl / / delete the target of the linked folder on the file system making the linked folder out of sync dcnl / / with the file system . dcnl i file store folder store = efs . get store ( test linked folder . get location uri ( ) ) ; dcnl folder store . delete ( efs . none , get monitor ( ) ) ; / / delete the target folder on the file system . dcnl dcnl execute ( op ) ; dcnl assert false ( " folder delete failed" , test linked folder . exists ( ) ) ; dcnl undo ( ) ; dcnl assert true ( " folder recreation failed" , test linked folder . exists ( ) ) ; dcnl assert true ( " folder content was altered on undo" , snap . is valid ( test linked folder . get parent ( ) ) ) ; dcnl redo ( ) ; dcnl assert false ( " redo delete failed" , test linked folder . exists ( ) ) ; dcnl } dcnl
import java . util . array list ; dcnl import java . util . list ;
private list < abstract resource undo state > members ;
members = new array list < > ( resource members . length ) ; dcnl for ( i resource resource member : resource members ) { dcnl / / add a member only if its container exists on disk or if the member is a linked resource . dcnl / / otherwise avoid wasting time . see http : / / bugs . eclipse . org / 508260 dcnl if ( local time stamp ! = i resource . null stamp | | resource member . is linked ( ) ) { dcnl members . add ( ( abstract resource undo state ) resource undo state . from resource ( resource member ) ) ; dcnl }
if ( members ! = null ) { dcnl for ( abstract resource undo state member : members ) { dcnl member . parent = parent handle ; dcnl member . create resource ( new sub progress monitor ( monitor , ticks / members . size ( ) ) ) ;
for ( abstract resource undo state member : members ) { dcnl if ( member instanceof file undo state ) { dcnl i path path = resource . get full path ( ) . append ( ( ( file undo state ) member ) . name ) ; dcnl i file file handle = resource . get workspace ( ) . get root ( ) . get file ( path ) ; dcnl member . record state from history ( file handle , dcnl new sub progress monitor ( monitor , 100 / members . size ( ) ) ) ; dcnl } else if ( member instanceof folder undo state ) { dcnl i path path = resource . get full path ( ) . append ( ( ( folder undo state ) member ) . name ) ; dcnl i folder folder handle = resource . get workspace ( ) . get root ( ) . get folder ( path ) ; dcnl member . record state from history ( folder handle , dcnl new sub progress monitor ( monitor , 100 / members . size ( ) ) ) ;
if ( members = = null | | members . is empty ( ) ) {
for ( abstract resource undo state member : members ) { dcnl if ( member instanceof container undo state ) { dcnl return ( ( container undo state ) member ) . get first leaf folder ( ) ;
members = new array list < > ( ) ;
members . add ( member ) ;
public static final j unit plugin description junit jupiter migration support plugin = new j unit plugin description ( dcnl "org . junit . jupiter . migration . support" , new version range ( " [ 1 . 0 . 0 , 2 . 0 . 0 ) " ) , "org . junit . jupiter . migration . support . jar" , "org . junit . jupiter . migration . support . jar" , "org . junit . jupiter . migration . support . source" , "source - bundle / " , / / $non - nls - 1$ / / $non - nls - 2$ / / $non - nls - 3$ / / $non - nls - 4$ / / $non - nls - 5$ / / $non - nls - 6$ dcnl j unit preferences constants . junit jupiter migration support javadoc ) ; dcnl
entries list . add ( build path support . get j unit jupiter migration support library entry ( ) ) ;
private thread write lock owner ;
while ( this . lock count > giveup read locks | | this . waiting readers > 0 | | ( this . lock count < 0 ) ) {
if ( this . write lock owner ! = null & & this . write lock owner ! = thread . current thread ( ) ) { dcnl throw new illegal state exception ( " we somehow managed to acquire a write lock while another thread already holds it . " ) ; / / $non - nls - 1$ dcnl } dcnl this . write lock owner = thread . current thread ( ) ;
sub monitor sub monitor = sub monitor . convert ( monitor , 100 ) ;
manager . delete index files ( sub monitor . split ( 3 ) ) ;
import org . eclipse . core . runtime . jobs . i scheduling rule ;
private i scheduling rule scheduling rule = new i scheduling rule ( ) { dcnl @ override dcnl public boolean is conflicting ( i scheduling rule rule ) { dcnl return rule = = this ; dcnl } dcnl dcnl @ override dcnl public boolean contains ( i scheduling rule rule ) { dcnl return rule = = this ; dcnl } dcnl } ;
this . rescan job . set rule ( this . scheduling rule ) ;
import java . util . arrays ;
import java . util . function . function ; dcnl import java . util . stream . collectors ;
/ / create an indexfa
result . add ( ( i class file ) child ) ;
import org . eclipse . jdt . debug . core . i java object ;
/ / suspend if return is boolean ( true ) else don't suspend ( no error dialog ) dcnl if ( jdi value . get java type ( ) . get name ( ) . equals ( "java . lang . boolean" ) ) { / / $non - nls - 1$ dcnl i java primitive value java value = ( i java primitive value ) ( ( i java object ) jdi value ) . get field ( "value" , false ) . get value ( ) ; / / $non - nls - 1$ dcnl if ( java value . get boolean value ( ) ) { dcnl return suspend ; dcnl }
import org . eclipse . jdt . internal . compiler . classfmt . class file reader ;
import org . eclipse . jdt . internal . compiler . env . i dependent ;
i binary type result = null ; dcnl dcnl if ( get package fragment root ( ) instanceof jar package fragment root ) { dcnl package fragment pkg = ( package fragment ) get parent ( ) ; dcnl jar package fragment root root = ( jar package fragment root ) get package fragment root ( ) ; dcnl string entry name = util . concat with ( pkg . names , get element name ( ) , ' / ' ) ; dcnl if ( root instanceof jrt package fragment root ) { dcnl byte [ ] contents = get class file content ( root , entry name ) ; dcnl if ( contents ! = null ) { dcnl string file name ; dcnl string root path = root . get path ( ) . to os string ( ) ; dcnl if ( org . eclipse . jdt . internal . compiler . util . util . is jrt ( root path ) ) { dcnl file name = root . get handle identifier ( ) + i dependent . jar file entry separator + dcnl root . get element name ( ) + i dependent . jar file entry separator + entry name ; dcnl } else { dcnl file name = root . get handle identifier ( ) + i dependent . jar file entry separator + entry name ; dcnl } dcnl result = new class file reader ( contents , file name . to char array ( ) , false ) ; dcnl } dcnl } else { dcnl result = binary type factory . read type ( descriptor , null ) ; dcnl }
/ / todo ( sxenos ) : setup the external annotation provider if the i binary type came from the index dcnl / / todo ( sxenos ) : the old code always passed null as the third argument to setup external annotation provider , dcnl / / but this looks like a bug . i've preserved it for now but we need to figure out what was supposed to go dcnl / / there .
i package fragment root root = get package fragment root ( ) ;
jar package fragment root jar root = ( jar package fragment root ) get package fragment root ( ) ;
byte [ ] contents = get class file content ( jar root , entry name ) ;
} else { dcnl result = binary type factory . read type ( descriptor , null ) ; dcnl } dcnl dcnl if ( result = = null ) { dcnl return null ; dcnl }
/ / todo ( sxenos ) : setup the external annotation provider if the i binary type came from the index dcnl / / todo ( sxenos ) : the old code always passed null as the third argument to setup external annotation provider , dcnl / / but this looks like a bug . i've preserved it for now but we need to figure out what was supposed to go dcnl / / there . dcnl if ( root . get kind ( ) = = i package fragment root . k binary ) { dcnl java project java project = ( java project ) get ancestor ( i java element . java project ) ; dcnl i classpath entry entry = java project . get classpath entry for ( get path ( ) ) ; dcnl if ( entry ! = null ) { dcnl package fragment pkg = ( package fragment ) get parent ( ) ; dcnl string entry name = util . concat with ( pkg . names , get element name ( ) , ' / ' ) ; dcnl entry name = new string ( char array utils . concat ( dcnl java names . field descriptor to binary name ( descriptor . field descriptor ) , suffix constants . suffix class ) ) ; dcnl i project project = java project . get project ( ) ; dcnl i path external annotation path = classpath entry . get external annotation path ( entry , project , false ) ; / / unresolved for use in external annotation tracker dcnl if ( external annotation path ! = null ) { dcnl result = setup external annotation provider ( project , external annotation path , null , result ,
public final class nd {
import org . eclipse . core . runtime . jobs . job group ;
private job group group = new job group ( messages . indexer updating index job name , 1 , 1 ) ;
this . rescan job . set job group ( this . group ) ;
test case . reset forgotten filters ( tests 1 3 ) ;
test case . reset forgotten filters ( tests 1 4 ) ;
test case . reset forgotten filters ( tests 1 5 ) ;
test case . reset forgotten filters ( tests 1 6 ) ;
test case . reset forgotten filters ( tests 1 7 ) ;
test case . reset forgotten filters ( tests 1 3 ) ;
test case . reset forgotten filters ( tests 1 4 ) ;
test case . reset forgotten filters ( tests 1 5 ) ;
test case . reset forgotten filters ( tests 1 6 ) ;
test case . reset forgotten filters ( tests 1 7 ) ;
import org . eclipse . jdt . internal . core . nd . indexer . indexer ;
indexer . get instance ( ) . enable automatic indexing ( false ) ;
import java . util . stream . collectors ;
linked hash set < i path > cycle participants = new linked hash set < > ( ) ;
if ( !cycle participants . is empty ( ) ) { dcnl string cycle string = cycle participants . stream ( ) dcnl . map ( path - > workspace root . find member ( path ) ) dcnl . filter ( r - > r ! = null ) dcnl . map ( r - > java core . create ( ( i project ) r ) ) dcnl . filter ( p - > p ! = null ) dcnl . map ( p - > p . get element name ( ) ) dcnl . collect ( collectors . joining ( " , " ) ) ; / / $non - nls - 1$ dcnl dcnl for ( int i = 0 ; i < length ; i + + ) { dcnl java project project = projects [ i ] ; dcnl if ( project ! = null ) { dcnl if ( cycle participants . contains ( project . get path ( ) ) ) { dcnl i marker cycle marker = project . get cycle marker ( ) ; dcnl string circular cp option = project . get option ( java core . core circular classpath , true ) ; dcnl int circular cp severity = java core . error . equals ( circular cp option ) ? i marker . severity error : i marker . severity warning ; dcnl if ( cycle marker ! = null ) { dcnl / / update existing cycle marker if needed dcnl try { dcnl int existing severity = ( ( integer ) cycle marker . get attribute ( i marker . severity ) ) . int value ( ) ; dcnl if ( existing severity ! = circular cp severity ) { dcnl cycle marker . set attribute ( i marker . severity , circular cp severity ) ; dcnl } dcnl string existing message = cycle marker . get attribute ( i marker . message , "" ) ; dcnl string new message = new java model status ( i java model status constants . classpath cycle , dcnl project , cycle string ) . get message ( ) ; dcnl if ( !new message . equals ( existing message ) ) { dcnl cycle marker . set attribute ( i marker . message , new message ) ;
} catch ( core exception e ) { dcnl throw new java model exception ( e ) ;
} else { dcnl / / create new marker dcnl project . create classpath problem marker ( dcnl new java model status ( i java model status constants . classpath cycle , project , cycle string ) ) ;
"import java . lang . annotation . annotation ; \ n" +
" system . out . print ( \ "y1 : \ " + normalize annotation ( y1 . class . get annotation ( attr . class ) ) + \ " \ \ n \ " ) ; \ n" + dcnl " system . out . print ( \ "y2 : \ " + normalize annotation ( y2 . class . get annotation ( attr . class ) ) + \ " \ \ n \ " ) ; \ n" + dcnl " system . out . print ( \ "y1 : \ " + normalize annotation ( y1 . class . get annotation ( attr container . class ) ) + \ " \ \ n \ " ) ; \ n" + dcnl " system . out . print ( \ "y2 : \ " + normalize annotation ( y2 . class . get annotation ( attr container . class ) ) + \ " \ \ n \ " ) ; \ n" + dcnl " } \ n" + dcnl " static string normalize annotation ( annotation a ) { \ n" + dcnl " if ( a = = null ) return null ; \ n" + dcnl " string str = a . to string ( ) ; \ n" + dcnl " str = str . replace ( \ "value = { @ \ " , \ "value = [ @ \ " ) ; \ n" + dcnl " str = str . replace ( \ " ) } \ " , \ " ) ] \ " ) ; \ n" + dcnl " return str ; \ n" +
" system . out . print ( normalize annotation ( a ) + \ " \ " ) ; \ n" +
" system . out . print ( \ " \ \ n \ " ) ; \ n" +
" static string normalize annotation ( annotation a ) { \ n" + dcnl " if ( a = = null ) return null ; \ n" + dcnl " string str = a . to string ( ) ; \ n" + dcnl " str = str . replace ( \ "value = { @ \ " , \ "value = [ @ \ " ) ; \ n" + dcnl " str = str . replace ( \ " ) } \ " , \ " ) ] \ " ) ; \ n" + dcnl " return str ; \ n" + dcnl " } \ n" +
" system . out . print ( normalize annotation ( a ) + \ " \ " ) ; \ n" +
" system . out . print ( \ " \ \ n \ " ) ; \ n" +
" system . out . print ( \ " annotations on superclass of \ " + clazz . get name ( ) + \ " \ \ n \ " ) ; \ n" +
" system . out . print ( \ " annotations on superinterfaces of \ " + clazz . get name ( ) + \ " \ \ n \ " ) ; \ n" +
" system . out . print ( \ " > \ \ n \ " ) ; \ n" +
" s = s . replace ( \ " \ \ \ " \ " , \ " \ " ) ; \ n" + dcnl " s = s . replace ( \ "' \ " , \ " \ " ) ; \ n" +
" if ( annos . length = = 0 ) { system . out . print ( header + t + \ " : no annotations \ \ n \ " ) ; return ; } \ n" +
" system . out . print ( \ " \ \ n \ " ) ; \ n" +
import org . eclipse . jdt . internal . compiler . util . util ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
string cycle string = cycle participants . stream ( ) dcnl . map ( path - > workspace root . find member ( path ) ) dcnl . filter ( r - > r ! = null ) dcnl . map ( r - > java core . create ( ( i project ) r ) ) dcnl . filter ( p - > p ! = null ) dcnl . map ( p - > p . get element name ( ) ) dcnl . collect ( collectors . joining ( " , " ) ) ; / / $non - nls - 1$ dcnl dcnl for ( int i = 0 ; i < length ; i + + ) { dcnl java project project = projects [ i ] ; dcnl if ( project ! = null ) { dcnl if ( cycle participants . contains ( project . get path ( ) ) ) { dcnl i marker cycle marker = project . get cycle marker ( ) ; dcnl string circular cp option = project . get option ( java core . core circular classpath , true ) ; dcnl int circular cp severity = java core . error . equals ( circular cp option ) ? i marker . severity error : i marker . severity warning ; dcnl if ( cycle marker ! = null ) { dcnl / / update existing cycle marker if needed dcnl try { dcnl int existing severity = ( ( integer ) cycle marker . get attribute ( i marker . severity ) ) . int value ( ) ; dcnl if ( existing severity ! = circular cp severity ) { dcnl cycle marker . set attribute ( i marker . severity , circular cp severity ) ; dcnl } dcnl string existing message = cycle marker . get attribute ( i marker . message , "" ) ; dcnl string new message = new java model status ( i java model status constants . classpath cycle , dcnl project , cycle string ) . get message ( ) ; dcnl if ( !new message . equals ( existing message ) ) { dcnl cycle marker . set attribute ( i marker . message , new message ) ;
} catch ( core exception e ) { dcnl throw new java model exception ( e ) ;
/ / create new marker dcnl project . create classpath problem marker ( dcnl new java model status ( i java model status constants . classpath cycle , project , cycle string ) ) ;
import org . eclipse . jdt . internal . core . nd . db . database ;
public long get backpointer address ( int idx ) { dcnl return back . get address of ( get nd ( ) , this . address , idx ) ; dcnl } dcnl
public void test large block back pointer test ( ) throws exception { dcnl this . nd . get db ( ) . give up exclusive lock ( true ) ; dcnl / / allocate enough entries to cause the metablock array to resize twice dcnl int total size = database . chunk size * 0x400 ; dcnl dcnl long initial allocations = this . nd . get db ( ) . get bytes allocated ( ) - this . nd . get db ( ) . get bytes freed ( ) ; dcnl this . nd . acquire write lock ( null ) ; dcnl forward pointer struct [ ] forward pointer = new forward pointer struct [ total size ] ; dcnl for ( int idx = 0 ; idx < total size ; idx + + ) { dcnl forward pointer [ idx ] = new forward pointer struct ( this . nd ) ; dcnl forward pointer [ idx ] . set bp ( this . ba ) ; dcnl } dcnl dcnl for ( int idx = 0 ; idx < total size ; idx + + ) { dcnl assert equals ( forward pointer [ idx ] . get address ( ) , this . ba . get backpointer address ( idx ) ) ; dcnl } dcnl dcnl for ( int idx = 0 ; idx < total size ; idx + + ) { dcnl forward pointer [ idx ] . delete ( ) ; dcnl } dcnl dcnl this . nd . release write lock ( ) ; dcnl dcnl long final allocations = this . nd . get db ( ) . get bytes allocated ( ) - this . nd . get db ( ) . get bytes freed ( ) ; dcnl dcnl / / verify no memory leaks dcnl assert equals ( initial allocations , final allocations ) ; dcnl } dcnl
import org . eclipse . jdt . internal . core . nd . field . field short ;
private static class growable block header {
private static final class meta block header extends growable block header { dcnl / * * dcnl * holds the number of pages used for the metablock . note that the start of the metablock array needs to be dcnl * 4 - byte aligned . since all malloc calls are always 2 bytes away from 4 - byte alignment , we need to use at dcnl * least one short in this struct . * / dcnl public static final field short metablock num pages ; dcnl public static final int meta block header bytes ; dcnl dcnl @ suppress warnings ( "hiding" ) dcnl private static final struct def < meta block header > type ; dcnl dcnl static { dcnl type = struct def . create abstract ( meta block header . class , growable block header . type ) ; dcnl dcnl metablock num pages = type . add short ( ) ; dcnl type . done ( ) ; dcnl dcnl meta block header bytes = type . size ( ) ; dcnl } dcnl } dcnl
/ / needed block size should always be a multiple of the max block size when metablocks are in use dcnl assert needed block size % growable block header . max growable size = = 0 ; dcnl / / create extra growable blocks if necessary . dcnl int required block count = divide rounding up ( needed block size , growable block header . max growable size ) ; dcnl dcnl int needed metablock pages = compute metablock pages for blocks ( required block count ) ; dcnl dcnl if ( needed metablock pages > short . max value ) { dcnl throw new index exception ( "a metablock overflowed . unable to allocate " + needed metablock pages / / $non - nls - 1$ dcnl + " pages . " ) ; / / $non - nls - 1$ dcnl }
metablock address = db . malloc ( database . get bytes that fit in chunks ( needed metablock pages ) , dcnl database . pool growable array ) ;
meta block header . metablock num pages . put ( nd , metablock address , ( short ) needed metablock pages ) ;
db . put rec ptr ( metablock address + meta block header . meta block header bytes ,
short metablock current pages = meta block header . metablock num pages . get ( nd , metablock address ) ; dcnl if ( metablock current pages < needed metablock pages ) { dcnl short new metablock pages = ( short ) math . min ( short . max value , needed metablock pages * 1 . 5 ) ; dcnl long new metablock address = db . malloc ( database . get bytes that fit in chunks ( new metablock pages ) , dcnl database . pool growable array ) ; dcnl int old num pages = meta block header . metablock num pages . get ( nd , metablock address ) ; dcnl db . memcpy ( new metablock address , metablock address , ( int ) database . get bytes that fit in chunks ( old num pages ) ) ; dcnl db . free ( metablock address , database . pool growable array ) ; dcnl metablock address = new metablock address ; dcnl meta block header . metablock num pages . put ( nd , metablock address , new metablock pages ) ; dcnl growable block address . put ( nd , address , metablock address ) ; dcnl }
long next block address = db . malloc ( compute block bytes ( growable block header . max growable size ) , dcnl database . pool growable array ) ;
db . put rec ptr ( metablock address + meta block header . meta block header bytes
private static int divide rounding up ( int needed block size , int max growable size ) { dcnl return ( needed block size + max growable size - 1 ) / max growable size ; dcnl } dcnl dcnl private int compute metablock pages for blocks ( int required block count ) { dcnl return database . get chunks needed for bytes ( dcnl required block count * database . ptr size + growable block header . growable block header bytes ) ; dcnl } dcnl
growable block address = db . get rec ptr ( growable block address + meta block header . meta block header bytes dcnl + block * database . ptr size ) ;
long data start address = growable block address + growable block header . growable block header bytes ;
long end address = source + num bytes ; dcnl assert end address < = this . f chunks used * chunk size ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
object [ ] resources = this . non java resources ; dcnl if ( resources = = null ) { dcnl resources = compute non java resources ( ) ; dcnl this . non java resources = resources ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
object [ ] resources = this . non java resources ; dcnl if ( resources = = null ) { dcnl resources = compute non java resources ( project ) ; dcnl this . non java resources = resources ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
/ * * dcnl * a array with all the non - java resources contained by this element dcnl * / dcnl protected object [ ] non java resources ; dcnl
* copyright ( c ) 2000 , 2016 ibm corporation and others .
object [ ] resources = this . non java resources ; dcnl if ( resources = = null ) {
resources =
resources = no non java resources ;
this . non java resources = resources ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . corext . util . java model util ;
* copyright ( c ) 2013 , 2016 ibm corporation and others .
import org . eclipse . jdt . core . dom . modifier ;
* copyright ( c ) 2013 , 2016 go pivotal , inc . all rights reserved .
type annotation info [ ] type annotations = null ;
type annotation info [ ] method type annotations = null ;
} else if ( char operation . equals ( attribute name , attribute names constants . runtime visible type annotations name ) ) { dcnl method type annotations = decode type annotations ( read offset , true , method info ) ; dcnl } else if ( char operation . equals ( attribute name , attribute names constants . runtime invisible type annotations name ) ) { dcnl method type annotations = decode type annotations ( read offset , false , method info ) ;
} else if ( method type annotations ! = null ) { dcnl if ( type annotations = = null ) { dcnl type annotations = method type annotations ; dcnl } else { dcnl int length = type annotations . length ; dcnl type annotation info [ ] new annotations = new type annotation info [ length + method type annotations . length ] ; dcnl system . arraycopy ( type annotations , 0 , new annotations , 0 , length ) ; dcnl system . arraycopy ( method type annotations , 0 , new annotations , length , method type annotations . length ) ; dcnl type annotations = new annotations ; dcnl }
if ( type annotations ! = null ) dcnl return new annotation method info with type annotations ( method info , default value , annotations , type annotations ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . core . i compilation unit ;
import org . eclipse . jdt . core . i problem requestor ;
import org . eclipse . jdt . core . working copy owner ;
/ / tests names = new string [ ] { "test reconciler module lookup" } ;
protected problem requestor problem requestor ;
public void set up ( ) throws exception { dcnl super . set up ( ) ; dcnl this . problem requestor = new problem requestor ( ) ; dcnl this . wc owner = new working copy owner ( ) { dcnl public i problem requestor get problem requestor ( i compilation unit unit ) { dcnl return module builder tests . this . problem requestor ; dcnl } dcnl } ; dcnl }
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* lars vogel < lars . vogel @ vogella . com > - bug 477789
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( pm , 2 ) ; dcnl f c unit . become working copy ( sub monitor . split ( 1 ) ) ;
return super . acquire document ( sub monitor . split ( 1 ) ) ;
sub monitor sub monitor = sub monitor . convert ( pm , 2 ) ; dcnl super . release document ( document , sub monitor . split ( 1 ) ) ;
sub monitor . split ( 1 , sub monitor . suppress begintask | sub monitor . suppress iscanceled ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( pm , 2 ) ; dcnl f c unit . become working copy ( sub monitor . split ( 1 ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , corext messages . java model util applyedit operation , 2 ) ;
cu . apply text edit ( edit , sub monitor . split ( 2 ) ) ;
i status status = resources . make committable ( file , null ) ; dcnl if ( !status . is ok ( ) ) { dcnl throw new validate edit exception ( status ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , 10 ) ;
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , java ui messages . type selection dialog progress consistency , 10 ) ; dcnl refresh search indices ( sub monitor . split ( 9 ) ) ; dcnl history . check consistency ( sub monitor . split ( 1 ) ) ;
sub monitor sub monitor = sub monitor . convert ( monitor , java ui messages . type selection dialog progress consistency , 10 ) ;
runnable . run ( sub monitor . split ( 1 ) ) ;
remaining monitor = sub monitor . split ( 8 ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , java ui messages . package selection dialog progress search , hide empty ? 2 : 1 ) ;
new search engine ( ) . search ( pattern , search utils . get default search participants ( ) , f scope , requestor , sub monitor . split ( 1 ) ) ;
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , messages . format ( search messages . java search query task label , string pattern ) , total ticks ) ;
engine . search ( pattern , new search participant [ ] { search engine . get default search participant ( ) } , get first specification ( ) . get scope ( ) , collector , sub monitor . split ( 1000 ) ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . core . runtime . sub monitor ;
sub monitor sub monitor = sub monitor . convert ( monitor , messages . format ( java ui messages . core utility buildproject taskname , basic element labels . get resource name ( f project ) ) , 2 ) ;
f project . build ( incremental project builder . full build , sub monitor . split ( 1 ) ) ; dcnl java plugin . get workspace ( ) . build ( incremental project builder . incremental build , sub monitor . split ( 1 ) ) ;
import org . eclipse . jdt . core . i classpath entry ;
return ( module description info ) ( ( binary module ) module desc ) . get element info ( ) ;
import org . eclipse . jdt . core . dom . structural property descriptor ;
static class indexed parameter { dcnl int index ; dcnl string name ; dcnl indexed parameter ( int index , string name ) { dcnl this . index = index ; dcnl this . name = name ;
private single variable declaration f argument ; dcnl dcnl / / for lambda parameter ( can return null ) : dcnl static parameter annotation rewrite operation create ( compilation unit unit , lambda expression lambda , string annotation to add , string annotation to remove , indexed parameter parameter , boolean allow remove , string message ) { dcnl i method binding lambda method binding = lambda . resolve method binding ( ) ; dcnl list < ? > parameters = lambda . parameters ( ) ; dcnl if ( parameters . size ( ) > parameter . index ) { dcnl object param = parameters . get ( parameter . index ) ;
return new parameter annotation rewrite operation ( unit , lambda method binding , parameters , annotation to add , annotation to remove , parameter . index , allow remove , message ) ;
throw new runtime exception ( " argument " + parameter . name + " not found in method " + lambda . to string ( ) ) ; / / $non - nls - 1$ / / $non - nls - 2$
/ / for method parameter : dcnl parameter annotation rewrite operation ( compilation unit unit , method declaration method , string annotation to add , string annotation to remove , int param idx , boolean allow remove , string message ) { dcnl this ( unit , method . resolve binding ( ) , method . parameters ( ) , annotation to add , annotation to remove , param idx , allow remove , message ) ;
private parameter annotation rewrite operation ( compilation unit unit , i method binding method binding , list < ? > parameters , string annotation to add , string annotation to remove , int param idx , boolean allow remove , string message ) {
f key = method binding . get key ( ) ;
f argument = ( single variable declaration ) parameters . get ( param idx ) ;
parameter annotation rewrite operation . indexed parameter parameter = find parameter declaration ( selected node ) ; dcnl if ( parameter ! = null ) {
new object [ ] { parameter . name , annotation name label } ) ; dcnl return new parameter annotation rewrite operation ( compilation unit , method , annotation to add , annotation to remove , parameter . index , allow remove , message ) ;
new object [ ] { parameter . name , annotation name label } ) ; dcnl return parameter annotation rewrite operation . create ( compilation unit , lambda , annotation to add , annotation to remove , parameter , allow remove , message ) ;
case i problem . specd non null local variable comparison yields false : dcnl case i problem . redundant null check on specd non null local variable :
parameter = find referenced parameter ( selected node ) ; dcnl if ( parameter ! = null ) {
new object [ ] { parameter . name , annotation name label } ) ; dcnl return new parameter annotation rewrite operation ( compilation unit , declaration , annotation to add , annotation to remove , parameter . index , allow remove , message ) ;
new object [ ] { parameter . name , annotation name label } ) ; dcnl return parameter annotation rewrite operation . create ( compilation unit , lambda , annotation to add , annotation to remove , parameter , allow remove , message ) ;
method declaration overridden declaration = ( method declaration ) method decl ;
parameter annotation rewrite operation . indexed parameter parameter = find parameter declaration ( selected node ) ; / / parameter . name is determined from the current method , but this name will not be used here dcnl if ( parameter = = null ) dcnl return null ; dcnl return new parameter annotation rewrite operation ( compilation unit , overridden declaration , annotation to add , annotation to remove , parameter . index , allow remove , message ) ;
private static parameter annotation rewrite operation . indexed parameter find parameter declaration ( ast node selected node ) {
if ( arg decl ! = null ) { dcnl structural property descriptor location in parent = arg decl . get location in parent ( ) ; dcnl if ( !location in parent . is child list property ( ) ) dcnl return null ; dcnl list < ? > containing list = ( list < ? > ) arg decl . get parent ( ) . get structural property ( location in parent ) ; dcnl return new parameter annotation rewrite operation . indexed parameter ( containing list . index of ( arg decl ) , arg decl . get name ( ) . get identifier ( ) ) ; dcnl } dcnl return null ; dcnl } dcnl dcnl private static parameter annotation rewrite operation . indexed parameter find referenced parameter ( ast node selected node ) {
* copyright ( c ) 2005 , 2016 ibm corporation and others .
import org . eclipse . jdt . internal . corext . fix . type annotation rewrite operations . move type annotation rewrite operation ;
import org . eclipse . jdt . internal . ui . text . correction . type annotation sub processor ;
string message ; dcnl if ( type annotation sub processor . has fix for ( problem id ) ) { dcnl boolean is move = create move type annotation operations ( compilation unit , locations , operations ) ; dcnl message = is move ? fix messages . type annotation fix move : fix messages . type annotation fix remove ; dcnl } else { dcnl create add null annotation operations ( compilation unit , locations , operations ) ; dcnl create remove redundant null annotations operations ( compilation unit , locations , operations ) ; dcnl message = fix messages . null annotations fix add annotation change name ; dcnl }
case i problem . illegal type annotations in static member access : dcnl case i problem . type annotation at qualified name : dcnl case i problem . null annotation at qualifying type : dcnl case i problem . illegal annotation for base type :
req . declaration end = req . declaration source end = this . end statement position ;
req . declaration source end = impt . source end + 1 ;
req . source start = req . declaration source start = this . int stack [ this . int ptr - - ] ;
this . last check point = req . declaration source end ;
expt . declaration source end = this . end statement position ;
expt . source end = impt . source end ;
stmt . source end = impt . source end ;
expt . declaration source end = this . end statement position ;
if ( this . current token = = token name semicolon ) { dcnl node . declaration source end = node . source end + 1 ; dcnl } else { dcnl node . declaration source end = node . source end ; dcnl }
stmt . declaration end = stmt . declaration source end = this . end statement position ;
stmt . declaration source end = si name . source end + 1 ;
stmt . source start = stmt . declaration source start = this . int stack [ this . int ptr - - ] ; dcnl stmt . source end = si name . source end ;
ref . source end = si name . source end ; dcnl ref . declaration source end = ref . source end ;
ref . declaration end = ref . declaration source end = this . end statement position ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
import org . eclipse . jdt . ui . preference constants ;
if ( store . contains ( preference constants . editor text font ) & & !store . is default ( preference constants . editor text font ) ) { dcnl data = preference converter . get font data ( store , preference constants . editor text font ) ;
data = preference converter . get default font data ( store , preference constants . editor text font ) ;
check source range ( variable declaration expression , "y y4 = new y ( ) " , contents ) ;
* copyright ( c ) 2004 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
ast node . type method reference , dcnl ast node . module declaration , dcnl ast node . exports statement , dcnl ast node . requires statement , dcnl ast node . uses statement , dcnl ast node . provides statement , dcnl ast node . opens statement
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
public boolean fake in module = false ; dcnl
/ * * dcnl * creates and returns a new unparented exports statement dcnl * node for an unspecified , but legal , name ; no target modules dcnl * dcnl * @ return a new unparented exports statement node dcnl * @ exception unsupported operation exception if this operation is used in level less than jls9 dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public exports statement new exports statement ( ) { dcnl exports statement result = new exports statement ( this ) ; dcnl return result ; dcnl } dcnl
*
/ * * dcnl * creates and returns a new unparented module declaration dcnl * node for an unspecified , but legal , name ; no modifiers ; no javadoc ; dcnl * and an empty list of statements . dcnl * dcnl * @ return a new unparented module declaration node dcnl * @ exception unsupported operation exception if this operation is used in level less than jls9 dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public module declaration new module declaration ( ) { dcnl module declaration result = new module declaration ( this ) ; dcnl return result ; dcnl } dcnl
/ * * dcnl * creates and returns a new unparented opens statement dcnl * node for an unspecified , but legal , name ; no target modules dcnl * dcnl * @ return a new unparented opens statement node dcnl * @ exception unsupported operation exception if this operation is used in level less than jls9 dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public opens statement new opens statement ( ) { dcnl opens statement result = new opens statement ( this ) ; dcnl return result ; dcnl } dcnl
/ * * dcnl * creates and returns a new unparented provides statement dcnl * node for an unspecified , but legal , type ; no target types dcnl * dcnl * @ return a new unparented provides statement node dcnl * @ exception unsupported operation exception if this operation is used in level less than jls9 dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public provides statement new provides statement ( ) { dcnl provides statement result = new provides statement ( this ) ; dcnl return result ; dcnl } dcnl
/ * * dcnl * creates and returns a new unparented requires statement dcnl * node for an unspecified , but legal , name ; dcnl * dcnl * @ return a new unparented requires statement node dcnl * @ exception unsupported operation exception if this operation is used in level less than jls9 dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public requires statement new requires statement ( ) { dcnl requires statement result = new requires statement ( this ) ; dcnl return result ; dcnl } dcnl
import java . util . comparator ;
import java . util . tree set ;
import org . eclipse . jdt . internal . compiler . ast . module reference ;
if ( type instanceof module declaration ) dcnl compilation unit . set module ( ( module declaration ) type ) ; dcnl else dcnl compilation unit . types ( ) . add ( type ) ;
private module package access get package visibility statement ( dcnl org . eclipse . jdt . internal . compiler . ast . package visibility statement pvs stmt , module package access stmt ) { dcnl int source end = pvs stmt . declaration source end ; dcnl if ( pvs stmt . declaration end > source end ) source end = pvs stmt . declaration end ; / / todo : working around a compiler issue dcnl stmt . set name ( get updated simple name ( pvs stmt . pkg name , pvs stmt . pkg ref . source start , pvs stmt . pkg ref . source end ) ) ; dcnl int tmp = source end ; dcnl if ( pvs stmt . targets ! = null & & pvs stmt . targets . length > 0 ) { dcnl list < name > modules = stmt . modules ( ) ; dcnl for ( module reference module ref : pvs stmt . get targeted modules ( ) ) { dcnl modules . add ( get updated simple name ( module ref . module name , module ref . source start , module ref . source end ) ) ; dcnl if ( tmp < module ref . source end ) tmp = module ref . source end ; dcnl } dcnl } dcnl if ( tmp > source end ) source end = tmp ; dcnl stmt . set source range ( pvs stmt . declaration source start , source end - pvs stmt . declaration source start + 1 ) ; dcnl return stmt ; dcnl } dcnl
interface i get java doc { dcnl javadoc get java doc ( ) ; dcnl } dcnl interface i set java doc { dcnl void set javadoc ( javadoc javadoc ) ; dcnl } dcnl public void convert ( org . eclipse . jdt . internal . compiler . ast . javadoc javadoc , i get java doc get j , i set java doc set j ) { dcnl if ( get j . get java doc ( ) = = null ) { dcnl javadoc doc comment = convert ( javadoc ) ; dcnl if ( doc comment ! = null ) dcnl set j . set javadoc ( doc comment ) ; dcnl } dcnl } dcnl private javadoc convert ( org . eclipse . jdt . internal . compiler . ast . javadoc javadoc ) { dcnl javadoc doc comment = null ; dcnl if ( javadoc ! = null ) { dcnl if ( this . comment mapper = = null | | !this . comment mapper . has same table ( this . comments table ) ) { dcnl this . comment mapper = new default comment mapper ( this . comments table ) ; dcnl } dcnl comment comment = this . comment mapper . get comment ( javadoc . source start ) ; dcnl if ( comment ! = null & & comment . is doc comment ( ) & & comment . get parent ( ) = = null ) { dcnl doc comment = ( javadoc ) comment ; dcnl if ( this . resolve bindings ) { dcnl record nodes ( doc comment , javadoc ) ; dcnl / / resolve member and method references binding dcnl iterator tags = doc comment . tags ( ) . list iterator ( ) ; dcnl while ( tags . has next ( ) ) { dcnl record nodes ( javadoc , ( tag element ) tags . next ( ) ) ;
return doc comment ; dcnl } dcnl public void convert ( org . eclipse . jdt . internal . compiler . ast . javadoc javadoc , body declaration body declaration ) { dcnl convert ( javadoc , body declaration : : get javadoc , body declaration : : set javadoc ) ; dcnl } dcnl public void convert ( org . eclipse . jdt . internal . compiler . ast . javadoc javadoc , module declaration module declaration ) { dcnl convert ( javadoc , module declaration : : get javadoc , module declaration : : set javadoc ) ;
if ( this . ast . api level = = ast . jls2 internal ) return ; dcnl convert ( javadoc , package declaration : : get javadoc , package declaration : : set javadoc ) ;
case org . eclipse . jdt . internal . compiler . ast . type declaration . module decl : dcnl return convert to module declaration ( type declaration ) ;
public module declaration convert to module declaration ( org . eclipse . jdt . internal . compiler . ast . type declaration type declaration ) { dcnl check canceled ( ) ; dcnl if ( this . scanner . source level < class file constants . jdk9 ) return null ; dcnl org . eclipse . jdt . internal . compiler . ast . module declaration module declaration = ( org . eclipse . jdt . internal . compiler . ast . module declaration ) type declaration ; dcnl module declaration module decl = this . ast . new module declaration ( ) ; dcnl convert ( module declaration . javadoc , module decl ) ; dcnl set modifiers ( module decl , module declaration ) ; dcnl simple name module name = get updated simple name ( module declaration . module name , module declaration . source start , module declaration . source end ) ; dcnl module decl . set name ( module name ) ; dcnl module decl . set source range ( module declaration . declaration source start , module declaration . declaration source end - module declaration . declaration source start + 1 ) ; dcnl dcnl list < module statement > stmts = module decl . module statements ( ) ; dcnl tree set < module statement > t set = new tree set < > ( new comparator ( ) { dcnl public int compare ( object o1 , object o2 ) { dcnl int p1 = ( ( module statement ) o1 ) . get start position ( ) ; dcnl int p2 = ( ( module statement ) o2 ) . get start position ( ) ; dcnl return p1 < p2 ? - 1 : p1 = = p2 ? 0 : 1 ; dcnl } dcnl } ) ; dcnl for ( int i = 0 ; i < module declaration . exports count ; + + i ) { dcnl t set . add ( get package visibility statement ( module declaration . exports [ i ] , new exports statement ( this . ast ) ) ) ; dcnl } dcnl for ( int i = 0 ; i < module declaration . opens count ; + + i ) { dcnl t set . add ( get package visibility statement ( module declaration . opens [ i ] , new opens statement ( this . ast ) ) ) ; dcnl } dcnl for ( int i = 0 ; i < module declaration . requires count ; + + i ) { dcnl org . eclipse . jdt . internal . compiler . ast . requires statement req = module declaration . requires [ i ] ; dcnl module reference module ref = req . module ; dcnl requires statement stmt = new requires statement ( this . ast ) ; dcnl simple name name = get updated simple name ( module ref . module name , module ref . source start , module ref . source end ) ; dcnl stmt . set name ( name ) ; dcnl dcnl add modifier to requires ( req , req . is transitive ( ) , modifier . modifier keyword . transient keyword , stmt ) ; dcnl add modifier to requires ( req , req . is static ( ) , modifier . modifier keyword . static keyword , stmt ) ; dcnl stmt . set source range ( req . declaration source start , req . declaration end - req . declaration source start + 1 ) ; dcnl t set . add ( stmt ) ; dcnl } dcnl for ( int i = 0 ; i < module declaration . uses count ; + + i ) { dcnl org . eclipse . jdt . internal . compiler . ast . uses statement uses statement = module declaration . uses [ i ] ; dcnl uses statement stmt = new uses statement ( this . ast ) ; dcnl type reference uses ref = uses statement . service interface ; dcnl stmt . set type ( convert type ( uses ref ) ) ; dcnl stmt . set source range ( uses statement . declaration source start , uses statement . declaration source end - uses statement . declaration source start + 1 ) ; dcnl t set . add ( stmt ) ; dcnl } dcnl for ( int i = 0 ; i < module declaration . services count ; + + i ) { dcnl org . eclipse . jdt . internal . compiler . ast . provides statement p stmt = module declaration . services [ i ] ; dcnl provides statement stmt = new provides statement ( this . ast ) ; dcnl stmt . set type ( convert type ( p stmt . service interface ) ) ; dcnl type reference [ ] impls = p stmt . implementations ; dcnl for ( type reference impl : impls ) { dcnl stmt . implementations ( ) . add ( convert type ( impl ) ) ; dcnl } dcnl stmt . set source range ( p stmt . declaration source start , p stmt . declaration end - p stmt . declaration source start + 1 ) ; dcnl t set . add ( stmt ) ; dcnl } dcnl / / the javadoc comment is now got from list store in compilation unit declaration dcnl if ( this . resolve bindings ) { dcnl record nodes ( module decl , module declaration ) ; dcnl record nodes ( module name , module declaration ) ; dcnl / / module decl . resolve binding ( ) ; todo : implement resolve binding dcnl } dcnl stmts . add all ( t set ) ; dcnl return module decl ; dcnl } dcnl dcnl private void add modifier to requires ( org . eclipse . jdt . internal . compiler . ast . requires statement req , boolean flag , modifier . modifier keyword keyword , dcnl requires statement stmt ) { dcnl if ( flag ) { dcnl modifier modifier = create modifier ( keyword ) ; dcnl modifier . set source range ( req . modifiers source start , keyword . to string ( ) . length ( ) ) ; dcnl stmt . modifiers ( ) . add ( modifier ) ; dcnl } dcnl } dcnl
private simple name get updated simple name ( char [ ] s , int source start , int source end ) { dcnl simple name name = new simple name ( this . ast ) ; dcnl name . set identifier ( new string ( s ) ) ; dcnl name . set source range ( source start , source end - source start + 1 ) ; dcnl return name ; dcnl }
set modifiers ( body declaration . modifiers ( ) , annotations , modifiers end ) ; dcnl } dcnl protected void set modifiers ( list modifiers , org . eclipse . jdt . internal . compiler . ast . annotation [ ] annotations , int modifiers end ) {
modifiers . add ( modifier ) ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
safe subtree match ( node . get module ( ) , o . get module ( ) ) dcnl & & safe subtree match ( node . get package ( ) , o . get package ( ) )
/ * * dcnl * returns whether the given node and the other object match . dcnl * < p > dcnl * the default implementation provided by this class tests whether the dcnl * other object is a node of the same type with structurally isomorphic dcnl * child subtrees . subclasses may override this method as needed . dcnl * < / p > dcnl * dcnl * @ param node the node dcnl * @ param other the other object , or < code > null < / code > dcnl * @ return < code > true < / code > if the subtree matches , or dcnl * < code > false < / code > if they do not match or the other object has a dcnl * different node type or is < code > null < / code > dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean match ( exports statement node , object other ) { dcnl if ( ! ( other instanceof exports statement ) ) { dcnl return false ; dcnl } dcnl exports statement o = ( exports statement ) other ; dcnl return ( dcnl safe subtree match ( node . get name ( ) , o . get name ( ) ) dcnl & & safe subtree list match ( node . modules ( ) , o . modules ( ) ) ) ; dcnl } dcnl
/ * * dcnl * returns whether the given node and the other object match . dcnl * < p > dcnl * the default implementation provided by this class tests whether the dcnl * other object is a node of the same type with structurally isomorphic dcnl * child subtrees . subclasses may override this method as needed . dcnl * < / p > dcnl * dcnl * @ param node the node dcnl * @ param other the other object , or < code > null < / code > dcnl * @ return < code > true < / code > if the subtree matches , or dcnl * < code > false < / code > if they do not match or the other object has a dcnl * different node type or is < code > null < / code > dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean match ( module declaration node , object other ) { dcnl if ( ! ( other instanceof module declaration ) ) { dcnl return false ; dcnl } dcnl module declaration o = ( module declaration ) other ; dcnl return ( safe subtree match ( node . get javadoc ( ) , o . get javadoc ( ) ) dcnl & & safe subtree list match ( node . modifiers ( ) , o . modifiers ( ) ) dcnl & & safe subtree match ( node . get name ( ) , o . get name ( ) ) dcnl & & safe subtree list match ( node . module statements ( ) , o . module statements ( ) ) ) ; dcnl } dcnl
/ * * dcnl * returns whether the given node and the other object match . dcnl * < p > dcnl * the default implementation provided by this class tests whether the dcnl * other object is a node of the same type with structurally isomorphic dcnl * child subtrees . subclasses may override this method as needed . dcnl * < / p > dcnl * dcnl * @ param node the node dcnl * @ param other the other object , or < code > null < / code > dcnl * @ return < code > true < / code > if the subtree matches , or dcnl * < code > false < / code > if they do not match or the other object has a dcnl * different node type or is < code > null < / code > dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean match ( opens statement node , object other ) { dcnl if ( ! ( other instanceof opens statement ) ) { dcnl return false ; dcnl } dcnl opens statement o = ( opens statement ) other ; dcnl return ( dcnl safe subtree match ( node . get name ( ) , o . get name ( ) ) dcnl & & safe subtree list match ( node . modules ( ) , o . modules ( ) ) ) ; dcnl } dcnl
/ * * dcnl * returns whether the given node and the other object match . dcnl * < p > dcnl * the default implementation provided by this class tests whether the dcnl * other object is a node of the same type with structurally isomorphic dcnl * child subtrees . subclasses may override this method as needed . dcnl * < / p > dcnl * dcnl * @ param node the node dcnl * @ param other the other object , or < code > null < / code > dcnl * @ return < code > true < / code > if the subtree matches , or dcnl * < code > false < / code > if they do not match or the other object has a dcnl * different node type or is < code > null < / code > dcnl * @ since 3 . 13 beta java9 dcnl dcnl * / dcnl public boolean match ( provides statement node , object other ) { dcnl if ( ! ( other instanceof provides statement ) ) { dcnl return false ; dcnl } dcnl provides statement o = ( provides statement ) other ; dcnl return ( dcnl safe subtree match ( node . get type ( ) , o . get type ( ) ) dcnl & & safe subtree list match ( node . implementations ( ) , o . implementations ( ) ) ) ; dcnl } dcnl
/ * * dcnl * returns whether the given node and the other object match . dcnl * < p > dcnl * the default implementation provided by this class tests whether the dcnl * other object is a node of the same type with structurally isomorphic dcnl * child subtrees . subclasses may override this method as needed . dcnl * < / p > dcnl * dcnl * @ param node the node dcnl * @ param other the other object , or < code > null < / code > dcnl * @ return < code > true < / code > if the subtree matches , or dcnl * < code > false < / code > if they do not match or the other object has a dcnl * different node type or is < code > null < / code > dcnl * dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean match ( requires statement node , object other ) { dcnl if ( ! ( other instanceof requires statement ) ) { dcnl return false ; dcnl } dcnl requires statement o = ( requires statement ) other ; dcnl return safe subtree list match ( node . modifiers ( ) , o . modifiers ( ) ) dcnl & & safe subtree match ( node . get name ( ) , o . get name ( ) ) ; dcnl } dcnl
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
/ * * dcnl * node type constant indicating a node of type dcnl * < code > module declaration < / code > . dcnl * @ see module declaration dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public static final int module declaration = 93 ; dcnl dcnl / * * dcnl * node type constant indicating a node of type dcnl * < code > exports statement < / code > . dcnl * @ see exports statement dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public static final int exports statement = 94 ; dcnl dcnl / * * dcnl * node type constant indicating a node of type dcnl * < code > requires statement < / code > . dcnl * @ see requires statement dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public static final int requires statement = 95 ; dcnl dcnl / * * dcnl * node type constant indicating a node of type dcnl * < code > uses statement < / code > . dcnl * @ see uses statement dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public static final int uses statement = 96 ; dcnl dcnl / * * dcnl * node type constant indicating a node of type dcnl * < code > provides statement < / code > . dcnl * @ see provides statement dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public static final int provides statement = 97 ; dcnl dcnl / * * dcnl * node type constant indicating a node of type dcnl * < code > opens statement < / code > . dcnl * @ see opens statement dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public static final int opens statement = 98 ;
case exports statement : dcnl return exports statement . class ;
case module declaration : dcnl return module declaration . class ;
case opens statement : dcnl return opens statement . class ;
case provides statement : dcnl return provides statement . class ;
case requires statement : dcnl return requires statement . class ;
case uses statement : dcnl return uses statement . class ;
dcnl / * * dcnl * checks that this ast operation is not used when dcnl * building jls2 , jls3 , jls4 or jls8 level as ts . dcnl * < p > dcnl * use this method to prevent access to new properties that have been added in jls9 . dcnl * < / p > dcnl * dcnl * @ exception unsupported operation exception if this operation is used below jls9 dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl final void unsupported below9 ( ) { dcnl if ( this . ast . api level < ast . jls9 ) { dcnl throw new unsupported operation exception ( " operation only supported in jls9 and later ast" ) ; / / $non - nls - 1$ dcnl } dcnl }
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
/ * * dcnl * visits the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing and return true . dcnl * subclasses may re - implement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ return < code > true < / code > if the children of this node should be dcnl * visited , and < code > false < / code > if the children of this node should dcnl * be skipped dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean visit ( exports statement node ) { dcnl return true ; dcnl } dcnl
/ * * dcnl * visits the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing and return true . dcnl * subclasses may reimplement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ return < code > true < / code > if the children of this node should be dcnl * visited , and < code > false < / code > if the children of this node should dcnl * be skipped dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean visit ( module declaration node ) { dcnl return true ; dcnl } dcnl
/ * * dcnl * visits the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing and return true . dcnl * subclasses may re - implement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ return < code > true < / code > if the children of this node should be dcnl * visited , and < code > false < / code > if the children of this node should dcnl * be skipped dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean visit ( opens statement node ) { dcnl return true ; dcnl } dcnl
/ * * dcnl * visits the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing and return true . dcnl * subclasses may re - implement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ return < code > true < / code > if the children of this node should be dcnl * visited , and < code > false < / code > if the children of this node should dcnl * be skipped dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean visit ( provides statement node ) { dcnl return true ; dcnl } dcnl
/ * * dcnl * visits the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing and return true . dcnl * subclasses may re - implement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ return < code > true < / code > if the children of this node should be dcnl * visited , and < code > false < / code > if the children of this node should dcnl * be skipped dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean visit ( requires statement node ) { dcnl return true ; dcnl } dcnl
/ * * dcnl * visits the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing and return true . dcnl * subclasses may re - implement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ return < code > true < / code > if the children of this node should be dcnl * visited , and < code > false < / code > if the children of this node should dcnl * be skipped dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public boolean visit ( uses statement node ) { dcnl return true ; dcnl } dcnl
/ * * dcnl * end of visit the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing . subclasses may reimplement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public void end visit ( exports statement node ) { dcnl / / default implementation : do nothing dcnl } dcnl
/ * * dcnl * end of visit the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing . subclasses may reimplement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public void end visit ( module declaration node ) { dcnl / / default implementation : do nothing dcnl } dcnl
/ * * dcnl * end of visit the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing . subclasses may reimplement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public void end visit ( opens statement node ) { dcnl / / default implementation : do nothing dcnl } dcnl
/ * * dcnl * end of visit the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing . subclasses may reimplement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public void end visit ( provides statement node ) { dcnl / / default implementation : do nothing dcnl } dcnl
/ * * dcnl * end of visit the given type - specific ast node . dcnl * < p > dcnl * the default implementation does nothing . subclasses may reimplement . dcnl * < / p > dcnl * dcnl * @ param node the node to visit dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public void end visit ( requires statement node ) { dcnl / / default implementation : do nothing dcnl } dcnl
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* from jls 9 onwards , this can contain a module declation . to be noted that not dcnl * all nodes make sense in all contexts .
* { type declaration | enum declaration | annotation type declaration | module declaration < b > ; < / b > }
/ * * dcnl * the "module" structural property of this node type ( child type : { @ link module declaration } ) . dcnl * dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public static final child property descriptor module property = dcnl new child property descriptor ( compilation unit . class , "module" , module declaration . class , optional , no cycle risk ) ; / / $non - nls - 1$ dcnl
/ * * dcnl * a list of property descriptors ( element type : dcnl * { @ link structural property descriptor } ) , dcnl * or null if uninitialized . dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl private static final list property descriptors 9 0 ; dcnl
dcnl propery list = new array list ( 5 ) ; dcnl create property list ( compilation unit . class , propery list ) ; dcnl add property ( package property , propery list ) ; dcnl add property ( imports property , propery list ) ; dcnl add property ( types property , propery list ) ; dcnl add property ( module property , propery list ) ; dcnl property descriptors 9 0 = reap property list ( propery list ) ;
if ( api level < ast . jls9 ) dcnl return property descriptors ; dcnl else dcnl return property descriptors 9 0 ;
/ * * dcnl * the module declaration , or < code > null < / code > if none ; initially dcnl * < code > null < / code > . dcnl * / dcnl private module declaration module = null ;
accept child ( visitor , get module ( ) ) ;
result . set module ( ( module declaration ) ast node . copy subtree ( target , get module ( ) ) ) ;
/ * * dcnl * returns the node for the module declaration of this compilation dcnl * unit , or < code > null < / code > if this compilation unit has a module dcnl * dcnl * @ return the module declaration node , or < code > null < / code > if none dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public module declaration get module ( ) { dcnl return this . module ; dcnl } dcnl
if ( property = = module property ) { dcnl if ( get ) { dcnl return get module ( ) ; dcnl } else { dcnl set module ( ( module declaration ) child ) ; dcnl return null ; dcnl } dcnl }
/ * * dcnl * sets or clears the module declaration of this compilation unit dcnl * node to the given module declaration node . dcnl * dcnl * @ param module the new module declaration node , or dcnl * < code > null < / code > if this compilation unit does not have a module dcnl * @ exception illegal argument exception if : dcnl * < ul > dcnl * < li > the node belongs to a different ast < / li > dcnl * < li > the node already has a parent < / li > dcnl * < / ul > dcnl * @ since 3 . 13 beta java9 dcnl * / dcnl public void set module ( module declaration module ) { dcnl ast node old child = this . module ; dcnl pre replace child ( old child , module , package property ) ; dcnl this . module = module ; dcnl post replace child ( old child , module , package property ) ; dcnl } dcnl
private void print types ( list < type > types , string prefix ) { dcnl if ( types . size ( ) > 0 ) { dcnl this . buffer . append ( " " + prefix + " " ) ; / / $non - nls - 1$ / / $non - nls - 2$ dcnl type type = types . get ( 0 ) ; dcnl type . accept ( this ) ; dcnl for ( int i = 1 , l = types . size ( ) ; i < l ; + + i ) { dcnl this . buffer . append ( " , " ) ; / / $non - nls - 1$ dcnl type = types . get ( 0 ) ; dcnl type . accept ( this ) ; dcnl } dcnl } dcnl } dcnl
* dcnl * @ param type arguments list of type arguments
@ override dcnl public boolean visit ( exports statement node ) { dcnl return visit ( node , "exports" ) ; / / $non - nls - 1$ dcnl } dcnl
*
@ override dcnl public boolean visit ( module declaration node ) { dcnl print modifiers ( node . modifiers ( ) ) ; dcnl this . buffer . append ( "module" ) ; / / $non - nls - 1$ dcnl this . buffer . append ( " " ) ; / / $non - nls - 1$ dcnl node . get name ( ) . accept ( this ) ; dcnl this . buffer . append ( " { \ n" ) ; / / $non - nls - 1$ dcnl this . indent + + ; dcnl for ( module statement stmt : ( list < module statement > ) node . module statements ( ) ) { dcnl stmt . accept ( this ) ; dcnl } dcnl this . indent - - ; dcnl this . buffer . append ( " } " ) ; / / $non - nls - 1$ dcnl return false ; dcnl } dcnl dcnl private boolean visit ( module package access node , string keyword ) { dcnl print indent ( ) ; dcnl this . buffer . append ( keyword ) ; dcnl this . buffer . append ( " " ) ; / / $non - nls - 1$ dcnl node . get name ( ) . accept ( this ) ; dcnl print types ( node . modules ( ) , "to" ) ; / / $non - nls - 1$ dcnl this . buffer . append ( " ; \ n" ) ; / / $non - nls - 1$ dcnl return false ; dcnl } dcnl
@ override dcnl public boolean visit ( opens statement node ) { dcnl return visit ( node , "opens" ) ; / / $non - nls - 1$ dcnl } dcnl
@ override dcnl public boolean visit ( provides statement node ) { dcnl print indent ( ) ; dcnl this . buffer . append ( "provides" ) ; / / $non - nls - 1$ dcnl this . buffer . append ( " " ) ; / / $non - nls - 1$ dcnl node . get type ( ) . accept ( this ) ; dcnl print types ( node . implementations ( ) , "with" ) ; / / $non - nls - 1$ dcnl this . buffer . append ( " ; \ n" ) ; / / $non - nls - 1$ dcnl return false ; dcnl } dcnl
@ override dcnl public boolean visit ( requires statement node ) { dcnl print indent ( ) ; dcnl this . buffer . append ( "requires" ) ; / / $non - nls - 1$ dcnl this . buffer . append ( " " ) ; / / $non - nls - 1$ dcnl node . get name ( ) . accept ( this ) ; dcnl this . buffer . append ( " ; \ n" ) ; / / $non - nls - 1$ dcnl return false ; dcnl } dcnl
for ( int j = 2 ; j < 6 ; j + + ) {
for ( int j = 2 ; j < 6 ; j + + ) {
check source range ( variable declaration expression , "y y4 = new y ( ) " , contents ) ;
* copyright ( c ) 2004 , 2015 ibm corporation and others .
ast node . type method reference
compilation unit . types ( ) . add ( type ) ;
public void convert ( org . eclipse . jdt . internal . compiler . ast . javadoc javadoc , body declaration body declaration ) { dcnl if ( body declaration . get javadoc ( ) = = null ) { dcnl if ( javadoc ! = null ) { dcnl if ( this . comment mapper = = null | | !this . comment mapper . has same table ( this . comments table ) ) { dcnl this . comment mapper = new default comment mapper ( this . comments table ) ; dcnl } dcnl comment comment = this . comment mapper . get comment ( javadoc . source start ) ; dcnl if ( comment ! = null & & comment . is doc comment ( ) & & comment . get parent ( ) = = null ) { dcnl javadoc doc comment = ( javadoc ) comment ; dcnl if ( this . resolve bindings ) { dcnl record nodes ( doc comment , javadoc ) ; dcnl / / resolve member and method references binding dcnl iterator tags = doc comment . tags ( ) . list iterator ( ) ; dcnl while ( tags . has next ( ) ) { dcnl record nodes ( javadoc , ( tag element ) tags . next ( ) ) ; dcnl }
body declaration . set javadoc ( doc comment ) ;
switch ( this . ast . api level ) { dcnl case ast . jls2 internal : dcnl return ; dcnl } dcnl if ( package declaration . get javadoc ( ) = = null ) { dcnl if ( javadoc ! = null ) { dcnl if ( this . comment mapper = = null | | !this . comment mapper . has same table ( this . comments table ) ) { dcnl this . comment mapper = new default comment mapper ( this . comments table ) ; dcnl } dcnl comment comment = this . comment mapper . get comment ( javadoc . source start ) ; dcnl if ( comment ! = null & & comment . is doc comment ( ) & & comment . get parent ( ) = = null ) { dcnl javadoc doc comment = ( javadoc ) comment ; dcnl if ( this . resolve bindings ) { dcnl record nodes ( doc comment , javadoc ) ; dcnl / / resolve member and method references binding dcnl iterator tags = doc comment . tags ( ) . list iterator ( ) ; dcnl while ( tags . has next ( ) ) { dcnl record nodes ( javadoc , ( tag element ) tags . next ( ) ) ; dcnl } dcnl } dcnl package declaration . set javadoc ( doc comment ) ; dcnl } dcnl } dcnl }
* copyright ( c ) 2000 , 2014 ibm corporation and others .
* copyright ( c ) 2000 , 2013 ibm corporation and others .
* { type declaration | enum declaration | annotation type declaration | < b > ; < / b > }
return property descriptors ;
* dcnl * @ param type arguments list of type arguments
protected int flags ;
protected int opens count ;
protected package export info [ ] opens ;
protected module info ( byte class file bytes [ ] , int offsets [ ] , int offset ) {
int utf8 offset ; dcnl module info module = new module info ( class file bytes , offsets , 0 ) ; dcnl utf8 offset = module . constant pool offsets [ module . u2 at ( module offset ) ] ; dcnl module . name = module . utf8 at ( utf8 offset + 3 , module . u2 at ( utf8 offset + 1 ) ) ; dcnl char operation . replace ( module . name , ' / ' , ' . ' ) ; dcnl module offset + = 2 ; dcnl module . flags = module . u2 at ( module offset ) ; dcnl module offset + = 2 ; dcnl dcnl utf8 offset = module . constant pool offsets [ module . u2 at ( read offset ) ] ;
char operation . replace ( requires names , ' / ' , ' . ' ) ;
pack . modifiers = module . u2 at ( module offset ) ; dcnl module offset + = 2 ; dcnl int exportedto count = module . u2 at ( module offset ) ; dcnl module offset + = 2 ; dcnl if ( exportedto count > 0 ) { dcnl pack . exported to = new char [ exportedto count ] [ ] ; dcnl pack . exported to count = exportedto count ; dcnl for ( int k = 0 ; k < exportedto count ; k + + ) { dcnl utf8 offset = module . constant pool offsets [ module . u2 at ( module offset ) ] ; dcnl char [ ] exported to name = module . utf8 at ( utf8 offset + 3 , module . u2 at ( utf8 offset + 1 ) ) ; dcnl pack . exported to [ k ] = exported to name ; dcnl module offset + = 2 ; dcnl } dcnl } dcnl } dcnl count = module . u2 at ( module offset ) ; dcnl module offset + = 2 ; dcnl module . opens count = count ; dcnl module . opens = new package export info [ count ] ; dcnl for ( int i = 0 ; i < count ; i + + ) { dcnl utf8 offset = module . constant pool offsets [ module . u2 at ( module offset ) ] ; dcnl char [ ] exported = module . utf8 at ( utf8 offset + 3 , module . u2 at ( utf8 offset + 1 ) ) ; dcnl char operation . replace ( exported , ' / ' , ' . ' ) ; dcnl package export info pack = module . new package export info ( ) ; dcnl module . opens [ i ] = pack ; dcnl pack . package name = exported ; dcnl module offset + = 2 ; dcnl pack . modifiers = module . u2 at ( module offset ) ; dcnl module offset + = 2 ;
* @ param name a a potentially qualified name
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
/ / type in package info and module info must be fully qualified . dcnl if ( f compilation unit ! = null & & ( java model util . is package info ( f compilation unit ) | | java model util . is module info ( f compilation unit ) ) )
return true ;
string match10 = " - > / * [ 10 ] * / t . method2" ; dcnl offset = buf1 . to string ( ) . index of ( match10 ) + match10 . length ( ) ;
import org . eclipse . jdt . core . dom . qualified type ;
import org . eclipse . jdt . internal . core . manipulation . dom . ast resolving ; dcnl import org . eclipse . jdt . internal . core . manipulation . util . basic element labels ;
expression expr body = get single expression from lambda body ( lambda body ) ;
private static expression get single expression from lambda body ( block lambda body ) {
if ( is valid lambda expression body ( expression ) ) {
private static boolean is valid lambda expression body ( expression expression ) {
lambda = ast resolving . find enclosing lambda expression ( covering node ) ; dcnl if ( lambda = = null ) { dcnl return false ; dcnl }
expr body = get single expression from lambda body ( ( block ) lambda body ) ;
if ( expr body = = null | | !is valid lambda reference to method ( expr body ) ) dcnl return false ; dcnl dcnl if ( ! ( ast nodes . is parent ( expr body , covering node ) dcnl | | represents defining node ( covering node , expr body ) ) ) {
}
project . get project ( ) . clear cached dynamic references ( ) ;
private hash set < i java project > project reference changes = new hash set < > ( ) ;
}
public synchronized void add project reference change ( i java project project ) { dcnl this . project reference changes . add ( project ) ;
project . clear cached dynamic references ( ) ; dcnl this . state . add project reference change ( java project ) ;
change . project . get project ( ) . clear cached dynamic references ( ) ; dcnl this . state . add project reference change ( change . project ) ;
set < i java project > referenced projects = this . state . remove project reference changes ( ) ; dcnl need cycle validation = need cycle validation | | !referenced projects . is empty ( ) ;
public static final field long jdk level ;
jdk level = type . add long ( ) ;
private long jdk level ; dcnl
* copyright ( c ) 2014 , 2016 lars vogel and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
private static final int ast jls latest = ast . jls9 ;
ast node node = run conversion ( ast jls latest , contents , true , true , true , "p / x . java" ) ;
ast parser parser = ast parser . new parser ( ast jls latest ) ;
ast parser parser = ast parser . new parser ( ast jls latest ) ;
ast parser parser = ast parser . new parser ( ast jls latest ) ;
ast parser parser = ast parser . new parser ( ast jls latest ) ;
ast parser parser = ast parser . new parser ( ast jls latest ) ;
ast parser parser = ast parser . new parser ( ast jls latest ) ;
this . ast = ast . new ast ( ast internal jls9 ) ;
/ * * dcnl * internal synonym for constant ast . jsl9 dcnl * to alleviate deprecation warnings once ast . jls9 is deprecated in future . dcnl * / dcnl protected static final int ast internal jls9 = ast . jls9 ; dcnl
/ * * dcnl * internal synonym for deprecated constant ast . jsl8 dcnl * to alleviate deprecation warnings . dcnl * @ deprecated dcnl * / dcnl / * package * / static final int ast internal jls8 = ast . jls8 ;
jls level = ast internal jls9 ;
* copyright ( c ) 2000 , 2016 ibm corporation and others .
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
import org . eclipse . jdt . core . dom . ast ;
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
* this is an implementation of an early - draft specification developed under the java dcnl * community process ( jcp ) and is made available for testing and evaluation purposes dcnl * only . the code is not compatible with any specification of the jcp . dcnl *
ast parser parser = ast parser . new parser ( ast internal jls9 ) ;
ast parser parser = ast parser . new parser ( ast internal jls9 ) ;
ast parser parser = ast parser . new parser ( ast internal jls9 ) ;
ast parser parser = ast parser . new parser ( ast internal jls9 ) ;
* the "module" structural property of this node type ( child type : { @ link module declaration } ) ( added in jls9 api ) .
if ( api level < ast . jls9 internal )
if ( this . ast . api level > = ast . jls9 internal ) { dcnl accept child ( visitor , get module ( ) ) ; dcnl }
if ( this . ast . api level > = ast . jls9 internal ) { dcnl result . set module ( ( module declaration ) ast node . copy subtree ( target , get module ( ) ) ) ; dcnl }
* unit , or < code > null < / code > if this compilation unit is not a module info .
import org . eclipse . jdt . internal . compiler . lookup . module binding ;
if ( char operation . ends with ( name , type constants . module info file name ) )
module binding binding = module . module binding ;
this . constant pool . literal index ( binding . constant pool name ( ) ) ;
int flags = module . modifiers & ~ ( class file constants . acc module ) ;
module binding java base binding = null ;
module binding req binding = binding . environment . get module ( req . module . module name ) ;
java base binding = req binding ;
int name index = this . constant pool . literal index ( req binding . constant pool name ( ) ) ;
if ( java base binding = = null ) {
java base binding = binding . environment . get module ( type constants . java base ) ; dcnl int javabase index = this . constant pool . literal index ( java base binding . constant pool name ( ) ) ;
int name index = this . constant pool . literal index ( char operation . replace on copy ( ref . pkg name , ' . ' , ' / ' ) ) ;
name index = this . constant pool . literal index ( char operation . replace on copy ( ref . targets [ j ] . module name , ' . ' , ' / ' ) ) ;
int name index = this . constant pool . literal index ( char operation . replace on copy ( ref . pkg name , ' . ' , ' / ' ) ) ;
name index = this . constant pool . literal index ( char operation . replace on copy ( ref . targets [ j ] . module name , ' . ' , ' / ' ) ) ;
attr length + = opens size ;
private char [ ] constant pool name ; dcnl
if ( parent ! = null ) { dcnl switch ( parent . get node type ( ) ) { dcnl case ast node . type declaration : dcnl if ( node . get location in parent ( ) = = type declaration . super interface types property ) { dcnl kind = similar elements requestor . interfaces ; dcnl } else if ( node . get location in parent ( ) = = type declaration . superclass type property ) { dcnl kind = similar elements requestor . classes ; dcnl } dcnl break ; dcnl case ast node . enum declaration :
break ; dcnl case ast node . method declaration : dcnl if ( node . get location in parent ( ) = = method declaration . thrown exception types property ) { dcnl kind = similar elements requestor . classes ; dcnl } else if ( node . get location in parent ( ) = = method declaration . return type2 property ) { dcnl kind = similar elements requestor . all types | similar elements requestor . voidtype ; dcnl } dcnl break ; dcnl case ast node . annotation type member declaration : dcnl kind = similar elements requestor . primitivetypes | similar elements requestor . annotations | similar elements requestor . enums ; dcnl break ; dcnl case ast node . instanceof expression : dcnl kind = similar elements requestor . ref types ; dcnl break ; dcnl case ast node . throw statement :
break ; dcnl case ast node . class instance creation : dcnl if ( ( ( class instance creation ) parent ) . get anonymous class declaration ( ) = = null ) { dcnl kind = similar elements requestor . classes ; dcnl } else { dcnl kind = similar elements requestor . classes | similar elements requestor . interfaces ; dcnl } dcnl break ; dcnl case ast node . single variable declaration : dcnl int super parent = parent . get parent ( ) . get node type ( ) ; dcnl if ( super parent = = ast node . catch clause ) { dcnl kind = similar elements requestor . classes ; dcnl } else if ( super parent = = ast node . enhanced for statement ) { dcnl kind = similar elements requestor . ref types ; dcnl } dcnl break ; dcnl case ast node . tag element :
char operation . replace ( exported to name , ' / ' , ' . ' ) ;
char operation . replace ( exported to name , ' / ' , ' . ' ) ;
import org . eclipse . jdt . internal . compiler . lookup . parameterized method binding ;
/ * * not per jls : pushing bounds from inner to outer may have to be deferred till after overload resolution , store here a runnable to perform the push . * / dcnl private runnable push to outer job = null ;
boolean deferred = outer . current invocation instanceof invocation ; / / need to wait till after overload resolution ? dcnl bound set to push = deferred ? this . current bounds . copy ( ) : this . current bounds ; dcnl runnable job = ( ) - > { dcnl if ( outer . directly accepting inner bounds ) { dcnl outer . current bounds . add bounds ( to push , this . environment ) ; dcnl } else if ( outer . inner inbox = = null ) { dcnl outer . inner inbox = deferred ? to push : to push . copy ( ) ; / / copy now , unless already copied on behalf of 'deferred' dcnl } else { dcnl outer . inner inbox . add bounds ( to push , this . environment ) ; dcnl } dcnl } ; dcnl if ( deferred ) { dcnl this . push to outer job = job ;
job . run ( ) ; / / todo ( stephan ) : ever reached ? for reference expression ? ( would need a corresponding new call to flush bound outbox ( ) ) .
import java . util . arrays ; dcnl import java . util . comparator ;
import org . eclipse . jdt . internal . codeassist . select . selection on export reference ;
m . collect all dependencies ( deps ) ;
m . collect transitive dependencies ( deps ) ;
if ( this . is auto ) { / / all packages are exported by an automatic module dcnl return true ; dcnl }
if ( this . is auto ) { / / all packages are exported by an automatic module dcnl return get declared package ( char operation . split on ( ' . ' , qualified package name ) ) ; dcnl }
import java . util . stream . collectors ;
